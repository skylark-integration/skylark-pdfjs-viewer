{"version":3,"sources":["pdf_single_page_viewer.js"],"names":["define","pdfjsLib","base_viewer","BaseViewer","shadow","PDFSinglePageViewer","[object Object]","options","super","this","eventBus","_on","evt","_ensurePageViewVisible","_viewerElement","_shadowViewer","_pageWidthScaleFactor","_resetView","_previousPageNumber","document","createDocumentFragment","_updateScrollDown","pageView","_pages","_currentPageNumber","previousPageView","viewerNodes","viewer","childNodes","length","appendChild","div","Error","container","scrollTop","_scrollUpdate","pageDiv","pageSpot","pageNumber","_setCurrentPageNumber","scrolledDown","update","_scrollIntoView","scroll","down","_getCurrentVisiblePage","visiblePages","_isScrollModeHorizontal"],"mappings":";;;;;;;AAAAA,QACE,wBACA,iBACA,SAASC,EAASC,GAgBlB,MAAMC,WAAEA,GAAeD,GACjBE,OAAEA,GAAWH,EAiHnB,OAASI,kCA/GyBF,EAChCG,YAAYC,GACVC,MAAMD,GAENE,KAAKC,SAASC,IAAI,YAAaC,IAG7BH,KAAKI,2BAITC,qBAKE,OAAOV,EAAOK,KAAM,iBAAkBA,KAAKM,eAG7CC,4BACE,OAAO,EAGTV,aACEE,MAAMS,aACNR,KAAKS,oBAAsB,EAC3BT,KAAKM,cAAgBI,SAASC,yBAC9BX,KAAKY,kBAAoB,KAG3Bf,yBACE,MAAMgB,EAAWb,KAAKc,OAAOd,KAAKe,mBAAqB,GACjDC,EAAmBhB,KAAKc,OAAOd,KAAKS,oBAAsB,GAE1DQ,EAAcjB,KAAKkB,OAAOC,WAChC,OAAQF,EAAYG,QAClB,KAAK,EACHpB,KAAKkB,OAAOG,YAAYR,EAASS,KACjC,MACF,KAAK,EACH,GAAIL,EAAY,KAAOD,EAAiBM,IACtC,MAAM,IAAIC,MACR,+DAGJ,GAAIV,IAAaG,EACf,MAGFhB,KAAKM,cAAce,YAAYL,EAAiBM,KAChDtB,KAAKkB,OAAOG,YAAYR,EAASS,KAEjCtB,KAAKwB,UAAUC,UAAY,EAC3B,MACF,QACE,MAAM,IAAIF,MACR,sEAGNvB,KAAKS,oBAAsBT,KAAKe,mBAGlClB,gBACMG,KAAKY,mBACPZ,KAAKY,oBAEPb,MAAM2B,gBAGR7B,iBAAgB8B,QAAEA,EAAOC,SAAEA,EAAW,KAAIC,WAAEA,EAAa,OACnDA,GAEF7B,KAAK8B,sBAAsBD,GAE7B,MAAME,EAAe/B,KAAKe,oBAAsBf,KAAKS,oBAErDT,KAAKI,yBAGLJ,KAAKgC,SAELjC,MAAMkC,iBAAkBN,QAAAA,EAASC,SAAAA,EAAUC,WAAAA,IAI3C7B,KAAKY,kBAAoB,MACvBZ,KAAKkC,OAAOC,KAAOJ,EACnB/B,KAAKY,kBAAoB,OAI7Bf,mBACE,OAAOG,KAAKoC,yBAGdvC,cAAcwC,IAEdC,8BAEE,OAAO3C,EAAOK,KAAM,2BAA2B,GAGjDH,qBAEAA,qBAEAA,kBACE,OAAO","file":"../pdf_single_page_viewer.js","sourcesContent":["define([\n  \"skylark-pdfjs-display\",\n  \"./base_viewer\"\n],function(pdfjsLib,base_viewer){\n  /* Copyright 2017 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { BaseViewer } = base_viewer;\n  const { shadow } = pdfjsLib;\n\n  class PDFSinglePageViewer extends BaseViewer {\n    constructor(options) {\n      super(options);\n\n      this.eventBus._on(\"pagesinit\", evt => {\n        // Since the pages are placed in a `DocumentFragment`, make sure that\n        // the current page becomes visible upon loading of the document.\n        this._ensurePageViewVisible();\n      });\n    }\n\n    get _viewerElement() {\n      // Since we only want to display *one* page at a time when using the\n      // `PDFSinglePageViewer`, we cannot append them to the `viewer` DOM element.\n      // Instead, they are placed in a `DocumentFragment`, and only the current\n      // page is displayed in the viewer (refer to `this._ensurePageViewVisible`).\n      return shadow(this, \"_viewerElement\", this._shadowViewer);\n    }\n\n    get _pageWidthScaleFactor() {\n      return 1;\n    }\n\n    _resetView() {\n      super._resetView();\n      this._previousPageNumber = 1;\n      this._shadowViewer = document.createDocumentFragment();\n      this._updateScrollDown = null;\n    }\n\n    _ensurePageViewVisible() {\n      const pageView = this._pages[this._currentPageNumber - 1];\n      const previousPageView = this._pages[this._previousPageNumber - 1];\n\n      const viewerNodes = this.viewer.childNodes;\n      switch (viewerNodes.length) {\n        case 0: // Should *only* occur on initial loading.\n          this.viewer.appendChild(pageView.div);\n          break;\n        case 1: // The normal page-switching case.\n          if (viewerNodes[0] !== previousPageView.div) {\n            throw new Error(\n              \"_ensurePageViewVisible: Unexpected previously visible page.\"\n            );\n          }\n          if (pageView === previousPageView) {\n            break; // The correct page is already visible.\n          }\n          // Switch visible pages, and reset the viewerContainer scroll position.\n          this._shadowViewer.appendChild(previousPageView.div);\n          this.viewer.appendChild(pageView.div);\n\n          this.container.scrollTop = 0;\n          break;\n        default:\n          throw new Error(\n            \"_ensurePageViewVisible: Only one page should be visible at a time.\"\n          );\n      }\n      this._previousPageNumber = this._currentPageNumber;\n    }\n\n    _scrollUpdate() {\n      if (this._updateScrollDown) {\n        this._updateScrollDown();\n      }\n      super._scrollUpdate();\n    }\n\n    _scrollIntoView({ pageDiv, pageSpot = null, pageNumber = null }) {\n      if (pageNumber) {\n        // Ensure that `this._currentPageNumber` is correct.\n        this._setCurrentPageNumber(pageNumber);\n      }\n      const scrolledDown = this._currentPageNumber >= this._previousPageNumber;\n\n      this._ensurePageViewVisible();\n      // Ensure that rendering always occurs, to avoid showing a blank page,\n      // even if the current position doesn't change when the page is scrolled.\n      this.update();\n\n      super._scrollIntoView({ pageDiv, pageSpot, pageNumber });\n\n      // Since scrolling is tracked using `requestAnimationFrame`, update the\n      // scroll direction during the next `this._scrollUpdate` invocation.\n      this._updateScrollDown = () => {\n        this.scroll.down = scrolledDown;\n        this._updateScrollDown = null;\n      };\n    }\n\n    _getVisiblePages() {\n      return this._getCurrentVisiblePage();\n    }\n\n    _updateHelper(visiblePages) {}\n\n    get _isScrollModeHorizontal() {\n      // The Scroll/Spread modes are never used in `PDFSinglePageViewer`.\n      return shadow(this, \"_isScrollModeHorizontal\", false);\n    }\n\n    _updateScrollMode() {}\n\n    _updateSpreadMode() {}\n\n    _getPageAdvance() {\n      return 1;\n    }\n  }\n\n  return { PDFSinglePageViewer };\n});"]}