{"version":3,"sources":["chromecom.js"],"names":["define","PDFJSDev","app","app_options","download_manager","genericl10n","generic_scripting","DefaultExternalServices","PDFViewerApplication","AppOptions","BasePreferences","preferences","DownloadManager","GenericL10n","GenericScripting","test","Error","ChromeCom","[object Object]","action","data","callback","message","chrome","runtime","sendMessage","console","error","file","overlayManager","replace","location","origin","url","port","connect","name","onMessage","referer","state","window","history","chromecomState","replaceState","onDisconnect","removeListener","addListener","postMessage","requestUrl","setReferer","top","ancestorOrigins","request","getParentOrigin","getEmbedderOrigin","isAllowedFileSchemeAccess","isAllowedAccess","fileUrl","onCloseOverlay","addEventListener","reloadIfRuntimeIsUnavailable","removeEventListener","close","chromeFileAccessOverlayPromise","register","document","getElementById","then","iconPath","getManifest","icons","style","backgroundImage","getURL","i18nFileAccessLabel","json","i18n","getUILanguage","textContent","link","href","id","onclick","e","preventDefault","newTab","ctrlKey","metaKey","button","onchange","this","files","originalFilename","decodeURIComponent","split","pop","originalUrl","msg","confirm","value","encodeURIComponent","URL","createObjectURL","size","open","requestAccessToLocalFile","isRuntimeAvailable","reload","localStorage","setItem","Date","now","hidden","JSON","stringify","storageArea","storage","sync","local","ChromePreferences","prefObj","Promise","resolve","defaults","keysToRemove","Object","keys","remove","set","getPreferences","defaultPrefs","lastError","get","readPrefs","managed","defaultManagedPrefs","assign","enableHandToolOnLoad","disableTextLayer","enhanceTextSelection","showPreviousViewOnLoad","disablePageMode","items","cursorToolOnLoad","textLayerMode","viewOnLoad","externalServices","callbacks","resolvePDFFile","length","onOpenWithURL","options","navigator","language","sandboxBundleSrc"],"mappings":"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","file":"../chromecom.js","sourcesContent":["define([\n  \"./pdfjs_dev\",\n  \"./app\",\n  \"./app_options\",\n  \"./download_manager\",\n  \"./genericl10n\",\n  \"./generic_scripting\"\n],function(\n  PDFJSDev,\n  app,\n  app_options,\n  download_manager,\n  genericl10n,\n  generic_scripting\n){\n  /* Copyright 2013 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n  /* globals chrome */\n\n  const { DefaultExternalServices, PDFViewerApplication } = app;\n  const { AppOptions } = app_options;\n  const { BasePreferences } = preferences;\n  const { DownloadManager } = download_manager;\n  const { GenericL10n } = genericl10n;\n  const { GenericScripting } = generic_scripting;\n\n  if (typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"CHROME\")) {\n    throw new Error(\n      'Module \"pdfjs-web/chromecom\" shall not be used outside CHROME build.'\n    );\n  }\n\n  const ChromeCom = {\n    /**\n     * Creates an event that the extension is listening for and will\n     * asynchronously respond by calling the callback.\n     *\n     * @param {string} action - The action to trigger.\n     * @param {string} [data] - The data to send.\n     * @param {Function} [callback] - Response callback that will be called with\n     *   one data argument. When the request cannot be handled, the callback is\n     *   immediately invoked with no arguments.\n     */\n    request(action, data, callback) {\n      const message = {\n        action,\n        data,\n      };\n      if (!chrome.runtime) {\n        console.error(\"chrome.runtime is undefined.\");\n        if (callback) {\n          callback();\n        }\n      } else if (callback) {\n        chrome.runtime.sendMessage(message, callback);\n      } else {\n        chrome.runtime.sendMessage(message);\n      }\n    },\n\n    /**\n     * Resolves a PDF file path and attempts to detects length.\n     *\n     * @param {string} file - Absolute URL of PDF file.\n     * @param {OverlayManager} overlayManager - Manager for the viewer overlays.\n     * @param {Function} callback - A callback with resolved URL and file length.\n     */\n    resolvePDFFile(file, overlayManager, callback) {\n      // Expand drive:-URLs to filesystem URLs (Chrome OS)\n      file = file.replace(\n        /^drive:/i,\n        \"filesystem:\" + location.origin + \"/external/\"\n      );\n\n      if (/^https?:/.test(file)) {\n        // Assumption: The file being opened is the file that was requested.\n        // There is no UI to input a different URL, so this assumption will hold\n        // for now.\n        setReferer(file, function () {\n          callback(file);\n        });\n        return;\n      }\n      if (/^file?:/.test(file)) {\n        getEmbedderOrigin(function (origin) {\n          // If the origin cannot be determined, let Chrome decide whether to\n          // allow embedding files. Otherwise, only allow local files to be\n          // embedded from local files or Chrome extensions.\n          // Even without this check, the file load in frames is still blocked,\n          // but this may change in the future (https://crbug.com/550151).\n          if (origin && !/^file:|^chrome-extension:/.test(origin)) {\n            PDFViewerApplication.error(\n              \"Blocked \" +\n                origin +\n                \" from loading \" +\n                file +\n                \". Refused to load a local file in a non-local page \" +\n                \"for security reasons.\"\n            );\n            return;\n          }\n          isAllowedFileSchemeAccess(function (isAllowedAccess) {\n            if (isAllowedAccess) {\n              callback(file);\n            } else {\n              requestAccessToLocalFile(file, overlayManager, callback);\n            }\n          });\n        });\n        return;\n      }\n      callback(file);\n    },\n  };\n\n  function getEmbedderOrigin(callback) {\n    const origin = window === top ? location.origin : location.ancestorOrigins[0];\n    if (origin === \"null\") {\n      // file:-URLs, data-URLs, sandboxed frames, etc.\n      getParentOrigin(callback);\n    } else {\n      callback(origin);\n    }\n  }\n\n  function getParentOrigin(callback) {\n    ChromeCom.request(\"getParentOrigin\", null, callback);\n  }\n\n  function isAllowedFileSchemeAccess(callback) {\n    ChromeCom.request(\"isAllowedFileSchemeAccess\", null, callback);\n  }\n\n  function isRuntimeAvailable() {\n    try {\n      // When the extension is reloaded, the extension runtime is destroyed and\n      // the extension APIs become unavailable.\n      if (chrome.runtime && chrome.runtime.getManifest()) {\n        return true;\n      }\n    } catch (e) {}\n    return false;\n  }\n\n  function reloadIfRuntimeIsUnavailable() {\n    if (!isRuntimeAvailable()) {\n      location.reload();\n    }\n  }\n\n  let chromeFileAccessOverlayPromise;\n  function requestAccessToLocalFile(fileUrl, overlayManager, callback) {\n    let onCloseOverlay = null;\n    if (top !== window) {\n      // When the extension reloads after receiving new permissions, the pages\n      // have to be reloaded to restore the extension runtime. Auto-reload\n      // frames, because users should not have to reload the whole page just to\n      // update the viewer.\n      // Top-level frames are closed by Chrome upon reload, so there is no need\n      // for detecting unload of the top-level frame. Should this ever change\n      // (crbug.com/511670), then the user can just reload the tab.\n      window.addEventListener(\"focus\", reloadIfRuntimeIsUnavailable);\n      onCloseOverlay = function () {\n        window.removeEventListener(\"focus\", reloadIfRuntimeIsUnavailable);\n        reloadIfRuntimeIsUnavailable();\n        overlayManager.close(\"chromeFileAccessOverlay\");\n      };\n    }\n    if (!chromeFileAccessOverlayPromise) {\n      chromeFileAccessOverlayPromise = overlayManager.register(\n        \"chromeFileAccessOverlay\",\n        document.getElementById(\"chromeFileAccessOverlay\"),\n        onCloseOverlay,\n        true\n      );\n    }\n    chromeFileAccessOverlayPromise.then(function () {\n      const iconPath = chrome.runtime.getManifest().icons[48];\n      document.getElementById(\"chrome-pdfjs-logo-bg\").style.backgroundImage =\n        \"url(\" + chrome.runtime.getURL(iconPath) + \")\";\n\n      // Use Chrome's definition of UI language instead of PDF.js's #lang=...,\n      // because the shown string should match the UI at chrome://extensions.\n      // These strings are from chrome/app/resources/generated_resources_*.xtb.\n      const i18nFileAccessLabel = PDFJSDev.json(\n        \"$ROOT/web/chrome-i18n-allow-access-to-file-urls.json\"\n      )[chrome.i18n.getUILanguage && chrome.i18n.getUILanguage()];\n\n      if (i18nFileAccessLabel) {\n        document.getElementById(\n          \"chrome-file-access-label\"\n        ).textContent = i18nFileAccessLabel;\n      }\n\n      const link = document.getElementById(\"chrome-link-to-extensions-page\");\n      link.href = \"chrome://extensions/?id=\" + chrome.runtime.id;\n      link.onclick = function (e) {\n        // Direct navigation to chrome:// URLs is blocked by Chrome, so we\n        // have to ask the background page to open chrome://extensions/?id=...\n        e.preventDefault();\n        // Open in the current tab by default, because toggling the file access\n        // checkbox causes the extension to reload, and Chrome will close all\n        // tabs upon reload.\n        ChromeCom.request(\"openExtensionsPageForFileAccess\", {\n          newTab: e.ctrlKey || e.metaKey || e.button === 1 || window !== top,\n        });\n      };\n\n      // Show which file is being opened to help the user with understanding\n      // why this permission request is shown.\n      document.getElementById(\"chrome-url-of-local-file\").textContent = fileUrl;\n\n      document.getElementById(\"chrome-file-fallback\").onchange = function () {\n        const file = this.files[0];\n        if (file) {\n          const originalFilename = decodeURIComponent(fileUrl.split(\"/\").pop());\n          let originalUrl = fileUrl;\n          if (originalFilename !== file.name) {\n            const msg =\n              \"The selected file does not match the original file.\" +\n              \"\\nOriginal: \" +\n              originalFilename +\n              \"\\nSelected: \" +\n              file.name +\n              \"\\nDo you want to open the selected file?\";\n            // eslint-disable-next-line no-alert\n            if (!confirm(msg)) {\n              this.value = \"\";\n              return;\n            }\n            // There is no way to retrieve the original URL from the File object.\n            // So just generate a fake path.\n            originalUrl = \"file:///fakepath/to/\" + encodeURIComponent(file.name);\n          }\n          callback(URL.createObjectURL(file), file.size, originalUrl);\n          overlayManager.close(\"chromeFileAccessOverlay\");\n        }\n      };\n\n      overlayManager.open(\"chromeFileAccessOverlay\");\n    });\n  }\n\n  if (window === top) {\n    // Chrome closes all extension tabs (crbug.com/511670) when the extension\n    // reloads. To counter this, the tab URL and history state is saved to\n    // localStorage and restored by extension-router.js.\n    // Unfortunately, the window and tab index are not restored. And if it was\n    // the only tab in an incognito window, then the tab is not restored either.\n    addEventListener(\"unload\", function () {\n      // If the runtime is still available, the unload is most likely a normal\n      // tab closure. Otherwise it is most likely an extension reload.\n      if (!isRuntimeAvailable()) {\n        localStorage.setItem(\n          \"unload-\" + Date.now() + \"-\" + document.hidden + \"-\" + location.href,\n          JSON.stringify(history.state)\n        );\n      }\n    });\n  }\n\n  // This port is used for several purposes:\n  // 1. When disconnected, the background page knows that the frame has unload.\n  // 2. When the referrer was saved in history.state.chromecomState, it is sent\n  //    to the background page.\n  // 3. When the background page knows the referrer of the page, the referrer is\n  //    saved in history.state.chromecomState.\n  let port;\n  // Set the referer for the given URL.\n  // 0. Background: If loaded via a http(s) URL: Save referer.\n  // 1. Page -> background: send URL and referer from history.state\n  // 2. Background: Bind referer to URL (via webRequest).\n  // 3. Background -> page: Send latest referer and save to history.\n  // 4. Page: Invoke callback.\n  function setReferer(url, callback) {\n    if (!port) {\n      // The background page will accept the port, and keep adding the Referer\n      // request header to requests to |url| until the port is disconnected.\n      port = chrome.runtime.connect({ name: \"chromecom-referrer\" });\n    }\n    port.onDisconnect.addListener(onDisconnect);\n    port.onMessage.addListener(onMessage);\n    // Initiate the information exchange.\n    port.postMessage({\n      referer: window.history.state && window.history.state.chromecomState,\n      requestUrl: url,\n    });\n\n    function onMessage(referer) {\n      if (referer) {\n        // The background extracts the Referer from the initial HTTP request for\n        // the PDF file. When the viewer is reloaded or when the user navigates\n        // back and forward, the background page will not observe a HTTP request\n        // with Referer. To make sure that the Referer is preserved, store it in\n        // history.state, which is preserved across reloads/navigations.\n        const state = window.history.state || {};\n        state.chromecomState = referer;\n        window.history.replaceState(state, \"\");\n      }\n      onCompleted();\n    }\n    function onDisconnect() {\n      // When the connection fails, ignore the error and call the callback.\n      port = null;\n      callback();\n    }\n    function onCompleted() {\n      port.onDisconnect.removeListener(onDisconnect);\n      port.onMessage.removeListener(onMessage);\n      callback();\n    }\n  }\n\n  // chrome.storage.sync is not supported in every Chromium-derivate.\n  // Note: The background page takes care of migrating values from\n  // chrome.storage.local to chrome.storage.sync when needed.\n  const storageArea = chrome.storage.sync || chrome.storage.local;\n\n  class ChromePreferences extends BasePreferences {\n    async _writeToStorage(prefObj) {\n      return new Promise(resolve => {\n        if (prefObj === this.defaults) {\n          const keysToRemove = Object.keys(this.defaults);\n          // If the storage is reset, remove the keys so that the values from\n          // managed storage are applied again.\n          storageArea.remove(keysToRemove, function () {\n            resolve();\n          });\n        } else {\n          storageArea.set(prefObj, function () {\n            resolve();\n          });\n        }\n      });\n    }\n\n    async _readFromStorage(prefObj) {\n      return new Promise(resolve => {\n        const getPreferences = defaultPrefs => {\n          if (chrome.runtime.lastError) {\n            // Managed storage not supported, e.g. in Opera.\n            defaultPrefs = this.defaults;\n          }\n          storageArea.get(defaultPrefs, function (readPrefs) {\n            resolve(readPrefs);\n          });\n        };\n\n        if (chrome.storage.managed) {\n          // Get preferences as set by the system administrator.\n          // See extensions/chromium/preferences_schema.json for more information.\n          // These preferences can be overridden by the user.\n\n          // Deprecated preferences are removed from web/default_preferences.json,\n          // but kept in extensions/chromium/preferences_schema.json for backwards\n          // compatibility with managed preferences.\n          const defaultManagedPrefs = Object.assign(\n            {\n              enableHandToolOnLoad: false,\n              disableTextLayer: false,\n              enhanceTextSelection: false,\n              showPreviousViewOnLoad: true,\n              disablePageMode: false,\n            },\n            this.defaults\n          );\n\n          chrome.storage.managed.get(defaultManagedPrefs, function (items) {\n            items = items || defaultManagedPrefs;\n            // Migration logic for deprecated preferences: If the new preference\n            // is not defined by an administrator (i.e. the value is the same as\n            // the default value), and a deprecated preference is set with a\n            // non-default value, migrate the deprecated preference value to the\n            // new preference value.\n            // Never remove this, because we have no means of modifying managed\n            // preferences.\n\n            // Migration code for https://github.com/mozilla/pdf.js/pull/7635.\n            if (items.enableHandToolOnLoad && !items.cursorToolOnLoad) {\n              items.cursorToolOnLoad = 1;\n            }\n            delete items.enableHandToolOnLoad;\n\n            // Migration code for https://github.com/mozilla/pdf.js/pull/9479.\n            if (items.textLayerMode !== 1) {\n              if (items.disableTextLayer) {\n                items.textLayerMode = 0;\n              } else if (items.enhanceTextSelection) {\n                items.textLayerMode = 2;\n              }\n            }\n            delete items.disableTextLayer;\n            delete items.enhanceTextSelection;\n\n            // Migration code for https://github.com/mozilla/pdf.js/pull/10502.\n            if (!items.showPreviousViewOnLoad && !items.viewOnLoad) {\n              items.viewOnLoad = 1;\n            }\n            delete items.showPreviousViewOnLoad;\n            delete items.disablePageMode;\n\n            getPreferences(items);\n          });\n        } else {\n          // Managed storage not supported, e.g. in old Chromium versions.\n          getPreferences(this.defaults);\n        }\n      });\n    }\n  }\n\n  class ChromeExternalServices extends DefaultExternalServices {\n    static initPassiveLoading(callbacks) {\n      // defaultUrl is set in viewer.js\n      ChromeCom.resolvePDFFile(\n        AppOptions.get(\"defaultUrl\"),\n        PDFViewerApplication.overlayManager,\n        function (url, length, originalUrl) {\n          callbacks.onOpenWithURL(url, length, originalUrl);\n        }\n      );\n    }\n\n    static createDownloadManager(options) {\n      return new DownloadManager();\n    }\n\n    static createPreferences() {\n      return new ChromePreferences();\n    }\n\n    static createL10n(options) {\n      return new GenericL10n(navigator.language);\n    }\n\n    static createScripting({ sandboxBundleSrc }) {\n      return new GenericScripting(sandboxBundleSrc);\n    }\n  }\n  PDFViewerApplication.externalServices = ChromeExternalServices;\n\n  return { ChromeCom };\n});"]}