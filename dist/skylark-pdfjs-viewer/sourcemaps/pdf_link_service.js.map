{"version":3,"sources":["pdf_link_service.js"],"names":["define","ui_utils","parseQueryString","PDFLinkService","[object Object]","eventBus","externalLinkTarget","externalLinkRel","externalLinkEnabled","ignoreDestinationZoom","this","_ignoreDestinationZoom","baseUrl","pdfDocument","pdfViewer","pdfHistory","_pagesRefCache","Object","create","pagesCount","numPages","page","currentPageNumber","value","rotation","pagesRotation","dest","console","error","goToDestination","rawDest","namedDest","explicitDest","destRef","pageNumber","_cachedPageNumber","getPageIndex","then","pageIndex","cachePageRef","_goToDestinationHelper","catch","Number","isInteger","pushCurrentPosition","push","scrollPageIntoView","destArray","getDestination","Array","isArray","val","pageLabelToPageNumber","pushPage","length","getAnchorUrl","escape","str","JSON","stringify","anchor","hash","includes","params","dispatch","source","query","search","replace","phraseSearch","phrase","zoomArgs","zoom","split","zoomArg","zoomArgNumber","parseFloat","name","allowNegativeOffset","mode","pagemode","nameddest","unescape","parse","toString","ex","destLength","num","gen","allowNull","i","param","isValidExplicitDestination","action","back","forward","nextPage","previousPage","pageNum","pageRef","refStr","isPageVisible","isPageCached","SimpleLinkService"],"mappings":"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","file":"../pdf_link_service.js","sourcesContent":["define([\n  \"./ui_utils\",\n],function(ui_utils){\n  /* Copyright 2015 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { parseQueryString } = ui_utils;\n\n  /**\n   * @typedef {Object} PDFLinkServiceOptions\n   * @property {EventBus} eventBus - The application event bus.\n   * @property {number} [externalLinkTarget] - Specifies the `target` attribute\n   *   for external links. Must use one of the values from {LinkTarget}.\n   *   Defaults to using no target.\n   * @property {string} [externalLinkRel] - Specifies the `rel` attribute for\n   *   external links. Defaults to stripping the referrer.\n   * @property {boolean} [ignoreDestinationZoom] - Ignores the zoom argument,\n   *   thus preserving the current zoom level in the viewer, when navigating\n   *   to internal destinations. The default value is `false`.\n   */\n\n  /**\n   * Performs navigation functions inside PDF, such as opening specified page,\n   * or destination.\n   * @implements {IPDFLinkService}\n   */\n  class PDFLinkService {\n    /**\n     * @param {PDFLinkServiceOptions} options\n     */\n    constructor({\n      eventBus,\n      externalLinkTarget = null,\n      externalLinkRel = null,\n      externalLinkEnabled = true,\n      ignoreDestinationZoom = false,\n    } = {}) {\n      this.eventBus = eventBus;\n      this.externalLinkTarget = externalLinkTarget;\n      this.externalLinkRel = externalLinkRel;\n      this.externalLinkEnabled = externalLinkEnabled;\n      this._ignoreDestinationZoom = ignoreDestinationZoom;\n\n      this.baseUrl = null;\n      this.pdfDocument = null;\n      this.pdfViewer = null;\n      this.pdfHistory = null;\n\n      this._pagesRefCache = null;\n    }\n\n    setDocument(pdfDocument, baseUrl = null) {\n      this.baseUrl = baseUrl;\n      this.pdfDocument = pdfDocument;\n      this._pagesRefCache = Object.create(null);\n    }\n\n    setViewer(pdfViewer) {\n      this.pdfViewer = pdfViewer;\n    }\n\n    setHistory(pdfHistory) {\n      this.pdfHistory = pdfHistory;\n    }\n\n    /**\n     * @type {number}\n     */\n    get pagesCount() {\n      return this.pdfDocument ? this.pdfDocument.numPages : 0;\n    }\n\n    /**\n     * @type {number}\n     */\n    get page() {\n      return this.pdfViewer.currentPageNumber;\n    }\n\n    /**\n     * @param {number} value\n     */\n    set page(value) {\n      this.pdfViewer.currentPageNumber = value;\n    }\n\n    /**\n     * @type {number}\n     */\n    get rotation() {\n      return this.pdfViewer.pagesRotation;\n    }\n\n    /**\n     * @param {number} value\n     */\n    set rotation(value) {\n      this.pdfViewer.pagesRotation = value;\n    }\n\n    /**\n     * @deprecated\n     */\n    navigateTo(dest) {\n      console.error(\n        \"Deprecated method: `navigateTo`, use `goToDestination` instead.\"\n      );\n      this.goToDestination(dest);\n    }\n\n    /**\n     * @private\n     */\n    _goToDestinationHelper(rawDest, namedDest = null, explicitDest) {\n      // Dest array looks like that: <page-ref> </XYZ|/FitXXX> <args..>\n      const destRef = explicitDest[0];\n      let pageNumber;\n\n      if (destRef instanceof Object) {\n        pageNumber = this._cachedPageNumber(destRef);\n\n        if (pageNumber === null) {\n          // Fetch the page reference if it's not yet available. This could\n          // only occur during loading, before all pages have been resolved.\n          this.pdfDocument\n            .getPageIndex(destRef)\n            .then(pageIndex => {\n              this.cachePageRef(pageIndex + 1, destRef);\n              this._goToDestinationHelper(rawDest, namedDest, explicitDest);\n            })\n            .catch(() => {\n              console.error(\n                `PDFLinkService._goToDestinationHelper: \"${destRef}\" is not ` +\n                  `a valid page reference, for dest=\"${rawDest}\".`\n              );\n            });\n          return;\n        }\n      } else if (Number.isInteger(destRef)) {\n        pageNumber = destRef + 1;\n      } else {\n        console.error(\n          `PDFLinkService._goToDestinationHelper: \"${destRef}\" is not ` +\n            `a valid destination reference, for dest=\"${rawDest}\".`\n        );\n        return;\n      }\n      if (!pageNumber || pageNumber < 1 || pageNumber > this.pagesCount) {\n        console.error(\n          `PDFLinkService._goToDestinationHelper: \"${pageNumber}\" is not ` +\n            `a valid page number, for dest=\"${rawDest}\".`\n        );\n        return;\n      }\n\n      if (this.pdfHistory) {\n        // Update the browser history before scrolling the new destination into\n        // view, to be able to accurately capture the current document position.\n        this.pdfHistory.pushCurrentPosition();\n        this.pdfHistory.push({ namedDest, explicitDest, pageNumber });\n      }\n\n      this.pdfViewer.scrollPageIntoView({\n        pageNumber,\n        destArray: explicitDest,\n        ignoreDestinationZoom: this._ignoreDestinationZoom,\n      });\n    }\n\n    /**\n     * This method will, when available, also update the browser history.\n     *\n     * @param {string|Array} dest - The named, or explicit, PDF destination.\n     */\n    async goToDestination(dest) {\n      if (!this.pdfDocument) {\n        return;\n      }\n      let namedDest, explicitDest;\n      if (typeof dest === \"string\") {\n        namedDest = dest;\n        explicitDest = await this.pdfDocument.getDestination(dest);\n      } else {\n        namedDest = null;\n        explicitDest = await dest;\n      }\n      if (!Array.isArray(explicitDest)) {\n        console.error(\n          `PDFLinkService.goToDestination: \"${explicitDest}\" is not ` +\n            `a valid destination array, for dest=\"${dest}\".`\n        );\n        return;\n      }\n      this._goToDestinationHelper(dest, namedDest, explicitDest);\n    }\n\n    /**\n     * This method will, when available, also update the browser history.\n     *\n     * @param {number|string} val - The page number, or page label.\n     */\n    goToPage(val) {\n      if (!this.pdfDocument) {\n        return;\n      }\n      const pageNumber =\n        (typeof val === \"string\" && this.pdfViewer.pageLabelToPageNumber(val)) ||\n        val | 0;\n      if (\n        !(\n          Number.isInteger(pageNumber) &&\n          pageNumber > 0 &&\n          pageNumber <= this.pagesCount\n        )\n      ) {\n        console.error(`PDFLinkService.goToPage: \"${val}\" is not a valid page.`);\n        return;\n      }\n\n      if (this.pdfHistory) {\n        // Update the browser history before scrolling the new page into view,\n        // to be able to accurately capture the current document position.\n        this.pdfHistory.pushCurrentPosition();\n        this.pdfHistory.pushPage(pageNumber);\n      }\n\n      this.pdfViewer.scrollPageIntoView({ pageNumber });\n    }\n\n    /**\n     * @param {string|Array} dest - The PDF destination object.\n     * @returns {string} The hyperlink to the PDF object.\n     */\n    getDestinationHash(dest) {\n      if (typeof dest === \"string\") {\n        if (dest.length > 0) {\n          return this.getAnchorUrl(\"#\" + escape(dest));\n        }\n      } else if (Array.isArray(dest)) {\n        const str = JSON.stringify(dest);\n        if (str.length > 0) {\n          return this.getAnchorUrl(\"#\" + escape(str));\n        }\n      }\n      return this.getAnchorUrl(\"\");\n    }\n\n    /**\n     * Prefix the full url on anchor links to make sure that links are resolved\n     * relative to the current URL instead of the one defined in <base href>.\n     * @param {string} anchor - The anchor hash, including the #.\n     * @returns {string} The hyperlink to the PDF object.\n     */\n    getAnchorUrl(anchor) {\n      return (this.baseUrl || \"\") + anchor;\n    }\n\n    /**\n     * @param {string} hash\n     */\n    setHash(hash) {\n      if (!this.pdfDocument) {\n        return;\n      }\n      let pageNumber, dest;\n      if (hash.includes(\"=\")) {\n        const params = parseQueryString(hash);\n        if (\"search\" in params) {\n          this.eventBus.dispatch(\"findfromurlhash\", {\n            source: this,\n            query: params.search.replace(/\"/g, \"\"),\n            phraseSearch: params.phrase === \"true\",\n          });\n        }\n        // borrowing syntax from \"Parameters for Opening PDF Files\"\n        if (\"page\" in params) {\n          pageNumber = params.page | 0 || 1;\n        }\n        if (\"zoom\" in params) {\n          // Build the destination array.\n          const zoomArgs = params.zoom.split(\",\"); // scale,left,top\n          const zoomArg = zoomArgs[0];\n          const zoomArgNumber = parseFloat(zoomArg);\n\n          if (!zoomArg.includes(\"Fit\")) {\n            // If the zoomArg is a number, it has to get divided by 100. If it's\n            // a string, it should stay as it is.\n            dest = [\n              null,\n              { name: \"XYZ\" },\n              zoomArgs.length > 1 ? zoomArgs[1] | 0 : null,\n              zoomArgs.length > 2 ? zoomArgs[2] | 0 : null,\n              zoomArgNumber ? zoomArgNumber / 100 : zoomArg,\n            ];\n          } else {\n            if (zoomArg === \"Fit\" || zoomArg === \"FitB\") {\n              dest = [null, { name: zoomArg }];\n            } else if (\n              zoomArg === \"FitH\" ||\n              zoomArg === \"FitBH\" ||\n              zoomArg === \"FitV\" ||\n              zoomArg === \"FitBV\"\n            ) {\n              dest = [\n                null,\n                { name: zoomArg },\n                zoomArgs.length > 1 ? zoomArgs[1] | 0 : null,\n              ];\n            } else if (zoomArg === \"FitR\") {\n              if (zoomArgs.length !== 5) {\n                console.error(\n                  'PDFLinkService.setHash: Not enough parameters for \"FitR\".'\n                );\n              } else {\n                dest = [\n                  null,\n                  { name: zoomArg },\n                  zoomArgs[1] | 0,\n                  zoomArgs[2] | 0,\n                  zoomArgs[3] | 0,\n                  zoomArgs[4] | 0,\n                ];\n              }\n            } else {\n              console.error(\n                `PDFLinkService.setHash: \"${zoomArg}\" is not ` +\n                  \"a valid zoom value.\"\n              );\n            }\n          }\n        }\n        if (dest) {\n          this.pdfViewer.scrollPageIntoView({\n            pageNumber: pageNumber || this.page,\n            destArray: dest,\n            allowNegativeOffset: true,\n          });\n        } else if (pageNumber) {\n          this.page = pageNumber; // simple page\n        }\n        if (\"pagemode\" in params) {\n          this.eventBus.dispatch(\"pagemode\", {\n            source: this,\n            mode: params.pagemode,\n          });\n        }\n        // Ensure that this parameter is *always* handled last, in order to\n        // guarantee that it won't be overridden (e.g. by the \"page\" parameter).\n        if (\"nameddest\" in params) {\n          this.goToDestination(params.nameddest);\n        }\n      } else {\n        // Named (or explicit) destination.\n        dest = unescape(hash);\n        try {\n          dest = JSON.parse(dest);\n\n          if (!Array.isArray(dest)) {\n            // Avoid incorrectly rejecting a valid named destination, such as\n            // e.g. \"4.3\" or \"true\", because `JSON.parse` converted its type.\n            dest = dest.toString();\n          }\n        } catch (ex) {}\n\n        if (typeof dest === \"string\" || isValidExplicitDestination(dest)) {\n          this.goToDestination(dest);\n          return;\n        }\n        console.error(\n          `PDFLinkService.setHash: \"${unescape(hash)}\" is not ` +\n            \"a valid destination.\"\n        );\n      }\n    }\n\n    /**\n     * @param {string} action\n     */\n    executeNamedAction(action) {\n      // See PDF reference, table 8.45 - Named action\n      switch (action) {\n        case \"GoBack\":\n          if (this.pdfHistory) {\n            this.pdfHistory.back();\n          }\n          break;\n\n        case \"GoForward\":\n          if (this.pdfHistory) {\n            this.pdfHistory.forward();\n          }\n          break;\n\n        case \"NextPage\":\n          this.pdfViewer.nextPage();\n          break;\n\n        case \"PrevPage\":\n          this.pdfViewer.previousPage();\n          break;\n\n        case \"LastPage\":\n          this.page = this.pagesCount;\n          break;\n\n        case \"FirstPage\":\n          this.page = 1;\n          break;\n\n        default:\n          break; // No action according to spec\n      }\n\n      this.eventBus.dispatch(\"namedaction\", {\n        source: this,\n        action,\n      });\n    }\n\n    /**\n     * @param {number} pageNum - page number.\n     * @param {Object} pageRef - reference to the page.\n     */\n    cachePageRef(pageNum, pageRef) {\n      if (!pageRef) {\n        return;\n      }\n      const refStr =\n        pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`;\n      this._pagesRefCache[refStr] = pageNum;\n    }\n\n    /**\n     * @private\n     */\n    _cachedPageNumber(pageRef) {\n      const refStr =\n        pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`;\n      return (this._pagesRefCache && this._pagesRefCache[refStr]) || null;\n    }\n\n    /**\n     * @param {number} pageNumber\n     */\n    isPageVisible(pageNumber) {\n      return this.pdfViewer.isPageVisible(pageNumber);\n    }\n\n    /**\n     * @param {number} pageNumber\n     */\n    isPageCached(pageNumber) {\n      return this.pdfViewer.isPageCached(pageNumber);\n    }\n  }\n\n  function isValidExplicitDestination(dest) {\n    if (!Array.isArray(dest)) {\n      return false;\n    }\n    const destLength = dest.length;\n    if (destLength < 2) {\n      return false;\n    }\n    const page = dest[0];\n    if (\n      !(\n        typeof page === \"object\" &&\n        Number.isInteger(page.num) &&\n        Number.isInteger(page.gen)\n      ) &&\n      !(Number.isInteger(page) && page >= 0)\n    ) {\n      return false;\n    }\n    const zoom = dest[1];\n    if (!(typeof zoom === \"object\" && typeof zoom.name === \"string\")) {\n      return false;\n    }\n    let allowNull = true;\n    switch (zoom.name) {\n      case \"XYZ\":\n        if (destLength !== 5) {\n          return false;\n        }\n        break;\n      case \"Fit\":\n      case \"FitB\":\n        return destLength === 2;\n      case \"FitH\":\n      case \"FitBH\":\n      case \"FitV\":\n      case \"FitBV\":\n        if (destLength !== 3) {\n          return false;\n        }\n        break;\n      case \"FitR\":\n        if (destLength !== 6) {\n          return false;\n        }\n        allowNull = false;\n        break;\n      default:\n        return false;\n    }\n    for (let i = 2; i < destLength; i++) {\n      const param = dest[i];\n      if (!(typeof param === \"number\" || (allowNull && param === null))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @implements {IPDFLinkService}\n   */\n  class SimpleLinkService {\n    constructor() {\n      this.externalLinkTarget = null;\n      this.externalLinkRel = null;\n      this.externalLinkEnabled = true;\n      this._ignoreDestinationZoom = false;\n    }\n\n    /**\n     * @type {number}\n     */\n    get pagesCount() {\n      return 0;\n    }\n\n    /**\n     * @type {number}\n     */\n    get page() {\n      return 0;\n    }\n\n    /**\n     * @param {number} value\n     */\n    set page(value) {}\n\n    /**\n     * @type {number}\n     */\n    get rotation() {\n      return 0;\n    }\n\n    /**\n     * @param {number} value\n     */\n    set rotation(value) {}\n\n    /**\n     * @param {string|Array} dest - The named, or explicit, PDF destination.\n     */\n    async goToDestination(dest) {}\n\n    /**\n     * @param {number|string} val - The page number, or page label.\n     */\n    goToPage(val) {}\n\n    /**\n     * @param dest - The PDF destination object.\n     * @returns {string} The hyperlink to the PDF object.\n     */\n    getDestinationHash(dest) {\n      return \"#\";\n    }\n\n    /**\n     * @param hash - The PDF parameters/hash.\n     * @returns {string} The hyperlink to the PDF object.\n     */\n    getAnchorUrl(hash) {\n      return \"#\";\n    }\n\n    /**\n     * @param {string} hash\n     */\n    setHash(hash) {}\n\n    /**\n     * @param {string} action\n     */\n    executeNamedAction(action) {}\n\n    /**\n     * @param {number} pageNum - page number.\n     * @param {Object} pageRef - reference to the page.\n     */\n    cachePageRef(pageNum, pageRef) {}\n\n    /**\n     * @param {number} pageNumber\n     */\n    isPageVisible(pageNumber) {\n      return true;\n    }\n\n    /**\n     * @param {number} pageNumber\n     */\n    isPageCached(pageNumber) {\n      return true;\n    }\n  }\n\n  return { PDFLinkService, SimpleLinkService };\n});"]}