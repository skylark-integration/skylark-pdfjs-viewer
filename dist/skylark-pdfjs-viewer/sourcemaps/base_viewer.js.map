{"version":3,"sources":["base_viewer.js"],"names":["define","pdfjsLib","PDFJSDev","ui_utils","pdf_rendering_queue","annotation_layer_builder","pdf_page_view","pdf_link_service","text_layer_builder","createPromiseCapability","version","CSS_UNITS","DEFAULT_SCALE","DEFAULT_SCALE_VALUE","getVisibleElements","isPortraitOrientation","isValidRotation","isValidScrollMode","isValidSpreadMode","MAX_AUTO_SCALE","moveToEndOfArray","NullL10n","PresentationModeState","RendererType","SCROLLBAR_PADDING","scrollIntoView","ScrollMode","SpreadMode","TextLayerMode","UNKNOWN_SCALE","VERTICAL_PADDING","watchScroll","PDFRenderingQueue","RenderingStates","AnnotationLayerBuilder","PDFPageView","SimpleLinkService","TextLayerBuilder","DEFAULT_CACHE_SIZE","BaseViewer","[object Object]","options","this","constructor","Error","viewerVersion","eval","_name","name","container","viewer","firstElementChild","test","tagName","toUpperCase","getComputedStyle","position","eventBus","linkService","downloadManager","findController","removePageBorders","textLayerMode","Number","isInteger","ENABLE","imageResourcesPath","renderInteractiveForms","enablePrintAutoRotate","renderer","CANVAS","enableWebGL","useOnlyCssZoom","maxCanvasPixels","l10n","enableScripting","_mouseState","mouseState","defaultRenderingQueue","renderingQueue","setViewer","scroll","_scrollUpdate","bind","presentationModeState","UNKNOWN","_onBeforeDraw","_onAfterDraw","_resetView","classList","add","Promise","resolve","then","dispatch","source","pagesCount","_pages","length","index","pageViewsReady","_pagesCapability","settled","every","pageView","pdfPage","currentPageNumber","_currentPageNumber","val","pdfDocument","_setCurrentPageNumber","console","error","resetCurrentPageView","_resetCurrentPageView","previous","pageNumber","pageLabel","_pageLabels","currentPageLabel","page","i","indexOf","currentScale","_currentScale","isNaN","_setScale","currentScaleValue","_currentScaleValue","pagesRotation","_pagesRotation","rotation","ii","update","scale","firstPagePromise","_firstPageCapability","promise","onePageRendered","_onePageRenderedCapability","pagesPromise","_viewerElement","offsetParent","_getVisiblePages","views","_cancelRendering","setDocument","numPages","getPage","optionalContentConfigPromise","getOptionalContentConfig","evt","_buffer","push","_on","cssTransform","_off","firstPdfPage","_optionalContentConfigPromise","viewport","getViewport","textLayerFactory","DISABLE","pageNum","id","defaultViewport","clone","annotationLayerFactory","firstPageView","setPdfPage","cachePageRef","ref","_spreadMode","NONE","_updateSpreadMode","_onePageRenderedOrForceFetch","loadingParams","disableAutoFetch","getPagesLeft","reason","catch","labels","Array","isArray","label","setPageLabel","size","data","view","splice","shift","destroy","resize","newSize","pagesToKeep","pageIdsToKeep","Set","iMax","has","includes","_location","_pagesRequests","WeakMap","_scrollMode","VERTICAL","_resetScriptingEvents","textContent","_updateScrollMode","pageDiv","pageSpot","newScale","newValue","noScroll","preset","toString","oldScale","Math","abs","isSameScale","presetValue","dest","isInPresentationMode","isChangingPresentationMode","left","top","scrollPageIntoView","destArray","allowNegativeOffset","undefined","_pageWidthScaleFactor","spreadMode","scrollMode","HORIZONTAL","value","parseFloat","_setScaleUpdatePages","currentPage","noPadding","hPadding","vPadding","_isScrollModeHorizontal","pageWidthScale","clientWidth","width","pageHeightScale","clientHeight","height","min","horizontalScale","_scrollIntoView","div","ignoreDestinationZoom","widthScale","heightScale","x","y","changeOrientation","pageWidth","pageHeight","boundingRect","convertToViewportPoint","max","firstPage","normalizedScaleValue","round","pdfOpenParams","currentPageView","topLeft","getPagePoint","scrollLeft","scrollTop","intLeft","intTop","visiblePages","visible","numVisiblePages","newCacheSize","renderHighestPriority","_updateHelper","_updateLocation","first","location","element","contains","focus","_isContainerRtl","direction","FULLSCREEN","CHANGING","isHorizontalScrollbarEnabled","scrollWidth","isVerticalScrollbarEnabled","scrollHeight","offsetLeft","clientLeft","offsetTop","clientTop","last","scrollEl","sortByVisibility","horizontal","rtl","some","renderingState","FINISHED","reset","cancelRendering","get","delete","set","currentlyVisiblePages","scrollAhead","right","down","getHighestPriority","_ensurePdfPageLoaded","renderView","textLayerDiv","pageIndex","enhanceTextSelection","annotationStorage","hasJSActionsPromise","hasJSActions","hasEqualPageSizes","pagesOverview","map","mode","toggle","WRAPPED","pages","appendChild","parity","spread","document","createElement","className","cloneNode","pageLayout","Map","percent","widthPercent","yArray","values","currentIndex","currentId","expectedId","firstId","lastId","advance","_getPageAdvance","_pageOpenPendingSet","pageOpenPendingSet","scriptingEvents","_scriptingEvents","Object","create","dispatchPageClose","dispatchPageOpen","actionsPromise","getJSActions","onPageChanging","onPageRendered","onPagesDestroy"],"mappings":"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","file":"../base_viewer.js","sourcesContent":["define([\n  \"skylark-pdfjs-display\",\n  \"./pdfjs_dev\",\n  \"./ui_utils\",\n  \"./pdf_rendering_queue\",\n  \"./annotation_layer_builder\",\n  \"./pdf_page_view\",\n  \"./pdf_link_service\",\n  \"./text_layer_builder\"\n],function(\n  pdfjsLib,\n  PDFJSDev,\n  ui_utils,\n  pdf_rendering_queue,\n  annotation_layer_builder,\n  pdf_page_view,\n  pdf_link_service,\n  text_layer_builder\n\n){\n\n  /* Copyright 2014 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { createPromiseCapability, version } = pdfjsLib;\n  const {\n    CSS_UNITS,\n    DEFAULT_SCALE,\n    DEFAULT_SCALE_VALUE,\n    getVisibleElements,\n    isPortraitOrientation,\n    isValidRotation,\n    isValidScrollMode,\n    isValidSpreadMode,\n    MAX_AUTO_SCALE,\n    moveToEndOfArray,\n    NullL10n,\n    PresentationModeState,\n    RendererType,\n    SCROLLBAR_PADDING,\n    scrollIntoView,\n    ScrollMode,\n    SpreadMode,\n    TextLayerMode,\n    UNKNOWN_SCALE,\n    VERTICAL_PADDING,\n    watchScroll,\n  } = ui_utils;\n  const { PDFRenderingQueue, RenderingStates } = pdf_rendering_queue;\n  const { AnnotationLayerBuilder } = annotation_layer_builder;\n  const { PDFPageView } = pdf_page_view;\n  const { SimpleLinkService } = pdf_link_service;\n  const { TextLayerBuilder } = text_layer_builder;\n\n  const DEFAULT_CACHE_SIZE = 10;\n\n  /**\n   * @typedef {Object} PDFViewerOptions\n   * @property {HTMLDivElement} container - The container for the viewer element.\n   * @property {HTMLDivElement} [viewer] - The viewer element.\n   * @property {EventBus} eventBus - The application event bus.\n   * @property {IPDFLinkService} linkService - The navigation/linking service.\n   * @property {DownloadManager} [downloadManager] - The download manager\n   *   component.\n   * @property {PDFFindController} [findController] - The find controller\n   *   component.\n   * @property {PDFRenderingQueue} [renderingQueue] - The rendering queue object.\n   * @property {boolean} [removePageBorders] - Removes the border shadow around\n   *   the pages. The default value is `false`.\n   * @property {number} [textLayerMode] - Controls if the text layer used for\n   *   selection and searching is created, and if the improved text selection\n   *   behaviour is enabled. The constants from {TextLayerMode} should be used.\n   *   The default value is `TextLayerMode.ENABLE`.\n   * @property {string} [imageResourcesPath] - Path for image resources, mainly\n   *   mainly for annotation icons. Include trailing slash.\n   * @property {boolean} [renderInteractiveForms] - Enables rendering of\n   *   interactive form elements. The default value is `true`.\n   * @property {boolean} [enablePrintAutoRotate] - Enables automatic rotation of\n   *   landscape pages upon printing. The default is `false`.\n   * @property {string} renderer - 'canvas' or 'svg'. The default is 'canvas'.\n   * @property {boolean} [enableWebGL] - Enables WebGL accelerated rendering for\n   *   some operations. The default value is `false`.\n   * @property {boolean} [useOnlyCssZoom] - Enables CSS only zooming. The default\n   *   value is `false`.\n   * @property {number} [maxCanvasPixels] - The maximum supported canvas size in\n   *   total pixels, i.e. width * height. Use -1 for no limit. The default value\n   *   is 4096 * 4096 (16 mega-pixels).\n   * @property {IL10n} l10n - Localization service.\n   * @property {boolean} [enableScripting] - Enable embedded script execution.\n   *   The default value is `false`.\n   * @property {Object} [mouseState] - The mouse button state. The default value\n   *   is `null`.\n   */\n\n  function PDFPageViewBuffer(size) {\n    const data = [];\n    this.push = function (view) {\n      const i = data.indexOf(view);\n      if (i >= 0) {\n        data.splice(i, 1);\n      }\n      data.push(view);\n      if (data.length > size) {\n        data.shift().destroy();\n      }\n    };\n    /**\n     * After calling resize, the size of the buffer will be newSize. The optional\n     * parameter pagesToKeep is, if present, an array of pages to push to the back\n     * of the buffer, delaying their destruction. The size of pagesToKeep has no\n     * impact on the final size of the buffer; if pagesToKeep has length larger\n     * than newSize, some of those pages will be destroyed anyway.\n     */\n    this.resize = function (newSize, pagesToKeep) {\n      size = newSize;\n      if (pagesToKeep) {\n        const pageIdsToKeep = new Set();\n        for (let i = 0, iMax = pagesToKeep.length; i < iMax; ++i) {\n          pageIdsToKeep.add(pagesToKeep[i].id);\n        }\n        moveToEndOfArray(data, function (page) {\n          return pageIdsToKeep.has(page.id);\n        });\n      }\n      while (data.length > size) {\n        data.shift().destroy();\n      }\n    };\n\n    this.has = function (view) {\n      return data.includes(view);\n    };\n  }\n\n  function isSameScale(oldScale, newScale) {\n    if (newScale === oldScale) {\n      return true;\n    }\n    if (Math.abs(newScale - oldScale) < 1e-15) {\n      // Prevent unnecessary re-rendering of all pages when the scale\n      // changes only because of limited numerical precision.\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Simple viewer control to display PDF content/pages.\n   * @implements {IRenderableView}\n   */\n  class BaseViewer {\n    /**\n     * @param {PDFViewerOptions} options\n     */\n    constructor(options) {\n      if (this.constructor === BaseViewer) {\n        throw new Error(\"Cannot initialize BaseViewer.\");\n      }\n\n      //TODO : checking\n      const viewerVersion =\n        typeof PDFJSDev !== \"undefined\" ? PDFJSDev.eval(\"BUNDLE_VERSION\") : null;\n      if (version !== viewerVersion) {\n        throw new Error(\n          `The API version \"${version}\" does not match the Viewer version \"${viewerVersion}\".`\n        );\n      }\n      this._name = this.constructor.name;\n\n      this.container = options.container;\n      this.viewer = options.viewer || options.container.firstElementChild;\n\n      //TODO : checking\n      if (\n        typeof PDFJSDev === \"undefined\" ||\n        PDFJSDev.test(\"!PRODUCTION || GENERIC\")\n      ) {\n        if (\n          !(\n            ///this.container?.tagName.toUpperCase() === \"DIV\" && // lwf \n            this.container && this.container.tagName.toUpperCase() === \"DIV\" &&\n            ///this.viewer?.tagName.toUpperCase() === \"DIV\" // lwf\n            this.viewer && this.viewer.tagName.toUpperCase() === \"DIV\"\n          )\n        ) {\n          throw new Error(\"Invalid `container` and/or `viewer` option.\");\n        }\n\n        if (getComputedStyle(this.container).position !== \"absolute\") {\n          throw new Error(\"The `container` must be absolutely positioned.\");\n        }\n      }\n      this.eventBus = options.eventBus;\n      this.linkService = options.linkService || new SimpleLinkService();\n      this.downloadManager = options.downloadManager || null;\n      this.findController = options.findController || null;\n      this.removePageBorders = options.removePageBorders || false;\n      this.textLayerMode = Number.isInteger(options.textLayerMode)\n        ? options.textLayerMode\n        : TextLayerMode.ENABLE;\n      this.imageResourcesPath = options.imageResourcesPath || \"\";\n      this.renderInteractiveForms =\n        typeof options.renderInteractiveForms === \"boolean\"\n          ? options.renderInteractiveForms\n          : true;\n      this.enablePrintAutoRotate = options.enablePrintAutoRotate || false;\n      this.renderer = options.renderer || RendererType.CANVAS;\n      this.enableWebGL = options.enableWebGL || false;\n      this.useOnlyCssZoom = options.useOnlyCssZoom || false;\n      this.maxCanvasPixels = options.maxCanvasPixels;\n      this.l10n = options.l10n || NullL10n;\n      this.enableScripting = options.enableScripting || false;\n      this._mouseState = options.mouseState || null;\n\n      this.defaultRenderingQueue = !options.renderingQueue;\n      if (this.defaultRenderingQueue) {\n        // Custom rendering queue is not specified, using default one\n        this.renderingQueue = new PDFRenderingQueue();\n        this.renderingQueue.setViewer(this);\n      } else {\n        this.renderingQueue = options.renderingQueue;\n      }\n\n      this.scroll = watchScroll(this.container, this._scrollUpdate.bind(this));\n      this.presentationModeState = PresentationModeState.UNKNOWN;\n      this._onBeforeDraw = this._onAfterDraw = null;\n      this._resetView();\n\n      if (this.removePageBorders) {\n        this.viewer.classList.add(\"removePageBorders\");\n      }\n      // Defer the dispatching of this event, to give other viewer components\n      // time to initialize *and* register 'baseviewerinit' event listeners.\n      Promise.resolve().then(() => {\n        this.eventBus.dispatch(\"baseviewerinit\", { source: this });\n      });\n    }\n\n    get pagesCount() {\n      return this._pages.length;\n    }\n\n    getPageView(index) {\n      return this._pages[index];\n    }\n\n    /**\n     * @type {boolean} - True if all {PDFPageView} objects are initialized.\n     */\n    get pageViewsReady() {\n      if (!this._pagesCapability.settled) {\n        return false;\n      }\n      // Prevent printing errors when 'disableAutoFetch' is set, by ensuring\n      // that *all* pages have in fact been completely loaded.\n      return this._pages.every(function (pageView) {\n        return pageView && pageView.pdfPage;\n      });\n    }\n\n    /**\n     * @type {number}\n     */\n    get currentPageNumber() {\n      return this._currentPageNumber;\n    }\n\n    /**\n     * @param {number} val - The page number.\n     */\n    set currentPageNumber(val) {\n      if (!Number.isInteger(val)) {\n        throw new Error(\"Invalid page number.\");\n      }\n      if (!this.pdfDocument) {\n        return;\n      }\n      // The intent can be to just reset a scroll position and/or scale.\n      if (!this._setCurrentPageNumber(val, /* resetCurrentPageView = */ true)) {\n        console.error(\n          `${this._name}.currentPageNumber: \"${val}\" is not a valid page.`\n        );\n      }\n    }\n\n    /**\n     * @returns {boolean} Whether the pageNumber is valid (within bounds).\n     * @private\n     */\n    _setCurrentPageNumber(val, resetCurrentPageView = false) {\n      if (this._currentPageNumber === val) {\n        if (resetCurrentPageView) {\n          this._resetCurrentPageView();\n        }\n        return true;\n      }\n\n      if (!(0 < val && val <= this.pagesCount)) {\n        return false;\n      }\n      const previous = this._currentPageNumber;\n      this._currentPageNumber = val;\n\n      this.eventBus.dispatch(\"pagechanging\", {\n        source: this,\n        pageNumber: val,\n        pageLabel: this._pageLabels && this._pageLabels[val - 1],\n        previous,\n      });\n\n      if (resetCurrentPageView) {\n        this._resetCurrentPageView();\n      }\n      return true;\n    }\n\n    /**\n     * @type {string|null} Returns the current page label, or `null` if no page\n     *   labels exist.\n     */\n    get currentPageLabel() {\n      return this._pageLabels && this._pageLabels[this._currentPageNumber - 1];\n    }\n\n    /**\n     * @param {string} val - The page label.\n     */\n    set currentPageLabel(val) {\n      if (!this.pdfDocument) {\n        return;\n      }\n      let page = val | 0; // Fallback page number.\n      if (this._pageLabels) {\n        const i = this._pageLabels.indexOf(val);\n        if (i >= 0) {\n          page = i + 1;\n        }\n      }\n      // The intent can be to just reset a scroll position and/or scale.\n      if (!this._setCurrentPageNumber(page, /* resetCurrentPageView = */ true)) {\n        console.error(\n          `${this._name}.currentPageLabel: \"${val}\" is not a valid page.`\n        );\n      }\n    }\n\n    /**\n     * @type {number}\n     */\n    get currentScale() {\n      return this._currentScale !== UNKNOWN_SCALE\n        ? this._currentScale\n        : DEFAULT_SCALE;\n    }\n\n    /**\n     * @param {number} val - Scale of the pages in percents.\n     */\n    set currentScale(val) {\n      if (isNaN(val)) {\n        throw new Error(\"Invalid numeric scale.\");\n      }\n      if (!this.pdfDocument) {\n        return;\n      }\n      this._setScale(val, false);\n    }\n\n    /**\n     * @type {string}\n     */\n    get currentScaleValue() {\n      return this._currentScaleValue;\n    }\n\n    /**\n     * @param val - The scale of the pages (in percent or predefined value).\n     */\n    set currentScaleValue(val) {\n      if (!this.pdfDocument) {\n        return;\n      }\n      this._setScale(val, false);\n    }\n\n    /**\n     * @type {number}\n     */\n    get pagesRotation() {\n      return this._pagesRotation;\n    }\n\n    /**\n     * @param {number} rotation - The rotation of the pages (0, 90, 180, 270).\n     */\n    set pagesRotation(rotation) {\n      if (!isValidRotation(rotation)) {\n        throw new Error(\"Invalid pages rotation angle.\");\n      }\n      if (!this.pdfDocument) {\n        return;\n      }\n      if (this._pagesRotation === rotation) {\n        return; // The rotation didn't change.\n      }\n      this._pagesRotation = rotation;\n\n      const pageNumber = this._currentPageNumber;\n\n      for (let i = 0, ii = this._pages.length; i < ii; i++) {\n        const pageView = this._pages[i];\n        pageView.update(pageView.scale, rotation);\n      }\n      // Prevent errors in case the rotation changes *before* the scale has been\n      // set to a non-default value.\n      if (this._currentScaleValue) {\n        this._setScale(this._currentScaleValue, true);\n      }\n\n      this.eventBus.dispatch(\"rotationchanging\", {\n        source: this,\n        pagesRotation: rotation,\n        pageNumber,\n      });\n\n      if (this.defaultRenderingQueue) {\n        this.update();\n      }\n    }\n\n    get firstPagePromise() {\n      return this.pdfDocument ? this._firstPageCapability.promise : null;\n    }\n\n    get onePageRendered() {\n      return this.pdfDocument ? this._onePageRenderedCapability.promise : null;\n    }\n\n    get pagesPromise() {\n      return this.pdfDocument ? this._pagesCapability.promise : null;\n    }\n\n    /**\n     * @private\n     */\n    get _viewerElement() {\n      // In most viewers, e.g. `PDFViewer`, this should return `this.viewer`.\n      throw new Error(\"Not implemented: _viewerElement\");\n    }\n\n    /**\n     * @private\n     */\n    _onePageRenderedOrForceFetch() {\n      // Unless the viewer *and* its pages are visible, rendering won't start and\n      // `this._onePageRenderedCapability` thus won't be resolved.\n      // To ensure that automatic printing, on document load, still works even in\n      // those cases we force-allow fetching of all pages when:\n      //  - The viewer is hidden in the DOM, e.g. in a `display: none` <iframe>\n      //    element; fixes bug 1618621.\n      //  - The viewer is visible, but none of the pages are (e.g. if the\n      //    viewer is very small); fixes bug 1618955.\n      if (\n        !this.container.offsetParent ||\n        this._getVisiblePages().views.length === 0\n      ) {\n        return Promise.resolve();\n      }\n      return this._onePageRenderedCapability.promise;\n    }\n\n    /**\n     * @param pdfDocument {PDFDocument}\n     */\n    setDocument(pdfDocument) {\n      if (this.pdfDocument) {\n        this.eventBus.dispatch(\"pagesdestroy\", { source: this });\n\n        this._cancelRendering();\n        this._resetView();\n\n        if (this.findController) {\n          this.findController.setDocument(null);\n        }\n      }\n\n      this.pdfDocument = pdfDocument;\n      if (!pdfDocument) {\n        return;\n      }\n      const pagesCount = pdfDocument.numPages;\n      const firstPagePromise = pdfDocument.getPage(1);\n      // Rendering (potentially) depends on this, hence fetching it immediately.\n      const optionalContentConfigPromise = pdfDocument.getOptionalContentConfig();\n\n      this._pagesCapability.promise.then(() => {\n        this.eventBus.dispatch(\"pagesloaded\", {\n          source: this,\n          pagesCount,\n        });\n      });\n\n      this._onBeforeDraw = evt => {\n        const pageView = this._pages[evt.pageNumber - 1];\n        if (!pageView) {\n          return;\n        }\n        // Add the page to the buffer at the start of drawing. That way it can be\n        // evicted from the buffer and destroyed even if we pause its rendering.\n        this._buffer.push(pageView);\n      };\n      this.eventBus._on(\"pagerender\", this._onBeforeDraw);\n\n      this._onAfterDraw = evt => {\n        if (evt.cssTransform || this._onePageRenderedCapability.settled) {\n          return;\n        }\n        this._onePageRenderedCapability.resolve();\n\n        this.eventBus._off(\"pagerendered\", this._onAfterDraw);\n        this._onAfterDraw = null;\n      };\n      this.eventBus._on(\"pagerendered\", this._onAfterDraw);\n\n      // Fetch a single page so we can get a viewport that will be the default\n      // viewport for all pages\n      firstPagePromise\n        .then(firstPdfPage => {\n          this._firstPageCapability.resolve(firstPdfPage);\n          this._optionalContentConfigPromise = optionalContentConfigPromise;\n\n          const scale = this.currentScale;\n          const viewport = firstPdfPage.getViewport({ scale: scale * CSS_UNITS });\n          const textLayerFactory =\n            this.textLayerMode !== TextLayerMode.DISABLE ? this : null;\n\n          for (let pageNum = 1; pageNum <= pagesCount; ++pageNum) {\n            const pageView = new PDFPageView({\n              container: this._viewerElement,\n              eventBus: this.eventBus,\n              id: pageNum,\n              scale,\n              defaultViewport: viewport.clone(),\n              optionalContentConfigPromise,\n              renderingQueue: this.renderingQueue,\n              textLayerFactory,\n              textLayerMode: this.textLayerMode,\n              annotationLayerFactory: this,\n              imageResourcesPath: this.imageResourcesPath,\n              renderInteractiveForms: this.renderInteractiveForms,\n              renderer: this.renderer,\n              enableWebGL: this.enableWebGL,\n              useOnlyCssZoom: this.useOnlyCssZoom,\n              maxCanvasPixels: this.maxCanvasPixels,\n              l10n: this.l10n,\n              enableScripting: this.enableScripting,\n            });\n            this._pages.push(pageView);\n          }\n          // Set the first `pdfPage` immediately, since it's already loaded,\n          // rather than having to repeat the `PDFDocumentProxy.getPage` call in\n          // the `this._ensurePdfPageLoaded` method before rendering can start.\n          const firstPageView = this._pages[0];\n          if (firstPageView) {\n            firstPageView.setPdfPage(firstPdfPage);\n            this.linkService.cachePageRef(1, firstPdfPage.ref);\n          }\n          if (this._spreadMode !== SpreadMode.NONE) {\n            this._updateSpreadMode();\n          }\n\n          // Fetch all the pages since the viewport is needed before printing\n          // starts to create the correct size canvas. Wait until one page is\n          // rendered so we don't tie up too many resources early on.\n          this._onePageRenderedOrForceFetch().then(() => {\n            if (this.findController) {\n              this.findController.setDocument(pdfDocument); // Enable searching.\n            }\n\n            // In addition to 'disableAutoFetch' being set, also attempt to reduce\n            // resource usage when loading *very* long/large documents.\n            if (pdfDocument.loadingParams.disableAutoFetch || pagesCount > 7500) {\n              // XXX: Printing is semi-broken with auto fetch disabled.\n              this._pagesCapability.resolve();\n              return;\n            }\n            let getPagesLeft = pagesCount - 1; // The first page was already loaded.\n\n            if (getPagesLeft <= 0) {\n              this._pagesCapability.resolve();\n              return;\n            }\n            for (let pageNum = 2; pageNum <= pagesCount; ++pageNum) {\n              pdfDocument.getPage(pageNum).then(\n                pdfPage => {\n                  const pageView = this._pages[pageNum - 1];\n                  if (!pageView.pdfPage) {\n                    pageView.setPdfPage(pdfPage);\n                  }\n                  this.linkService.cachePageRef(pageNum, pdfPage.ref);\n                  if (--getPagesLeft === 0) {\n                    this._pagesCapability.resolve();\n                  }\n                },\n                reason => {\n                  console.error(\n                    `Unable to get page ${pageNum} to initialize viewer`,\n                    reason\n                  );\n                  if (--getPagesLeft === 0) {\n                    this._pagesCapability.resolve();\n                  }\n                }\n              );\n            }\n          });\n\n          this.eventBus.dispatch(\"pagesinit\", { source: this });\n\n          if (this.defaultRenderingQueue) {\n            this.update();\n          }\n        })\n        .catch(reason => {\n          console.error(\"Unable to initialize viewer\", reason);\n        });\n    }\n\n    /**\n     * @param {Array|null} labels\n     */\n    setPageLabels(labels) {\n      if (!this.pdfDocument) {\n        return;\n      }\n      if (!labels) {\n        this._pageLabels = null;\n      } else if (\n        !(Array.isArray(labels) && this.pdfDocument.numPages === labels.length)\n      ) {\n        this._pageLabels = null;\n        console.error(`${this._name}.setPageLabels: Invalid page labels.`);\n      } else {\n        this._pageLabels = labels;\n      }\n      // Update all the `PDFPageView` instances.\n      for (let i = 0, ii = this._pages.length; i < ii; i++) {\n        const pageView = this._pages[i];\n        const label = this._pageLabels && this._pageLabels[i];\n        pageView.setPageLabel(label);\n      }\n    }\n\n    _resetView() {\n      this._pages = [];\n      this._currentPageNumber = 1;\n      this._currentScale = UNKNOWN_SCALE;\n      this._currentScaleValue = null;\n      this._pageLabels = null;\n      this._buffer = new PDFPageViewBuffer(DEFAULT_CACHE_SIZE);\n      this._location = null;\n      this._pagesRotation = 0;\n      this._optionalContentConfigPromise = null;\n      this._pagesRequests = new WeakMap();\n      this._firstPageCapability = createPromiseCapability();\n      this._onePageRenderedCapability = createPromiseCapability();\n      this._pagesCapability = createPromiseCapability();\n      this._scrollMode = ScrollMode.VERTICAL;\n      this._spreadMode = SpreadMode.NONE;\n\n      if (this._onBeforeDraw) {\n        this.eventBus._off(\"pagerender\", this._onBeforeDraw);\n        this._onBeforeDraw = null;\n      }\n      if (this._onAfterDraw) {\n        this.eventBus._off(\"pagerendered\", this._onAfterDraw);\n        this._onAfterDraw = null;\n      }\n      this._resetScriptingEvents();\n\n      // Remove the pages from the DOM...\n      this.viewer.textContent = \"\";\n      // ... and reset the Scroll mode CSS class(es) afterwards.\n      this._updateScrollMode();\n    }\n\n    _scrollUpdate() {\n      if (this.pagesCount === 0) {\n        return;\n      }\n      this.update();\n    }\n\n    _scrollIntoView({ pageDiv, pageSpot = null, pageNumber = null }) {\n      scrollIntoView(pageDiv, pageSpot);\n    }\n\n    _setScaleUpdatePages(newScale, newValue, noScroll = false, preset = false) {\n      this._currentScaleValue = newValue.toString();\n\n      if (isSameScale(this._currentScale, newScale)) {\n        if (preset) {\n          this.eventBus.dispatch(\"scalechanging\", {\n            source: this,\n            scale: newScale,\n            presetValue: newValue,\n          });\n        }\n        return;\n      }\n\n      for (let i = 0, ii = this._pages.length; i < ii; i++) {\n        this._pages[i].update(newScale);\n      }\n      this._currentScale = newScale;\n\n      if (!noScroll) {\n        let page = this._currentPageNumber,\n          dest;\n        if (\n          this._location &&\n          !(this.isInPresentationMode || this.isChangingPresentationMode)\n        ) {\n          page = this._location.pageNumber;\n          dest = [\n            null,\n            { name: \"XYZ\" },\n            this._location.left,\n            this._location.top,\n            null,\n          ];\n        }\n        this.scrollPageIntoView({\n          pageNumber: page,\n          destArray: dest,\n          allowNegativeOffset: true,\n        });\n      }\n\n      this.eventBus.dispatch(\"scalechanging\", {\n        source: this,\n        scale: newScale,\n        presetValue: preset ? newValue : undefined,\n      });\n\n      if (this.defaultRenderingQueue) {\n        this.update();\n      }\n    }\n\n    /**\n     * @private\n     */\n    get _pageWidthScaleFactor() {\n      if (\n        this.spreadMode !== SpreadMode.NONE &&\n        this.scrollMode !== ScrollMode.HORIZONTAL &&\n        !this.isInPresentationMode\n      ) {\n        return 2;\n      }\n      return 1;\n    }\n\n    _setScale(value, noScroll = false) {\n      let scale = parseFloat(value);\n\n      if (scale > 0) {\n        this._setScaleUpdatePages(scale, value, noScroll, /* preset = */ false);\n      } else {\n        const currentPage = this._pages[this._currentPageNumber - 1];\n        if (!currentPage) {\n          return;\n        }\n        const noPadding = this.isInPresentationMode || this.removePageBorders;\n        let hPadding = noPadding ? 0 : SCROLLBAR_PADDING;\n        let vPadding = noPadding ? 0 : VERTICAL_PADDING;\n\n        if (!noPadding && this._isScrollModeHorizontal) {\n          [hPadding, vPadding] = [vPadding, hPadding]; // Swap the padding values.\n        }\n        const pageWidthScale =\n          (((this.container.clientWidth - hPadding) / currentPage.width) *\n            currentPage.scale) /\n          this._pageWidthScaleFactor;\n        const pageHeightScale =\n          ((this.container.clientHeight - vPadding) / currentPage.height) *\n          currentPage.scale;\n        switch (value) {\n          case \"page-actual\":\n            scale = 1;\n            break;\n          case \"page-width\":\n            scale = pageWidthScale;\n            break;\n          case \"page-height\":\n            scale = pageHeightScale;\n            break;\n          case \"page-fit\":\n            scale = Math.min(pageWidthScale, pageHeightScale);\n            break;\n          case \"auto\":\n            // For pages in landscape mode, fit the page height to the viewer\n            // *unless* the page would thus become too wide to fit horizontally.\n            const horizontalScale = isPortraitOrientation(currentPage)\n              ? pageWidthScale\n              : Math.min(pageHeightScale, pageWidthScale);\n            scale = Math.min(MAX_AUTO_SCALE, horizontalScale);\n            break;\n          default:\n            console.error(\n              `${this._name}._setScale: \"${value}\" is an unknown zoom value.`\n            );\n            return;\n        }\n        this._setScaleUpdatePages(scale, value, noScroll, /* preset = */ true);\n      }\n    }\n\n    /**\n     * Refreshes page view: scrolls to the current page and updates the scale.\n     * @private\n     */\n    _resetCurrentPageView() {\n      if (this.isInPresentationMode) {\n        // Fixes the case when PDF has different page sizes.\n        this._setScale(this._currentScaleValue, true);\n      }\n\n      const pageView = this._pages[this._currentPageNumber - 1];\n      this._scrollIntoView({ pageDiv: pageView.div });\n    }\n\n    /**\n     * @param {string} label - The page label.\n     * @returns {number|null} The page number corresponding to the page label,\n     *   or `null` when no page labels exist and/or the input is invalid.\n     */\n    pageLabelToPageNumber(label) {\n      if (!this._pageLabels) {\n        return null;\n      }\n      const i = this._pageLabels.indexOf(label);\n      if (i < 0) {\n        return null;\n      }\n      return i + 1;\n    }\n\n    /**\n     * @typedef ScrollPageIntoViewParameters\n     * @property {number} pageNumber - The page number.\n     * @property {Array} [destArray] - The original PDF destination array, in the\n     *   format: <page-ref> </XYZ|/FitXXX> <args..>\n     * @property {boolean} [allowNegativeOffset] - Allow negative page offsets.\n     *   The default value is `false`.\n     * @property {boolean} [ignoreDestinationZoom] - Ignore the zoom argument in\n     *   the destination array. The default value is `false`.\n     */\n\n    /**\n     * Scrolls page into view.\n     * @param {ScrollPageIntoViewParameters} params\n     */\n    scrollPageIntoView({\n      pageNumber,\n      destArray = null,\n      allowNegativeOffset = false,\n      ignoreDestinationZoom = false,\n    }) {\n      if (!this.pdfDocument) {\n        return;\n      }\n      const pageView =\n        Number.isInteger(pageNumber) && this._pages[pageNumber - 1];\n      if (!pageView) {\n        console.error(\n          `${this._name}.scrollPageIntoView: ` +\n            `\"${pageNumber}\" is not a valid pageNumber parameter.`\n        );\n        return;\n      }\n\n      if (this.isInPresentationMode || !destArray) {\n        this._setCurrentPageNumber(pageNumber, /* resetCurrentPageView = */ true);\n        return;\n      }\n      let x = 0,\n        y = 0;\n      let width = 0,\n        height = 0,\n        widthScale,\n        heightScale;\n      const changeOrientation = pageView.rotation % 180 !== 0;\n      const pageWidth =\n        (changeOrientation ? pageView.height : pageView.width) /\n        pageView.scale /\n        CSS_UNITS;\n      const pageHeight =\n        (changeOrientation ? pageView.width : pageView.height) /\n        pageView.scale /\n        CSS_UNITS;\n      let scale = 0;\n      switch (destArray[1].name) {\n        case \"XYZ\":\n          x = destArray[2];\n          y = destArray[3];\n          scale = destArray[4];\n          // If x and/or y coordinates are not supplied, default to\n          // _top_ left of the page (not the obvious bottom left,\n          // since aligning the bottom of the intended page with the\n          // top of the window is rarely helpful).\n          x = x !== null ? x : 0;\n          y = y !== null ? y : pageHeight;\n          break;\n        case \"Fit\":\n        case \"FitB\":\n          scale = \"page-fit\";\n          break;\n        case \"FitH\":\n        case \"FitBH\":\n          y = destArray[2];\n          scale = \"page-width\";\n          // According to the PDF spec, section 12.3.2.2, a `null` value in the\n          // parameter should maintain the position relative to the new page.\n          if (y === null && this._location) {\n            x = this._location.left;\n            y = this._location.top;\n          } else if (typeof y !== \"number\") {\n            // The \"top\" value isn't optional, according to the spec, however some\n            // bad PDF generators will pretend that it is (fixes bug 1663390).\n            y = pageHeight;\n          }\n          break;\n        case \"FitV\":\n        case \"FitBV\":\n          x = destArray[2];\n          width = pageWidth;\n          height = pageHeight;\n          scale = \"page-height\";\n          break;\n        case \"FitR\":\n          x = destArray[2];\n          y = destArray[3];\n          width = destArray[4] - x;\n          height = destArray[5] - y;\n          const hPadding = this.removePageBorders ? 0 : SCROLLBAR_PADDING;\n          const vPadding = this.removePageBorders ? 0 : VERTICAL_PADDING;\n\n          widthScale =\n            (this.container.clientWidth - hPadding) / width / CSS_UNITS;\n          heightScale =\n            (this.container.clientHeight - vPadding) / height / CSS_UNITS;\n          scale = Math.min(Math.abs(widthScale), Math.abs(heightScale));\n          break;\n        default:\n          console.error(\n            `${this._name}.scrollPageIntoView: ` +\n              `\"${destArray[1].name}\" is not a valid destination type.`\n          );\n          return;\n      }\n\n      if (!ignoreDestinationZoom) {\n        if (scale && scale !== this._currentScale) {\n          this.currentScaleValue = scale;\n        } else if (this._currentScale === UNKNOWN_SCALE) {\n          this.currentScaleValue = DEFAULT_SCALE_VALUE;\n        }\n      }\n\n      if (scale === \"page-fit\" && !destArray[4]) {\n        this._scrollIntoView({\n          pageDiv: pageView.div,\n          pageNumber,\n        });\n        return;\n      }\n\n      const boundingRect = [\n        pageView.viewport.convertToViewportPoint(x, y),\n        pageView.viewport.convertToViewportPoint(x + width, y + height),\n      ];\n      let left = Math.min(boundingRect[0][0], boundingRect[1][0]);\n      let top = Math.min(boundingRect[0][1], boundingRect[1][1]);\n\n      if (!allowNegativeOffset) {\n        // Some bad PDF generators will create destinations with e.g. top values\n        // that exceeds the page height. Ensure that offsets are not negative,\n        // to prevent a previous page from becoming visible (fixes bug 874482).\n        left = Math.max(left, 0);\n        top = Math.max(top, 0);\n      }\n      this._scrollIntoView({\n        pageDiv: pageView.div,\n        pageSpot: { left, top },\n        pageNumber,\n      });\n    }\n\n    _updateLocation(firstPage) {\n      const currentScale = this._currentScale;\n      const currentScaleValue = this._currentScaleValue;\n      const normalizedScaleValue =\n        parseFloat(currentScaleValue) === currentScale\n          ? Math.round(currentScale * 10000) / 100\n          : currentScaleValue;\n\n      const pageNumber = firstPage.id;\n      let pdfOpenParams = \"#page=\" + pageNumber;\n      pdfOpenParams += \"&zoom=\" + normalizedScaleValue;\n      const currentPageView = this._pages[pageNumber - 1];\n      const container = this.container;\n      const topLeft = currentPageView.getPagePoint(\n        container.scrollLeft - firstPage.x,\n        container.scrollTop - firstPage.y\n      );\n      const intLeft = Math.round(topLeft[0]);\n      const intTop = Math.round(topLeft[1]);\n      pdfOpenParams += \",\" + intLeft + \",\" + intTop;\n\n      this._location = {\n        pageNumber,\n        scale: normalizedScaleValue,\n        top: intTop,\n        left: intLeft,\n        rotation: this._pagesRotation,\n        pdfOpenParams,\n      };\n    }\n\n    _updateHelper(visiblePages) {\n      throw new Error(\"Not implemented: _updateHelper\");\n    }\n\n    update() {\n      const visible = this._getVisiblePages();\n      const visiblePages = visible.views,\n        numVisiblePages = visiblePages.length;\n\n      if (numVisiblePages === 0) {\n        return;\n      }\n      const newCacheSize = Math.max(DEFAULT_CACHE_SIZE, 2 * numVisiblePages + 1);\n      this._buffer.resize(newCacheSize, visiblePages);\n\n      this.renderingQueue.renderHighestPriority(visible);\n\n      this._updateHelper(visiblePages); // Run any class-specific update code.\n\n      this._updateLocation(visible.first);\n      this.eventBus.dispatch(\"updateviewarea\", {\n        source: this,\n        location: this._location,\n      });\n    }\n\n    containsElement(element) {\n      return this.container.contains(element);\n    }\n\n    focus() {\n      this.container.focus();\n    }\n\n    get _isScrollModeHorizontal() {\n      // Used to ensure that pre-rendering of the next/previous page works\n      // correctly, since Scroll/Spread modes are ignored in Presentation Mode.\n      return this.isInPresentationMode\n        ? false\n        : this._scrollMode === ScrollMode.HORIZONTAL;\n    }\n\n    get _isContainerRtl() {\n      return getComputedStyle(this.container).direction === \"rtl\";\n    }\n\n    get isInPresentationMode() {\n      return this.presentationModeState === PresentationModeState.FULLSCREEN;\n    }\n\n    get isChangingPresentationMode() {\n      return this.presentationModeState === PresentationModeState.CHANGING;\n    }\n\n    get isHorizontalScrollbarEnabled() {\n      return this.isInPresentationMode\n        ? false\n        : this.container.scrollWidth > this.container.clientWidth;\n    }\n\n    get isVerticalScrollbarEnabled() {\n      return this.isInPresentationMode\n        ? false\n        : this.container.scrollHeight > this.container.clientHeight;\n    }\n\n    /**\n     * Helper method for `this._getVisiblePages`. Should only ever be used when\n     * the viewer can only display a single page at a time, for example in:\n     *  - `PDFSinglePageViewer`.\n     *  - `PDFViewer` with Presentation Mode active.\n     */\n    _getCurrentVisiblePage() {\n      if (!this.pagesCount) {\n        return { views: [] };\n      }\n      const pageView = this._pages[this._currentPageNumber - 1];\n      // NOTE: Compute the `x` and `y` properties of the current view,\n      // since `this._updateLocation` depends of them being available.\n      const element = pageView.div;\n\n      const view = {\n        id: pageView.id,\n        x: element.offsetLeft + element.clientLeft,\n        y: element.offsetTop + element.clientTop,\n        view: pageView,\n      };\n      return { first: view, last: view, views: [view] };\n    }\n\n    _getVisiblePages() {\n      return getVisibleElements({\n        scrollEl: this.container,\n        views: this._pages,\n        sortByVisibility: true,\n        horizontal: this._isScrollModeHorizontal,\n        rtl: this._isScrollModeHorizontal && this._isContainerRtl,\n      });\n    }\n\n    /**\n     * @param {number} pageNumber\n     */\n    isPageVisible(pageNumber) {\n      if (!this.pdfDocument) {\n        return false;\n      }\n      if (\n        !(\n          Number.isInteger(pageNumber) &&\n          pageNumber > 0 &&\n          pageNumber <= this.pagesCount\n        )\n      ) {\n        console.error(\n          `${this._name}.isPageVisible: \"${pageNumber}\" is not a valid page.`\n        );\n        return false;\n      }\n      return this._getVisiblePages().views.some(function (view) {\n        return view.id === pageNumber;\n      });\n    }\n\n    /**\n     * @param {number} pageNumber\n     */\n    isPageCached(pageNumber) {\n      if (!this.pdfDocument || !this._buffer) {\n        return false;\n      }\n      if (\n        !(\n          Number.isInteger(pageNumber) &&\n          pageNumber > 0 &&\n          pageNumber <= this.pagesCount\n        )\n      ) {\n        console.error(\n          `${this._name}.isPageCached: \"${pageNumber}\" is not a valid page.`\n        );\n        return false;\n      }\n      const pageView = this._pages[pageNumber - 1];\n      if (!pageView) {\n        return false;\n      }\n      return this._buffer.has(pageView);\n    }\n\n    cleanup() {\n      for (let i = 0, ii = this._pages.length; i < ii; i++) {\n        if (\n          this._pages[i] &&\n          this._pages[i].renderingState !== RenderingStates.FINISHED\n        ) {\n          this._pages[i].reset();\n        }\n      }\n    }\n\n    /**\n     * @private\n     */\n    _cancelRendering() {\n      for (let i = 0, ii = this._pages.length; i < ii; i++) {\n        if (this._pages[i]) {\n          this._pages[i].cancelRendering();\n        }\n      }\n    }\n\n    /**\n     * @param {PDFPageView} pageView\n     * @returns {Promise} Returns a promise containing a {PDFPageProxy} object.\n     * @private\n     */\n    _ensurePdfPageLoaded(pageView) {\n      if (pageView.pdfPage) {\n        return Promise.resolve(pageView.pdfPage);\n      }\n      if (this._pagesRequests.has(pageView)) {\n        return this._pagesRequests.get(pageView);\n      }\n      const promise = this.pdfDocument\n        .getPage(pageView.id)\n        .then(pdfPage => {\n          if (!pageView.pdfPage) {\n            pageView.setPdfPage(pdfPage);\n          }\n          this._pagesRequests.delete(pageView);\n          return pdfPage;\n        })\n        .catch(reason => {\n          console.error(\"Unable to get page for page view\", reason);\n          // Page error -- there is nothing that can be done.\n          this._pagesRequests.delete(pageView);\n        });\n      this._pagesRequests.set(pageView, promise);\n      return promise;\n    }\n\n    forceRendering(currentlyVisiblePages) {\n      const visiblePages = currentlyVisiblePages || this._getVisiblePages();\n      const scrollAhead = this._isScrollModeHorizontal\n        ? this.scroll.right\n        : this.scroll.down;\n      const pageView = this.renderingQueue.getHighestPriority(\n        visiblePages,\n        this._pages,\n        scrollAhead\n      );\n      if (pageView) {\n        this._ensurePdfPageLoaded(pageView).then(() => {\n          this.renderingQueue.renderView(pageView);\n        });\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * @param {HTMLDivElement} textLayerDiv\n     * @param {number} pageIndex\n     * @param {PageViewport} viewport\n     * @param {boolean} enhanceTextSelection\n     * @param {EventBus} eventBus\n     * @returns {TextLayerBuilder}\n     */\n    createTextLayerBuilder(\n      textLayerDiv,\n      pageIndex,\n      viewport,\n      enhanceTextSelection = false,\n      eventBus\n    ) {\n      return new TextLayerBuilder({\n        textLayerDiv,\n        eventBus,\n        pageIndex,\n        viewport,\n        findController: this.isInPresentationMode ? null : this.findController,\n        enhanceTextSelection: this.isInPresentationMode\n          ? false\n          : enhanceTextSelection,\n      });\n    }\n\n    /**\n     * @param {HTMLDivElement} pageDiv\n     * @param {PDFPage} pdfPage\n     * @param {AnnotationStorage} [annotationStorage] - Storage for annotation\n     *   data in forms.\n     * @param {string} [imageResourcesPath] - Path for image resources, mainly\n     *   for annotation icons. Include trailing slash.\n     * @param {boolean} renderInteractiveForms\n     * @param {IL10n} l10n\n     * @param {boolean} [enableScripting]\n     * @param {Promise<boolean>} [hasJSActionsPromise]\n     * @param {Object} [mouseState]\n     * @returns {AnnotationLayerBuilder}\n     */\n    createAnnotationLayerBuilder(\n      pageDiv,\n      pdfPage,\n      annotationStorage = null,\n      imageResourcesPath = \"\",\n      renderInteractiveForms = false,\n      l10n = NullL10n,\n      enableScripting = false,\n      hasJSActionsPromise = null,\n      mouseState = null\n    ) {\n      return new AnnotationLayerBuilder({\n        pageDiv,\n        pdfPage,\n        annotationStorage:\n          ///annotationStorage || this.pdfDocument?.annotationStorage, // lwf\n          annotationStorage || (this.pdfDocument && this.pdfDocument.annotationStorage),\n        imageResourcesPath,\n        renderInteractiveForms,\n        linkService: this.linkService,\n        downloadManager: this.downloadManager,\n        l10n,\n        enableScripting,\n        hasJSActionsPromise:\n          ///hasJSActionsPromise || this.pdfDocument?.hasJSActions(), // lwf\n          hasJSActionsPromise || (this.pdfDocument && this.pdfDocument.hasJSActions()),\n        mouseState: mouseState || this._mouseState,\n      });\n    }\n\n    /**\n     * @type {boolean} Whether all pages of the PDF document have identical\n     *   widths and heights.\n     */\n    get hasEqualPageSizes() {\n      const firstPageView = this._pages[0];\n      for (let i = 1, ii = this._pages.length; i < ii; ++i) {\n        const pageView = this._pages[i];\n        if (\n          pageView.width !== firstPageView.width ||\n          pageView.height !== firstPageView.height\n        ) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Returns sizes of the pages.\n     * @returns {Array} Array of objects with width/height/rotation fields.\n     */\n    getPagesOverview() {\n      const pagesOverview = this._pages.map(function (pageView) {\n        const viewport = pageView.pdfPage.getViewport({ scale: 1 });\n        return {\n          width: viewport.width,\n          height: viewport.height,\n          rotation: viewport.rotation,\n        };\n      });\n      if (!this.enablePrintAutoRotate) {\n        return pagesOverview;\n      }\n      return pagesOverview.map(function (size) {\n        if (isPortraitOrientation(size)) {\n          return size;\n        }\n        return {\n          width: size.height,\n          height: size.width,\n          rotation: (size.rotation + 90) % 360,\n        };\n      });\n    }\n\n    /**\n     * @type {Promise<OptionalContentConfig | null>}\n     */\n    get optionalContentConfigPromise() {\n      if (!this.pdfDocument) {\n        return Promise.resolve(null);\n      }\n      if (!this._optionalContentConfigPromise) {\n        // Prevent issues if the getter is accessed *before* the `onePageRendered`\n        // promise has resolved; won't (normally) happen in the default viewer.\n        return this.pdfDocument.getOptionalContentConfig();\n      }\n      return this._optionalContentConfigPromise;\n    }\n\n    /**\n     * @param {Promise<OptionalContentConfig>} promise - A promise that is\n     *   resolved with an {@link OptionalContentConfig} instance.\n     */\n    set optionalContentConfigPromise(promise) {\n      if (!(promise instanceof Promise)) {\n        throw new Error(`Invalid optionalContentConfigPromise: ${promise}`);\n      }\n      if (!this.pdfDocument) {\n        return;\n      }\n      if (!this._optionalContentConfigPromise) {\n        // Ignore the setter *before* the `onePageRendered` promise has resolved,\n        // since it'll be overwritten anyway; won't happen in the default viewer.\n        return;\n      }\n      this._optionalContentConfigPromise = promise;\n\n      for (const pageView of this._pages) {\n        pageView.update(pageView.scale, pageView.rotation, promise);\n      }\n      this.update();\n\n      this.eventBus.dispatch(\"optionalcontentconfigchanged\", {\n        source: this,\n        promise,\n      });\n    }\n\n    /**\n     * @type {number} One of the values in {ScrollMode}.\n     */\n    get scrollMode() {\n      return this._scrollMode;\n    }\n\n    /**\n     * @param {number} mode - The direction in which the document pages should be\n     *   laid out within the scrolling container.\n     *   The constants from {ScrollMode} should be used.\n     */\n    set scrollMode(mode) {\n      if (this._scrollMode === mode) {\n        return; // The Scroll mode didn't change.\n      }\n      if (!isValidScrollMode(mode)) {\n        throw new Error(`Invalid scroll mode: ${mode}`);\n      }\n      this._scrollMode = mode;\n      this.eventBus.dispatch(\"scrollmodechanged\", { source: this, mode });\n\n      this._updateScrollMode(/* pageNumber = */ this._currentPageNumber);\n    }\n\n    _updateScrollMode(pageNumber = null) {\n      const scrollMode = this._scrollMode,\n        viewer = this.viewer;\n\n      viewer.classList.toggle(\n        \"scrollHorizontal\",\n        scrollMode === ScrollMode.HORIZONTAL\n      );\n      viewer.classList.toggle(\"scrollWrapped\", scrollMode === ScrollMode.WRAPPED);\n\n      if (!this.pdfDocument || !pageNumber) {\n        return;\n      }\n      // Non-numeric scale values can be sensitive to the scroll orientation.\n      // Call this before re-scrolling to the current page, to ensure that any\n      // changes in scale don't move the current page.\n      if (this._currentScaleValue && isNaN(this._currentScaleValue)) {\n        this._setScale(this._currentScaleValue, true);\n      }\n      this._setCurrentPageNumber(pageNumber, /* resetCurrentPageView = */ true);\n      this.update();\n    }\n\n    /**\n     * @type {number} One of the values in {SpreadMode}.\n     */\n    get spreadMode() {\n      return this._spreadMode;\n    }\n\n    /**\n     * @param {number} mode - Group the pages in spreads, starting with odd- or\n     *   even-number pages (unless `SpreadMode.NONE` is used).\n     *   The constants from {SpreadMode} should be used.\n     */\n    set spreadMode(mode) {\n      if (this._spreadMode === mode) {\n        return; // The Spread mode didn't change.\n      }\n      if (!isValidSpreadMode(mode)) {\n        throw new Error(`Invalid spread mode: ${mode}`);\n      }\n      this._spreadMode = mode;\n      this.eventBus.dispatch(\"spreadmodechanged\", { source: this, mode });\n\n      this._updateSpreadMode(/* pageNumber = */ this._currentPageNumber);\n    }\n\n    _updateSpreadMode(pageNumber = null) {\n      if (!this.pdfDocument) {\n        return;\n      }\n      const viewer = this.viewer,\n        pages = this._pages;\n      // Temporarily remove all the pages from the DOM.\n      viewer.textContent = \"\";\n\n      if (this._spreadMode === SpreadMode.NONE) {\n        for (let i = 0, iMax = pages.length; i < iMax; ++i) {\n          viewer.appendChild(pages[i].div);\n        }\n      } else {\n        const parity = this._spreadMode - 1;\n        let spread = null;\n        for (let i = 0, iMax = pages.length; i < iMax; ++i) {\n          if (spread === null) {\n            spread = document.createElement(\"div\");\n            spread.className = \"spread\";\n            viewer.appendChild(spread);\n          } else if (i % 2 === parity) {\n            spread = spread.cloneNode(false);\n            viewer.appendChild(spread);\n          }\n          spread.appendChild(pages[i].div);\n        }\n      }\n\n      if (!pageNumber) {\n        return;\n      }\n      if (this._currentScaleValue && isNaN(this._currentScaleValue)) {\n        this._setScale(this._currentScaleValue, true);\n      }\n      this._setCurrentPageNumber(pageNumber, /* resetCurrentPageView = */ true);\n      this.update();\n    }\n\n    /**\n     * @private\n     */\n    _getPageAdvance(currentPageNumber, previous = false) {\n      if (this.isInPresentationMode) {\n        return 1;\n      }\n      switch (this._scrollMode) {\n        case ScrollMode.WRAPPED: {\n          const { views } = this._getVisiblePages(),\n            pageLayout = new Map();\n\n          // Determine the current (visible) page layout.\n          for (const { id, y, percent, widthPercent } of views) {\n            if (percent === 0 || widthPercent < 100) {\n              continue;\n            }\n            let yArray = pageLayout.get(y);\n            if (!yArray) {\n              ///pageLayout.set(y, (yArray ||= [])); // lwf\n              pageLayout.set(y, (yArray = []));\n            }\n            yArray.push(id);\n          }\n          // Find the row of the current page.\n          for (const yArray of pageLayout.values()) {\n            const currentIndex = yArray.indexOf(currentPageNumber);\n            if (currentIndex === -1) {\n              continue;\n            }\n            const numPages = yArray.length;\n            if (numPages === 1) {\n              break;\n            }\n            // Handle documents with varying page sizes.\n            if (previous) {\n              for (let i = currentIndex - 1, ii = 0; i >= ii; i--) {\n                const currentId = yArray[i],\n                  expectedId = yArray[i + 1] - 1;\n                if (currentId < expectedId) {\n                  return currentPageNumber - expectedId;\n                }\n              }\n            } else {\n              for (let i = currentIndex + 1, ii = numPages; i < ii; i++) {\n                const currentId = yArray[i],\n                  expectedId = yArray[i - 1] + 1;\n                if (currentId > expectedId) {\n                  return expectedId - currentPageNumber;\n                }\n              }\n            }\n            // The current row is \"complete\", advance to the previous/next one.\n            if (previous) {\n              const firstId = yArray[0];\n              if (firstId < currentPageNumber) {\n                return currentPageNumber - firstId + 1;\n              }\n            } else {\n              const lastId = yArray[numPages - 1];\n              if (lastId > currentPageNumber) {\n                return lastId - currentPageNumber + 1;\n              }\n            }\n            break;\n          }\n          break;\n        }\n        case ScrollMode.HORIZONTAL: {\n          break;\n        }\n        case ScrollMode.VERTICAL: {\n          if (this._spreadMode === SpreadMode.NONE) {\n            break; // Normal vertical scrolling.\n          }\n          const parity = this._spreadMode - 1;\n\n          if (previous && currentPageNumber % 2 !== parity) {\n            break; // Left-hand side page.\n          } else if (!previous && currentPageNumber % 2 === parity) {\n            break; // Right-hand side page.\n          }\n          const { views } = this._getVisiblePages(),\n            expectedId = previous ? currentPageNumber - 1 : currentPageNumber + 1;\n\n          for (const { id, percent, widthPercent } of views) {\n            if (id !== expectedId) {\n              continue;\n            }\n            if (percent > 0 && widthPercent === 100) {\n              return 2;\n            }\n            break;\n          }\n          break;\n        }\n      }\n      return 1;\n    }\n\n    /**\n     * Go to the next page, taking scroll/spread-modes into account.\n     * @returns {boolean} Whether navigation occured.\n     */\n    nextPage() {\n      const currentPageNumber = this._currentPageNumber,\n        pagesCount = this.pagesCount;\n\n      if (currentPageNumber >= pagesCount) {\n        return false;\n      }\n      const advance =\n        this._getPageAdvance(currentPageNumber, /* previous = */ false) || 1;\n\n      this.currentPageNumber = Math.min(currentPageNumber + advance, pagesCount);\n      return true;\n    }\n\n    /**\n     * Go to the previous page, taking scroll/spread-modes into account.\n     * @returns {boolean} Whether navigation occured.\n     */\n    previousPage() {\n      const currentPageNumber = this._currentPageNumber;\n\n      if (currentPageNumber <= 1) {\n        return false;\n      }\n      const advance =\n        this._getPageAdvance(currentPageNumber, /* previous = */ true) || 1;\n\n      this.currentPageNumber = Math.max(currentPageNumber - advance, 1);\n      return true;\n    }\n\n    initializeScriptingEvents() {\n      if (!this.enableScripting || this._pageOpenPendingSet) {\n        return;\n      }\n      const eventBus = this.eventBus,\n        pageOpenPendingSet = (this._pageOpenPendingSet = new Set()),\n        //scriptingEvents = (this._scriptingEvents ||= Object.create(null)); // lwf\n        scriptingEvents = (this._scriptingEvents || (this._scriptingEvents = Object.create(null)));\n\n      const dispatchPageClose = pageNumber => {\n        if (pageOpenPendingSet.has(pageNumber)) {\n          return; // No \"pageopen\" event was dispatched for the previous page.\n        }\n        eventBus.dispatch(\"pageclose\", { source: this, pageNumber });\n      };\n      const dispatchPageOpen = pageNumber => {\n        const pageView = this._pages[pageNumber - 1];\n        //if (pageView?.renderingState === RenderingStates.FINISHED) { // lwf\n        if (pageView && pageView.renderingState === RenderingStates.FINISHED) {\n          pageOpenPendingSet.delete(pageNumber);\n\n          eventBus.dispatch(\"pageopen\", {\n            source: this,\n            pageNumber,\n            ///actionsPromise: pageView.pdfPage?.getJSActions(),// lwf\n            actionsPromise: pageView.pdfPage && pageView.pdfPage.getJSActions(),\n          });\n        } else {\n          pageOpenPendingSet.add(pageNumber);\n        }\n      };\n\n      scriptingEvents.onPageChanging = ({ pageNumber, previous }) => {\n        if (pageNumber === previous) {\n          return; // The active page didn't change.\n        }\n        dispatchPageClose(previous);\n        dispatchPageOpen(pageNumber);\n      };\n      eventBus._on(\"pagechanging\", scriptingEvents.onPageChanging);\n\n      scriptingEvents.onPageRendered = ({ pageNumber }) => {\n        if (!pageOpenPendingSet.has(pageNumber)) {\n          return; // No pending \"pageopen\" event for the newly rendered page.\n        }\n        if (pageNumber !== this._currentPageNumber) {\n          return; // The newly rendered page is no longer the current one.\n        }\n        dispatchPageOpen(pageNumber);\n      };\n      eventBus._on(\"pagerendered\", scriptingEvents.onPageRendered);\n\n      scriptingEvents.onPagesDestroy = () => {\n        dispatchPageClose(this._currentPageNumber);\n      };\n      eventBus._on(\"pagesdestroy\", scriptingEvents.onPagesDestroy);\n\n      // Ensure that a \"pageopen\" event is dispatched for the initial page.\n      dispatchPageOpen(this._currentPageNumber);\n    }\n\n    /**\n     * @private\n     */\n    _resetScriptingEvents() {\n      if (!this.enableScripting || !this._pageOpenPendingSet) {\n        return;\n      }\n      const eventBus = this.eventBus,\n        scriptingEvents = this._scriptingEvents;\n\n      // Remove the event listeners.\n      eventBus._off(\"pagechanging\", scriptingEvents.onPageChanging);\n      scriptingEvents.onPageChanging = null;\n\n      eventBus._off(\"pagerendered\", scriptingEvents.onPageRendered);\n      scriptingEvents.onPageRendered = null;\n\n      eventBus._off(\"pagesdestroy\", scriptingEvents.onPagesDestroy);\n      scriptingEvents.onPagesDestroy = null;\n\n      this._pageOpenPendingSet = null;\n    }\n  }\n\n  return { BaseViewer };\n});"]}