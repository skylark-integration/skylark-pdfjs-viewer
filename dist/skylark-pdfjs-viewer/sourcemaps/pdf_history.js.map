{"version":3,"sources":["pdf_history.js"],"names":["define","PDFJSDev","ui_utils","isValidRotation","parseQueryString","PresentationModeState","waitOnEventOrTimeout","HASH_CHANGE_TIMEOUT","POSITION_UPDATED_THRESHOLD","UPDATE_VIEWAREA_TIMEOUT","getCurrentHash","document","location","hash","isDestHashesEqual","destHash","pushHash","nameddest","isDestArraysEqual","firstDest","secondDest","isEntryEqual","first","second","Array","isArray","Object","keys","length","key","Number","isNaN","i","ii","PDFHistory","[object Object]","linkService","eventBus","this","_initialized","_fingerprint","reset","_boundEvents","_isViewerInPresentationMode","_on","evt","state","NORMAL","_isPagesLoaded","pagesCount","once","fingerprint","resetHistory","updateUrl","console","error","reInitialized","_updateUrl","_bindEvents","window","history","_popStateInProgress","_blockHashChange","_currentHash","_numPositionUpdates","_uid","_maxUid","_destination","_position","_isValidState","page","rotation","_parseCurrentHash","_pushOrReplaceState","destination","_updateInternalState","uid","undefined","_initialRotation","dest","_initialBookmark","JSON","stringify","_pageHide","_unbindEvents","_updateViewareaTimeout","clearTimeout","namedDest","explicitDest","pageNumber","isInteger","forceReplace","Promise","resolve","then","_tryPushCurrentPosition","back","forward","popStateInProgress","initialBookmark","initialRotation","shouldReplace","newState","newUrl","test","chromecomState","baseUrl","href","split","startsWith","replaceState","pushState","top","chrome","runtime","sendMessage","temporary","position","assign","create","checkReload","perfEntry","performance","getEntriesByType","type","removeTemporary","Math","max","checkNameddest","unescape","substring","params","pdfOpenParams","setTimeout","newHash","hashChanged","target","name","delay","goToDestination","setHash","updateViewarea","_updateViewarea","bind","popState","_popState","pageHide","addEventListener","_off","removeEventListener"],"mappings":"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","file":"../pdf_history.js","sourcesContent":["define([\n  \"./pdfjs_dev\",\n  \"./ui_utils\",\n],function(\n  PDFJSDev,\n  ui_utils\n){\n  /* Copyright 2017 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const {\n    isValidRotation,\n    parseQueryString,\n    PresentationModeState,\n    waitOnEventOrTimeout,\n  } = ui_utils;\n\n  // Heuristic value used when force-resetting `this._blockHashChange`.\n  const HASH_CHANGE_TIMEOUT = 1000; // milliseconds\n  // Heuristic value used when adding the current position to the browser history.\n  const POSITION_UPDATED_THRESHOLD = 50;\n  // Heuristic value used when adding a temporary position to the browser history.\n  const UPDATE_VIEWAREA_TIMEOUT = 1000; // milliseconds\n\n  /**\n   * @typedef {Object} PDFHistoryOptions\n   * @property {IPDFLinkService} linkService - The navigation/linking service.\n   * @property {EventBus} eventBus - The application event bus.\n   */\n\n  /**\n   * @typedef {Object} InitializeParameters\n   * @property {string} fingerprint - The PDF document's unique fingerprint.\n   * @property {boolean} [resetHistory] - Reset the browsing history.\n   * @property {boolean} [updateUrl] - Attempt to update the document URL, with\n   *   the current hash, when pushing/replacing browser history entries.\n   */\n\n  /**\n   * @typedef {Object} PushParameters\n   * @property {string} [namedDest] - The named destination. If absent, a\n   *   stringified version of `explicitDest` is used.\n   * @property {Array} explicitDest - The explicit destination array.\n   * @property {number} pageNumber - The page to which the destination points.\n   */\n\n  function getCurrentHash() {\n    return document.location.hash;\n  }\n\n  class PDFHistory {\n    /**\n     * @param {PDFHistoryOptions} options\n     */\n    constructor({ linkService, eventBus }) {\n      this.linkService = linkService;\n      this.eventBus = eventBus;\n\n      this._initialized = false;\n      this._fingerprint = \"\";\n      this.reset();\n\n      this._boundEvents = null;\n      this._isViewerInPresentationMode = false;\n      // Ensure that we don't miss either a 'presentationmodechanged' or a\n      // 'pagesinit' event, by registering the listeners immediately.\n      this.eventBus._on(\"presentationmodechanged\", evt => {\n        this._isViewerInPresentationMode =\n          evt.state !== PresentationModeState.NORMAL;\n      });\n      this.eventBus._on(\"pagesinit\", () => {\n        this._isPagesLoaded = false;\n\n        this.eventBus._on(\n          \"pagesloaded\",\n          evt => {\n            this._isPagesLoaded = !!evt.pagesCount;\n          },\n          { once: true }\n        );\n      });\n    }\n\n    /**\n     * Initialize the history for the PDF document, using either the current\n     * browser history entry or the document hash, whichever is present.\n     * @param {InitializeParameters} params\n     */\n    initialize({ fingerprint, resetHistory = false, updateUrl = false }) {\n      if (!fingerprint || typeof fingerprint !== \"string\") {\n        console.error(\n          'PDFHistory.initialize: The \"fingerprint\" must be a non-empty string.'\n        );\n        return;\n      }\n      // Ensure that any old state is always reset upon initialization.\n      if (this._initialized) {\n        this.reset();\n      }\n      const reInitialized =\n        this._fingerprint !== \"\" && this._fingerprint !== fingerprint;\n      this._fingerprint = fingerprint;\n      this._updateUrl = updateUrl === true;\n\n      this._initialized = true;\n      this._bindEvents();\n      const state = window.history.state;\n\n      this._popStateInProgress = false;\n      this._blockHashChange = 0;\n      this._currentHash = getCurrentHash();\n      this._numPositionUpdates = 0;\n\n      this._uid = this._maxUid = 0;\n      this._destination = null;\n      this._position = null;\n\n      if (!this._isValidState(state, /* checkReload = */ true) || resetHistory) {\n        const { hash, page, rotation } = this._parseCurrentHash(\n          /* checkNameddest = */ true\n        );\n\n        if (!hash || reInitialized || resetHistory) {\n          // Ensure that the browser history is reset on PDF document load.\n          this._pushOrReplaceState(null, /* forceReplace = */ true);\n          return;\n        }\n        // Ensure that the browser history is initialized correctly when\n        // the document hash is present on PDF document load.\n        this._pushOrReplaceState(\n          { hash, page, rotation },\n          /* forceReplace = */ true\n        );\n        return;\n      }\n\n      // The browser history contains a valid entry, ensure that the history is\n      // initialized correctly on PDF document load.\n      const destination = state.destination;\n      this._updateInternalState(\n        destination,\n        state.uid,\n        /* removeTemporary = */ true\n      );\n\n      if (destination.rotation !== undefined) {\n        this._initialRotation = destination.rotation;\n      }\n      if (destination.dest) {\n        this._initialBookmark = JSON.stringify(destination.dest);\n\n        // If the history is updated, e.g. through the user changing the hash,\n        // before the initial destination has become visible, then we do *not*\n        // want to potentially add `this._position` to the browser history.\n        this._destination.page = null;\n      } else if (destination.hash) {\n        this._initialBookmark = destination.hash;\n      } else if (destination.page) {\n        // Fallback case; shouldn't be necessary, but better safe than sorry.\n        this._initialBookmark = `page=${destination.page}`;\n      }\n    }\n\n    /**\n     * Reset the current `PDFHistory` instance, and consequently prevent any\n     * further updates and/or navigation of the browser history.\n     */\n    reset() {\n      if (this._initialized) {\n        this._pageHide(); // Simulate a 'pagehide' event when resetting.\n\n        this._initialized = false;\n        this._unbindEvents();\n      }\n      if (this._updateViewareaTimeout) {\n        clearTimeout(this._updateViewareaTimeout);\n        this._updateViewareaTimeout = null;\n      }\n      this._initialBookmark = null;\n      this._initialRotation = null;\n    }\n\n    /**\n     * Push an internal destination to the browser history.\n     * @param {PushParameters}\n     */\n    push({ namedDest = null, explicitDest, pageNumber }) {\n      if (!this._initialized) {\n        return;\n      }\n      if (namedDest && typeof namedDest !== \"string\") {\n        console.error(\n          \"PDFHistory.push: \" +\n            `\"${namedDest}\" is not a valid namedDest parameter.`\n        );\n        return;\n      } else if (!Array.isArray(explicitDest)) {\n        console.error(\n          \"PDFHistory.push: \" +\n            `\"${explicitDest}\" is not a valid explicitDest parameter.`\n        );\n        return;\n      } else if (\n        !(\n          Number.isInteger(pageNumber) &&\n          pageNumber > 0 &&\n          pageNumber <= this.linkService.pagesCount\n        )\n      ) {\n        // Allow an unset `pageNumber` if and only if the history is still empty;\n        // please refer to the `this._destination.page = null;` comment above.\n        if (pageNumber !== null || this._destination) {\n          console.error(\n            \"PDFHistory.push: \" +\n              `\"${pageNumber}\" is not a valid pageNumber parameter.`\n          );\n          return;\n        }\n      }\n\n      const hash = namedDest || JSON.stringify(explicitDest);\n      if (!hash) {\n        // The hash *should* never be undefined, but if that were to occur,\n        // avoid any possible issues by not updating the browser history.\n        return;\n      }\n\n      let forceReplace = false;\n      if (\n        this._destination &&\n        (isDestHashesEqual(this._destination.hash, hash) ||\n          isDestArraysEqual(this._destination.dest, explicitDest))\n      ) {\n        // When the new destination is identical to `this._destination`, and\n        // its `page` is undefined, replace the current browser history entry.\n        // NOTE: This can only occur if `this._destination` was set either:\n        //  - through the document hash being specified on load.\n        //  - through the user changing the hash of the document.\n        if (this._destination.page) {\n          return;\n        }\n        forceReplace = true;\n      }\n      if (this._popStateInProgress && !forceReplace) {\n        return;\n      }\n\n      this._pushOrReplaceState(\n        {\n          dest: explicitDest,\n          hash,\n          page: pageNumber,\n          rotation: this.linkService.rotation,\n        },\n        forceReplace\n      );\n\n      if (!this._popStateInProgress) {\n        // Prevent the browser history from updating while the new destination is\n        // being scrolled into view, to avoid potentially inconsistent state.\n        this._popStateInProgress = true;\n        // We defer the resetting of `this._popStateInProgress`, to account for\n        // e.g. zooming occuring when the new destination is being navigated to.\n        Promise.resolve().then(() => {\n          this._popStateInProgress = false;\n        });\n      }\n    }\n\n    /**\n     * Push a page to the browser history; generally the `push` method should be\n     * used instead.\n     * @param {number} pageNumber\n     */\n    pushPage(pageNumber) {\n      if (!this._initialized) {\n        return;\n      }\n      if (\n        !(\n          Number.isInteger(pageNumber) &&\n          pageNumber > 0 &&\n          pageNumber <= this.linkService.pagesCount\n        )\n      ) {\n        console.error(\n          `PDFHistory.pushPage: \"${pageNumber}\" is not a valid page number.`\n        );\n        return;\n      }\n\n      ///if (this._destination?.page === pageNumber) { // lwf\n      if (this._destination && this._destination.page === pageNumber) {\n        // When the new page is identical to the one in `this._destination`, we\n        // don't want to add a potential duplicate entry in the browser history.\n        return;\n      }\n      if (this._popStateInProgress) {\n        return;\n      }\n\n      this._pushOrReplaceState({\n        hash: `page=${pageNumber}`,\n        page: pageNumber,\n        rotation: this.linkService.rotation,\n      });\n\n      if (!this._popStateInProgress) {\n        // Prevent the browser history from updating while the new page is\n        // being scrolled into view, to avoid potentially inconsistent state.\n        this._popStateInProgress = true;\n        // We defer the resetting of `this._popStateInProgress`, to account for\n        // e.g. zooming occuring when the new page is being navigated to.\n        Promise.resolve().then(() => {\n          this._popStateInProgress = false;\n        });\n      }\n    }\n\n    /**\n     * Push the current position to the browser history.\n     */\n    pushCurrentPosition() {\n      if (!this._initialized || this._popStateInProgress) {\n        return;\n      }\n      this._tryPushCurrentPosition();\n    }\n\n    /**\n     * Go back one step in the browser history.\n     * NOTE: Avoids navigating away from the document, useful for \"named actions\".\n     */\n    back() {\n      if (!this._initialized || this._popStateInProgress) {\n        return;\n      }\n      const state = window.history.state;\n      if (this._isValidState(state) && state.uid > 0) {\n        window.history.back();\n      }\n    }\n\n    /**\n     * Go forward one step in the browser history.\n     * NOTE: Avoids navigating away from the document, useful for \"named actions\".\n     */\n    forward() {\n      if (!this._initialized || this._popStateInProgress) {\n        return;\n      }\n      const state = window.history.state;\n      if (this._isValidState(state) && state.uid < this._maxUid) {\n        window.history.forward();\n      }\n    }\n\n    /**\n     * @type {boolean} Indicating if the user is currently moving through the\n     *   browser history, useful e.g. for skipping the next 'hashchange' event.\n     */\n    get popStateInProgress() {\n      return (\n        this._initialized &&\n        (this._popStateInProgress || this._blockHashChange > 0)\n      );\n    }\n\n    get initialBookmark() {\n      return this._initialized ? this._initialBookmark : null;\n    }\n\n    get initialRotation() {\n      return this._initialized ? this._initialRotation : null;\n    }\n\n    /**\n     * @private\n     */\n    _pushOrReplaceState(destination, forceReplace = false) {\n      const shouldReplace = forceReplace || !this._destination;\n      const newState = {\n        fingerprint: this._fingerprint,\n        uid: shouldReplace ? this._uid : this._uid + 1,\n        destination,\n      };\n\n      if (\n        typeof PDFJSDev !== \"undefined\" &&\n        PDFJSDev.test(\"CHROME\") &&\n        ///window.history.state?.chromecomState // lwf\n        (window.history.state && window.history.state.chromecomState)\n      ) {\n        // history.state.chromecomState is managed by chromecom.js.\n        newState.chromecomState = window.history.state.chromecomState;\n      }\n      this._updateInternalState(destination, newState.uid);\n\n      let newUrl;\n      ///if (this._updateUrl && destination?.hash) { // lwf\n      if (this._updateUrl && destination && destination.hash) {\n        const baseUrl = document.location.href.split(\"#\")[0];\n        // Prevent errors in Firefox.\n        if (!baseUrl.startsWith(\"file://\")) {\n          newUrl = `${baseUrl}#${destination.hash}`;\n        }\n      }\n      if (shouldReplace) {\n        window.history.replaceState(newState, \"\", newUrl);\n      } else {\n        window.history.pushState(newState, \"\", newUrl);\n      }\n\n      if (\n        typeof PDFJSDev !== \"undefined\" &&\n        PDFJSDev.test(\"CHROME\") &&\n        top === window\n      ) {\n        // eslint-disable-next-line no-undef\n        chrome.runtime.sendMessage(\"showPageAction\");\n      }\n    }\n\n    /**\n     * @private\n     */\n    _tryPushCurrentPosition(temporary = false) {\n      if (!this._position) {\n        return;\n      }\n      let position = this._position;\n      if (temporary) {\n        position = Object.assign(Object.create(null), this._position);\n        position.temporary = true;\n      }\n\n      if (!this._destination) {\n        this._pushOrReplaceState(position);\n        return;\n      }\n      if (this._destination.temporary) {\n        // Always replace a previous *temporary* position.\n        this._pushOrReplaceState(position, /* forceReplace = */ true);\n        return;\n      }\n      if (this._destination.hash === position.hash) {\n        return; // The current document position has not changed.\n      }\n      if (\n        !this._destination.page &&\n        (POSITION_UPDATED_THRESHOLD <= 0 ||\n          this._numPositionUpdates <= POSITION_UPDATED_THRESHOLD)\n      ) {\n        // `this._destination` was set through the user changing the hash of\n        // the document. Do not add `this._position` to the browser history,\n        // to avoid \"flooding\" it with lots of (nearly) identical entries,\n        // since we cannot ensure that the document position has changed.\n        return;\n      }\n\n      let forceReplace = false;\n      if (\n        this._destination.page >= position.first &&\n        this._destination.page <= position.page\n      ) {\n        // When the `page` of `this._destination` is still visible, do not\n        // update the browsing history when `this._destination` either:\n        //  - contains an internal destination, since in this case we\n        //    cannot ensure that the document position has actually changed.\n        //  - was set through the user changing the hash of the document.\n        if (this._destination.dest || !this._destination.first) {\n          return;\n        }\n        // To avoid \"flooding\" the browser history, replace the current entry.\n        forceReplace = true;\n      }\n      this._pushOrReplaceState(position, forceReplace);\n    }\n\n    /**\n     * @private\n     */\n    _isValidState(state, checkReload = false) {\n      if (!state) {\n        return false;\n      }\n      if (state.fingerprint !== this._fingerprint) {\n        if (checkReload) {\n          // Potentially accept the history entry, even if the fingerprints don't\n          // match, when the viewer was reloaded (see issue 6847).\n          if (\n            typeof state.fingerprint !== \"string\" ||\n            state.fingerprint.length !== this._fingerprint.length\n          ) {\n            return false;\n          }\n          const [perfEntry] = performance.getEntriesByType(\"navigation\");\n          ///if (perfEntry?.type !== \"reload\") { // lwf\n          if (perfEntry && perfEntry.type !== \"reload\") {\n            return false;\n          }\n        } else {\n          // This should only occur in viewers with support for opening more than\n          // one PDF document, e.g. the GENERIC viewer.\n          return false;\n        }\n      }\n      if (!Number.isInteger(state.uid) || state.uid < 0) {\n        return false;\n      }\n      if (state.destination === null || typeof state.destination !== \"object\") {\n        return false;\n      }\n      return true;\n    }\n\n    /**\n     * @private\n     */\n    _updateInternalState(destination, uid, removeTemporary = false) {\n      if (this._updateViewareaTimeout) {\n        // When updating `this._destination`, make sure that we always wait for\n        // the next 'updateviewarea' event before (potentially) attempting to\n        // push the current position to the browser history.\n        clearTimeout(this._updateViewareaTimeout);\n        this._updateViewareaTimeout = null;\n      }\n      ///if (removeTemporary && destination?.temporary) { // lwf\n      if (removeTemporary && destination && destination.temporary) {\n        // When the `destination` comes from the browser history,\n        // we no longer treat it as a *temporary* position.\n        delete destination.temporary;\n      }\n      this._destination = destination;\n      this._uid = uid;\n      this._maxUid = Math.max(this._maxUid, uid);\n      // This should always be reset when `this._destination` is updated.\n      this._numPositionUpdates = 0;\n    }\n\n    /**\n     * @private\n     */\n    _parseCurrentHash(checkNameddest = false) {\n      const hash = unescape(getCurrentHash()).substring(1);\n      const params = parseQueryString(hash);\n\n      const nameddest = params.nameddest || \"\";\n      let page = params.page | 0;\n\n      if (\n        !(\n          Number.isInteger(page) &&\n          page > 0 &&\n          page <= this.linkService.pagesCount\n        ) ||\n        (checkNameddest && nameddest.length > 0)\n      ) {\n        page = null;\n      }\n      return { hash, page, rotation: this.linkService.rotation };\n    }\n\n    /**\n     * @private\n     */\n    _updateViewarea({ location }) {\n      if (this._updateViewareaTimeout) {\n        clearTimeout(this._updateViewareaTimeout);\n        this._updateViewareaTimeout = null;\n      }\n\n      this._position = {\n        hash: this._isViewerInPresentationMode\n          ? `page=${location.pageNumber}`\n          : location.pdfOpenParams.substring(1),\n        page: this.linkService.page,\n        first: location.pageNumber,\n        rotation: location.rotation,\n      };\n\n      if (this._popStateInProgress) {\n        return;\n      }\n\n      if (\n        POSITION_UPDATED_THRESHOLD > 0 &&\n        this._isPagesLoaded &&\n        this._destination &&\n        !this._destination.page\n      ) {\n        // If the current destination was set through the user changing the hash\n        // of the document, we will usually not try to push the current position\n        // to the browser history; see `this._tryPushCurrentPosition()`.\n        //\n        // To prevent `this._tryPushCurrentPosition()` from effectively being\n        // reduced to a no-op in this case, we will assume that the position\n        // *did* in fact change if the 'updateviewarea' event was dispatched\n        // more than `POSITION_UPDATED_THRESHOLD` times.\n        this._numPositionUpdates++;\n      }\n\n      if (UPDATE_VIEWAREA_TIMEOUT > 0) {\n        // When closing the browser, a 'pagehide' event will be dispatched which\n        // *should* allow us to push the current position to the browser history.\n        // In practice, it seems that the event is arriving too late in order for\n        // the session history to be successfully updated.\n        // (For additional details, please refer to the discussion in\n        //  https://bugzilla.mozilla.org/show_bug.cgi?id=1153393.)\n        //\n        // To workaround this we attempt to *temporarily* add the current position\n        // to the browser history only when the viewer is *idle*,\n        // i.e. when scrolling and/or zooming does not occur.\n        //\n        // PLEASE NOTE: It's absolutely imperative that the browser history is\n        // *not* updated too often, since that would render the viewer more or\n        // less unusable. Hence the use of a timeout to delay the update until\n        // the viewer has been idle for `UPDATE_VIEWAREA_TIMEOUT` milliseconds.\n        this._updateViewareaTimeout = setTimeout(() => {\n          if (!this._popStateInProgress) {\n            this._tryPushCurrentPosition(/* temporary = */ true);\n          }\n          this._updateViewareaTimeout = null;\n        }, UPDATE_VIEWAREA_TIMEOUT);\n      }\n    }\n\n    /**\n     * @private\n     */\n    _popState({ state }) {\n      const newHash = getCurrentHash(),\n        hashChanged = this._currentHash !== newHash;\n      this._currentHash = newHash;\n\n      if (\n        (typeof PDFJSDev !== \"undefined\" &&\n          PDFJSDev.test(\"CHROME\") &&\n          ///state?.chromecomState && // lwf\n          state && state.chromecomState &&\n          !this._isValidState(state)) ||\n        !state\n      ) {\n        // This case corresponds to the user changing the hash of the document.\n        this._uid++;\n\n        const { hash, page, rotation } = this._parseCurrentHash();\n        this._pushOrReplaceState(\n          { hash, page, rotation },\n          /* forceReplace = */ true\n        );\n        return;\n      }\n      if (!this._isValidState(state)) {\n        // This should only occur in viewers with support for opening more than\n        // one PDF document, e.g. the GENERIC viewer.\n        return;\n      }\n\n      // Prevent the browser history from updating until the new destination,\n      // as stored in the browser history, has been scrolled into view.\n      this._popStateInProgress = true;\n\n      if (hashChanged) {\n        // When the hash changed, implying that the 'popstate' event will be\n        // followed by a 'hashchange' event, then we do *not* want to update the\n        // browser history when handling the 'hashchange' event (in web/app.js)\n        // since that would *overwrite* the new destination navigated to below.\n        //\n        // To avoid accidentally disabling all future user-initiated hash changes,\n        // if there's e.g. another 'hashchange' listener that stops the event\n        // propagation, we make sure to always force-reset `this._blockHashChange`\n        // after `HASH_CHANGE_TIMEOUT` milliseconds have passed.\n        this._blockHashChange++;\n        waitOnEventOrTimeout({\n          target: window,\n          name: \"hashchange\",\n          delay: HASH_CHANGE_TIMEOUT,\n        }).then(() => {\n          this._blockHashChange--;\n        });\n      }\n\n      // Navigate to the new destination.\n      const destination = state.destination;\n      this._updateInternalState(\n        destination,\n        state.uid,\n        /* removeTemporary = */ true\n      );\n\n      if (isValidRotation(destination.rotation)) {\n        this.linkService.rotation = destination.rotation;\n      }\n      if (destination.dest) {\n        this.linkService.goToDestination(destination.dest);\n      } else if (destination.hash) {\n        this.linkService.setHash(destination.hash);\n      } else if (destination.page) {\n        // Fallback case; shouldn't be necessary, but better safe than sorry.\n        this.linkService.page = destination.page;\n      }\n\n      // Since `PDFLinkService.goToDestination` is asynchronous, we thus defer the\n      // resetting of `this._popStateInProgress` slightly.\n      Promise.resolve().then(() => {\n        this._popStateInProgress = false;\n      });\n    }\n\n    /**\n     * @private\n     */\n    _pageHide() {\n      // Attempt to push the `this._position` into the browser history when\n      // navigating away from the document. This is *only* done if the history\n      // is empty/temporary, since otherwise an existing browser history entry\n      // will end up being overwritten (given that new entries cannot be pushed\n      // into the browser history when the 'unload' event has already fired).\n      if (!this._destination || this._destination.temporary) {\n        this._tryPushCurrentPosition();\n      }\n    }\n\n    /**\n     * @private\n     */\n    _bindEvents() {\n      if (this._boundEvents) {\n        return; // The event listeners were already added.\n      }\n      this._boundEvents = {\n        updateViewarea: this._updateViewarea.bind(this),\n        popState: this._popState.bind(this),\n        pageHide: this._pageHide.bind(this),\n      };\n\n      this.eventBus._on(\"updateviewarea\", this._boundEvents.updateViewarea);\n      window.addEventListener(\"popstate\", this._boundEvents.popState);\n      window.addEventListener(\"pagehide\", this._boundEvents.pageHide);\n    }\n\n    /**\n     * @private\n     */\n    _unbindEvents() {\n      if (!this._boundEvents) {\n        return; // The event listeners were already removed.\n      }\n      this.eventBus._off(\"updateviewarea\", this._boundEvents.updateViewarea);\n      window.removeEventListener(\"popstate\", this._boundEvents.popState);\n      window.removeEventListener(\"pagehide\", this._boundEvents.pageHide);\n\n      this._boundEvents = null;\n    }\n  }\n\n  function isDestHashesEqual(destHash, pushHash) {\n    if (typeof destHash !== \"string\" || typeof pushHash !== \"string\") {\n      return false;\n    }\n    if (destHash === pushHash) {\n      return true;\n    }\n    const { nameddest } = parseQueryString(destHash);\n    if (nameddest === pushHash) {\n      return true;\n    }\n    return false;\n  }\n\n  function isDestArraysEqual(firstDest, secondDest) {\n    function isEntryEqual(first, second) {\n      if (typeof first !== typeof second) {\n        return false;\n      }\n      if (Array.isArray(first) || Array.isArray(second)) {\n        return false;\n      }\n      if (first !== null && typeof first === \"object\" && second !== null) {\n        if (Object.keys(first).length !== Object.keys(second).length) {\n          return false;\n        }\n        for (const key in first) {\n          if (!isEntryEqual(first[key], second[key])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return first === second || (Number.isNaN(first) && Number.isNaN(second));\n    }\n\n    if (!(Array.isArray(firstDest) && Array.isArray(secondDest))) {\n      return false;\n    }\n    if (firstDest.length !== secondDest.length) {\n      return false;\n    }\n    for (let i = 0, ii = firstDest.length; i < ii; i++) {\n      if (!isEntryEqual(firstDest[i], secondDest[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  return { isDestArraysEqual, isDestHashesEqual, PDFHistory };\n});"]}