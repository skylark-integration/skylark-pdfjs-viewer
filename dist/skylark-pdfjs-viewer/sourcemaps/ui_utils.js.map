{"version":3,"sources":["ui_utils.js"],"names":["define","PDFJSDev","LOADINGBAR_END_OFFSET_VAR","ScrollMode","UNKNOWN","VERTICAL","HORIZONTAL","WRAPPED","SpreadMode","NONE","ODD","EVEN","NullL10n","getLanguage","getDirection","get","property","args","fallback","text","replace","all","name","formatL10nValue","[object Object]","element","binarySearchFirstItem","items","condition","minIndex","maxIndex","length","currentIndex","backtrackBeforeAllVisibleElements","index","views","top","elt","div","pageTop","offsetTop","clientTop","i","clientHeight","normalizeWheelEventDirection","evt","delta","Math","sqrt","deltaX","deltaY","angle","atan2","PI","WaitOnType","EVENT","TIMEOUT","animationStarted","Promise","resolve","test","window","setTimeout","requestAnimationFrame","dispatchDOMEvent","eventName","Error","details","Object","create","obj","key","value","document","event","createEvent","initCustomEvent","dispatchEvent","EventBus","options","this","_listeners","_isInAutomation","isInAutomation","listener","_on","external","once","_off","eventListeners","Array","prototype","slice","call","arguments","externalListeners","forEach","push","apply","ii","splice","approximateFraction","x","floor","xinv","x_","result","a","b","c","d","p","q","AutoPrintRegExp","CSS_UNITS","DEFAULT_SCALE","DEFAULT_SCALE_VALUE","getActiveOrFocusedElement","curRoot","curActiveOrFocused","activeElement","querySelector","shadowRoot","getOutputScale","ctx","pixelRatio","devicePixelRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","backingStorePixelRatio","sx","sy","scaled","getPageSizeInches","view","userUnit","rotate","x1","y1","x2","y2","changeOrientation","width","height","getPDFFileNameFromURL","url","defaultFilename","trim","substring","toLowerCase","isDataSchema","console","warn","reFilename","splitURI","exec","suggestedFilename","includes","decodeURIComponent","ex","getVisibleElements","scrollEl","sortByVisibility","horizontal","rtl","scrollTop","bottom","left","scrollLeft","right","clientWidth","visible","numViews","firstVisibleElementInd","elementLeft","offsetLeft","clientLeft","elementRight","lastEdge","currentWidth","currentHeight","viewWidth","viewHeight","viewRight","viewBottom","hiddenHeight","max","fractionWidth","percent","id","y","widthPercent","first","last","sort","pc","abs","isPortraitOrientation","size","isValidRotation","Number","isInteger","isValidScrollMode","mode","values","isValidSpreadMode","MAX_AUTO_SCALE","MAX_SCALE","MIN_SCALE","moveToEndOfArray","arr","moved","len","write","read","noContextMenuHandler","preventDefault","normalizeWheelEventDelta","deltaMode","MOUSE_PIXELS_PER_LINE","parseQueryString","query","parts","split","params","param","PresentationModeState","NORMAL","CHANGING","FULLSCREEN","ProgressBar","units","bar","parentNode","style","_indeterminate","classList","add","remove","progressSize","_percent","val","v","min","isNaN","_updateBar","viewer","scrollbarWidth","offsetWidth","documentElement","setProperty","RendererType","CANVAS","SVG","roundToDivide","r","round","SCROLLBAR_PADDING","scrollIntoView","spot","skipOverflowHiddenElements","parent","offsetParent","error","offsetY","offsetX","scrollHeight","scrollWidth","getComputedStyle","overflow","dataset","_scaleY","_scaleX","undefined","SidebarView","THUMBS","OUTLINE","ATTACHMENTS","LAYERS","TextLayerMode","DISABLE","ENABLE","ENABLE_ENHANCE","UNKNOWN_SCALE","VERTICAL_PADDING","waitOnEventOrTimeout","target","delay","reject","handler","type","eventHandler","removeEventListener","timeout","clearTimeout","bind","addEventListener","timeoutHandler","watchScroll","viewAreaElement","callback","debounceScroll","rAF","currentX","lastX","state","currentY","lastY","down","_eventHandler"],"mappings":"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","file":"../ui_utils.js","sourcesContent":["define([\n  \"./pdfjs_dev\"\n],function(PDFJSDev){\n  /* Copyright 2012 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const CSS_UNITS = 96.0 / 72.0;\n  const DEFAULT_SCALE_VALUE = \"auto\";\n  const DEFAULT_SCALE = 1.0;\n  const MIN_SCALE = 0.1;\n  const MAX_SCALE = 10.0;\n  const UNKNOWN_SCALE = 0;\n  const MAX_AUTO_SCALE = 1.25;\n  const SCROLLBAR_PADDING = 40;\n  const VERTICAL_PADDING = 5;\n\n  const LOADINGBAR_END_OFFSET_VAR = \"--loadingBar-end-offset\";\n\n  const PresentationModeState = {\n    UNKNOWN: 0,\n    NORMAL: 1,\n    CHANGING: 2,\n    FULLSCREEN: 3,\n  };\n\n  const SidebarView = {\n    UNKNOWN: -1,\n    NONE: 0,\n    THUMBS: 1, // Default value.\n    OUTLINE: 2,\n    ATTACHMENTS: 3,\n    LAYERS: 4,\n  };\n\n  const RendererType = {\n    CANVAS: \"canvas\",\n    SVG: \"svg\",\n  };\n\n  const TextLayerMode = {\n    DISABLE: 0,\n    ENABLE: 1,\n    ENABLE_ENHANCE: 2,\n  };\n\n  const ScrollMode = {\n    UNKNOWN: -1,\n    VERTICAL: 0, // Default value.\n    HORIZONTAL: 1,\n    WRAPPED: 2,\n  };\n\n  const SpreadMode = {\n    UNKNOWN: -1,\n    NONE: 0, // Default value.\n    ODD: 1,\n    EVEN: 2,\n  };\n\n  // Used by `PDFViewerApplication`, and by the API unit-tests.\n  const AutoPrintRegExp = /\\bprint\\s*\\(/;\n\n  // Replaces {{arguments}} with their values.\n  function formatL10nValue(text, args) {\n    if (!args) {\n      return text;\n    }\n    return text.replace(/\\{\\{\\s*(\\w+)\\s*\\}\\}/g, (all, name) => {\n      return name in args ? args[name] : \"{{\" + name + \"}}\";\n    });\n  }\n\n  /**\n   * No-op implementation of the localization service.\n   * @implements {IL10n}\n   */\n  const NullL10n = {\n    async getLanguage() {\n      return \"en-us\";\n    },\n\n    async getDirection() {\n      return \"ltr\";\n    },\n\n    async get(property, args, fallback) {\n      return formatL10nValue(fallback, args);\n    },\n\n    async translate(element) {},\n  };\n\n  /**\n   * Returns scale factor for the canvas. It makes sense for the HiDPI displays.\n   * @returns {Object} The object with horizontal (sx) and vertical (sy)\n   *                   scales. The scaled property is set to false if scaling is\n   *                   not required, true otherwise.\n   */\n  function getOutputScale(ctx) {\n    const devicePixelRatio = window.devicePixelRatio || 1;\n    const backingStoreRatio =\n      ctx.webkitBackingStorePixelRatio ||\n      ctx.mozBackingStorePixelRatio ||\n      ctx.backingStorePixelRatio ||\n      1;\n    const pixelRatio = devicePixelRatio / backingStoreRatio;\n    return {\n      sx: pixelRatio,\n      sy: pixelRatio,\n      scaled: pixelRatio !== 1,\n    };\n  }\n\n  /**\n   * Scrolls specified element into view of its parent.\n   * @param {Object} element - The element to be visible.\n   * @param {Object} spot - An object with optional top and left properties,\n   *   specifying the offset from the top left edge.\n   * @param {boolean} skipOverflowHiddenElements - Ignore elements that have\n   *   the CSS rule `overflow: hidden;` set. The default is false.\n   */\n  function scrollIntoView(element, spot, skipOverflowHiddenElements = false) {\n    // Assuming offsetParent is available (it's not available when viewer is in\n    // hidden iframe or object). We have to scroll: if the offsetParent is not set\n    // producing the error. See also animationStarted.\n    let parent = element.offsetParent;\n    if (!parent) {\n      console.error(\"offsetParent is not set -- cannot scroll\");\n      return;\n    }\n    let offsetY = element.offsetTop + element.clientTop;\n    let offsetX = element.offsetLeft + element.clientLeft;\n    while (\n      (parent.clientHeight === parent.scrollHeight &&\n        parent.clientWidth === parent.scrollWidth) ||\n      (skipOverflowHiddenElements &&\n        getComputedStyle(parent).overflow === \"hidden\")\n    ) {\n      if (parent.dataset._scaleY) {\n        offsetY /= parent.dataset._scaleY;\n        offsetX /= parent.dataset._scaleX;\n      }\n      offsetY += parent.offsetTop;\n      offsetX += parent.offsetLeft;\n      parent = parent.offsetParent;\n      if (!parent) {\n        return; // no need to scroll\n      }\n    }\n    if (spot) {\n      if (spot.top !== undefined) {\n        offsetY += spot.top;\n      }\n      if (spot.left !== undefined) {\n        offsetX += spot.left;\n        parent.scrollLeft = offsetX;\n      }\n    }\n    parent.scrollTop = offsetY;\n  }\n\n  /**\n   * Helper function to start monitoring the scroll event and converting them into\n   * PDF.js friendly one: with scroll debounce and scroll direction.\n   */\n  function watchScroll(viewAreaElement, callback) {\n    const debounceScroll = function (evt) {\n      if (rAF) {\n        return;\n      }\n      // schedule an invocation of scroll for next animation frame.\n      rAF = window.requestAnimationFrame(function viewAreaElementScrolled() {\n        rAF = null;\n\n        const currentX = viewAreaElement.scrollLeft;\n        const lastX = state.lastX;\n        if (currentX !== lastX) {\n          state.right = currentX > lastX;\n        }\n        state.lastX = currentX;\n        const currentY = viewAreaElement.scrollTop;\n        const lastY = state.lastY;\n        if (currentY !== lastY) {\n          state.down = currentY > lastY;\n        }\n        state.lastY = currentY;\n        callback(state);\n      });\n    };\n\n    const state = {\n      right: true,\n      down: true,\n      lastX: viewAreaElement.scrollLeft,\n      lastY: viewAreaElement.scrollTop,\n      _eventHandler: debounceScroll,\n    };\n\n    let rAF = null;\n    viewAreaElement.addEventListener(\"scroll\", debounceScroll, true);\n    return state;\n  }\n\n  /**\n   * Helper function to parse query string (e.g. ?param1=value&parm2=...).\n   */\n  function parseQueryString(query) {\n    const parts = query.split(\"&\");\n    const params = Object.create(null);\n    for (let i = 0, ii = parts.length; i < ii; ++i) {\n      const param = parts[i].split(\"=\");\n      const key = param[0].toLowerCase();\n      const value = param.length > 1 ? param[1] : null;\n      params[decodeURIComponent(key)] = decodeURIComponent(value);\n    }\n    return params;\n  }\n\n  /**\n   * Use binary search to find the index of the first item in a given array which\n   * passes a given condition. The items are expected to be sorted in the sense\n   * that if the condition is true for one item in the array, then it is also true\n   * for all following items.\n   *\n   * @returns {number} Index of the first array element to pass the test,\n   *                   or |items.length| if no such element exists.\n   */\n  function binarySearchFirstItem(items, condition) {\n    let minIndex = 0;\n    let maxIndex = items.length - 1;\n\n    if (maxIndex < 0 || !condition(items[maxIndex])) {\n      return items.length;\n    }\n    if (condition(items[minIndex])) {\n      return minIndex;\n    }\n\n    while (minIndex < maxIndex) {\n      const currentIndex = (minIndex + maxIndex) >> 1;\n      const currentItem = items[currentIndex];\n      if (condition(currentItem)) {\n        maxIndex = currentIndex;\n      } else {\n        minIndex = currentIndex + 1;\n      }\n    }\n    return minIndex; /* === maxIndex */\n  }\n\n  /**\n   *  Approximates float number as a fraction using Farey sequence (max order\n   *  of 8).\n   *  @param {number} x - Positive float number.\n   *  @returns {Array} Estimated fraction: the first array item is a numerator,\n   *                   the second one is a denominator.\n   */\n  function approximateFraction(x) {\n    // Fast paths for int numbers or their inversions.\n    if (Math.floor(x) === x) {\n      return [x, 1];\n    }\n    const xinv = 1 / x;\n    const limit = 8;\n    if (xinv > limit) {\n      return [1, limit];\n    } else if (Math.floor(xinv) === xinv) {\n      return [1, xinv];\n    }\n\n    const x_ = x > 1 ? xinv : x;\n    // a/b and c/d are neighbours in Farey sequence.\n    let a = 0,\n      b = 1,\n      c = 1,\n      d = 1;\n    // Limiting search to order 8.\n    while (true) {\n      // Generating next term in sequence (order of q).\n      const p = a + c,\n        q = b + d;\n      if (q > limit) {\n        break;\n      }\n      if (x_ <= p / q) {\n        c = p;\n        d = q;\n      } else {\n        a = p;\n        b = q;\n      }\n    }\n    let result;\n    // Select closest of the neighbours to x.\n    if (x_ - a / b < c / d - x_) {\n      result = x_ === x ? [a, b] : [b, a];\n    } else {\n      result = x_ === x ? [c, d] : [d, c];\n    }\n    return result;\n  }\n\n  function roundToDivide(x, div) {\n    const r = x % div;\n    return r === 0 ? x : Math.round(x - r + div);\n  }\n\n  /**\n   * Gets the size of the specified page, converted from PDF units to inches.\n   * @param {Object} An Object containing the properties: {Array} `view`,\n   *   {number} `userUnit`, and {number} `rotate`.\n   * @returns {Object} An Object containing the properties: {number} `width`\n   *   and {number} `height`, given in inches.\n   */\n  function getPageSizeInches({ view, userUnit, rotate }) {\n    const [x1, y1, x2, y2] = view;\n    // We need to take the page rotation into account as well.\n    const changeOrientation = rotate % 180 !== 0;\n\n    const width = ((x2 - x1) / 72) * userUnit;\n    const height = ((y2 - y1) / 72) * userUnit;\n\n    return {\n      width: changeOrientation ? height : width,\n      height: changeOrientation ? width : height,\n    };\n  }\n\n  /**\n   * Helper function for getVisibleElements.\n   *\n   * @param {number} index - initial guess at the first visible element\n   * @param {Array} views - array of pages, into which `index` is an index\n   * @param {number} top - the top of the scroll pane\n   * @returns {number} less than or equal to `index` that is definitely at or\n   *   before the first visible element in `views`, but not by too much. (Usually,\n   *   this will be the first element in the first partially visible row in\n   *   `views`, although sometimes it goes back one row further.)\n   */\n  function backtrackBeforeAllVisibleElements(index, views, top) {\n    // binarySearchFirstItem's assumption is that the input is ordered, with only\n    // one index where the conditions flips from false to true: [false ...,\n    // true...]. With vertical scrolling and spreads, it is possible to have\n    // [false ..., true, false, true ...]. With wrapped scrolling we can have a\n    // similar sequence, with many more mixed true and false in the middle.\n    //\n    // So there is no guarantee that the binary search yields the index of the\n    // first visible element. It could have been any of the other visible elements\n    // that were preceded by a hidden element.\n\n    // Of course, if either this element or the previous (hidden) element is also\n    // the first element, there's nothing to worry about.\n    if (index < 2) {\n      return index;\n    }\n\n    // That aside, the possible cases are represented below.\n    //\n    //     ****  = fully hidden\n    //     A*B*  = mix of partially visible and/or hidden pages\n    //     CDEF  = fully visible\n    //\n    // (1) Binary search could have returned A, in which case we can stop.\n    // (2) Binary search could also have returned B, in which case we need to\n    // check the whole row.\n    // (3) Binary search could also have returned C, in which case we need to\n    // check the whole previous row.\n    //\n    // There's one other possibility:\n    //\n    //     ****  = fully hidden\n    //     ABCD  = mix of fully and/or partially visible pages\n    //\n    // (4) Binary search could only have returned A.\n\n    // Initially assume that we need to find the beginning of the current row\n    // (case 1, 2, or 4), which means finding a page that is above the current\n    // page's top. If the found page is partially visible, we're definitely not in\n    // case 3, and this assumption is correct.\n    let elt = views[index].div;\n    let pageTop = elt.offsetTop + elt.clientTop;\n\n    if (pageTop >= top) {\n      // The found page is fully visible, so we're actually either in case 3 or 4,\n      // and unfortunately we can't tell the difference between them without\n      // scanning the entire previous row, so we just conservatively assume that\n      // we do need to backtrack to that row. In both cases, the previous page is\n      // in the previous row, so use its top instead.\n      elt = views[index - 1].div;\n      pageTop = elt.offsetTop + elt.clientTop;\n    }\n\n    // Now we backtrack to the first page that still has its bottom below\n    // `pageTop`, which is the top of a page in the first visible row (unless\n    // we're in case 4, in which case it's the row before that).\n    // `index` is found by binary search, so the page at `index - 1` is\n    // invisible and we can start looking for potentially visible pages from\n    // `index - 2`. (However, if this loop terminates on its first iteration,\n    // which is the case when pages are stacked vertically, `index` should remain\n    // unchanged, so we use a distinct loop variable.)\n    for (let i = index - 2; i >= 0; --i) {\n      elt = views[i].div;\n      if (elt.offsetTop + elt.clientTop + elt.clientHeight <= pageTop) {\n        // We have reached the previous row, so stop now.\n        // This loop is expected to terminate relatively quickly because the\n        // number of pages per row is expected to be small.\n        break;\n      }\n      index = i;\n    }\n    return index;\n  }\n\n  /**\n   * @typedef {Object} GetVisibleElementsParameters\n   * @property {HTMLElement} scrollEl - A container that can possibly scroll.\n   * @property {Array} views - Objects with a `div` property that contains an\n   *   HTMLElement, which should all be descendants of `scrollEl` satisfying the\n   *   relevant layout assumptions.\n   * @property {boolean} sortByVisibility - If `true`, the returned elements are\n   *   sorted in descending order of the percent of their padding box that is\n   *   visible. The default value is `false`.\n   * @property {boolean} horizontal - If `true`, the elements are assumed to be\n   *   laid out horizontally instead of vertically. The default value is `false`.\n   * @property {boolean} rtl - If `true`, the `scrollEl` container is assumed to\n   *   be in right-to-left mode. The default value is `false`.\n   */\n\n  /**\n   * Generic helper to find out what elements are visible within a scroll pane.\n   *\n   * Well, pretty generic. There are some assumptions placed on the elements\n   * referenced by `views`:\n   *   - If `horizontal`, no left of any earlier element is to the right of the\n   *     left of any later element.\n   *   - Otherwise, `views` can be split into contiguous rows where, within a row,\n   *     no top of any element is below the bottom of any other element, and\n   *     between rows, no bottom of any element in an earlier row is below the\n   *     top of any element in a later row.\n   *\n   * (Here, top, left, etc. all refer to the padding edge of the element in\n   * question. For pages, that ends up being equivalent to the bounding box of the\n   * rendering canvas. Earlier and later refer to index in `views`, not page\n   * layout.)\n   *\n   * @param {GetVisibleElementsParameters}\n   * @returns {Object} `{ first, last, views: [{ id, x, y, view, percent }] }`\n   */\n  function getVisibleElements({\n    scrollEl,\n    views,\n    sortByVisibility = false,\n    horizontal = false,\n    rtl = false,\n  }) {\n    const top = scrollEl.scrollTop,\n      bottom = top + scrollEl.clientHeight;\n    const left = scrollEl.scrollLeft,\n      right = left + scrollEl.clientWidth;\n\n    // Throughout this \"generic\" function, comments will assume we're working with\n    // PDF document pages, which is the most important and complex case. In this\n    // case, the visible elements we're actually interested is the page canvas,\n    // which is contained in a wrapper which adds no padding/border/margin, which\n    // is itself contained in `view.div` which adds no padding (but does add a\n    // border). So, as specified in this function's doc comment, this function\n    // does all of its work on the padding edge of the provided views, starting at\n    // offsetLeft/Top (which includes margin) and adding clientLeft/Top (which is\n    // the border). Adding clientWidth/Height gets us the bottom-right corner of\n    // the padding edge.\n    function isElementBottomAfterViewTop(view) {\n      const element = view.div;\n      const elementBottom =\n        element.offsetTop + element.clientTop + element.clientHeight;\n      return elementBottom > top;\n    }\n    function isElementNextAfterViewHorizontally(view) {\n      const element = view.div;\n      const elementLeft = element.offsetLeft + element.clientLeft;\n      const elementRight = elementLeft + element.clientWidth;\n      return rtl ? elementLeft < right : elementRight > left;\n    }\n\n    const visible = [],\n      numViews = views.length;\n    let firstVisibleElementInd = binarySearchFirstItem(\n      views,\n      horizontal\n        ? isElementNextAfterViewHorizontally\n        : isElementBottomAfterViewTop\n    );\n\n    // Please note the return value of the `binarySearchFirstItem` function when\n    // no valid element is found (hence the `firstVisibleElementInd` check below).\n    if (\n      firstVisibleElementInd > 0 &&\n      firstVisibleElementInd < numViews &&\n      !horizontal\n    ) {\n      // In wrapped scrolling (or vertical scrolling with spreads), with some page\n      // sizes, isElementBottomAfterViewTop doesn't satisfy the binary search\n      // condition: there can be pages with bottoms above the view top between\n      // pages with bottoms below. This function detects and corrects that error;\n      // see it for more comments.\n      firstVisibleElementInd = backtrackBeforeAllVisibleElements(\n        firstVisibleElementInd,\n        views,\n        top\n      );\n    }\n\n    // lastEdge acts as a cutoff for us to stop looping, because we know all\n    // subsequent pages will be hidden.\n    //\n    // When using wrapped scrolling or vertical scrolling with spreads, we can't\n    // simply stop the first time we reach a page below the bottom of the view;\n    // the tops of subsequent pages on the same row could still be visible. In\n    // horizontal scrolling, we don't have that issue, so we can stop as soon as\n    // we pass `right`, without needing the code below that handles the -1 case.\n    let lastEdge = horizontal ? right : -1;\n\n    for (let i = firstVisibleElementInd; i < numViews; i++) {\n      const view = views[i],\n        element = view.div;\n      const currentWidth = element.offsetLeft + element.clientLeft;\n      const currentHeight = element.offsetTop + element.clientTop;\n      const viewWidth = element.clientWidth,\n        viewHeight = element.clientHeight;\n      const viewRight = currentWidth + viewWidth;\n      const viewBottom = currentHeight + viewHeight;\n\n      if (lastEdge === -1) {\n        // As commented above, this is only needed in non-horizontal cases.\n        // Setting lastEdge to the bottom of the first page that is partially\n        // visible ensures that the next page fully below lastEdge is on the\n        // next row, which has to be fully hidden along with all subsequent rows.\n        if (viewBottom >= bottom) {\n          lastEdge = viewBottom;\n        }\n      } else if ((horizontal ? currentWidth : currentHeight) > lastEdge) {\n        break;\n      }\n\n      if (\n        viewBottom <= top ||\n        currentHeight >= bottom ||\n        viewRight <= left ||\n        currentWidth >= right\n      ) {\n        continue;\n      }\n\n      const hiddenHeight =\n        Math.max(0, top - currentHeight) + Math.max(0, viewBottom - bottom);\n      const hiddenWidth =\n        Math.max(0, left - currentWidth) + Math.max(0, viewRight - right);\n\n      const fractionHeight = (viewHeight - hiddenHeight) / viewHeight,\n        fractionWidth = (viewWidth - hiddenWidth) / viewWidth;\n      const percent = (fractionHeight * fractionWidth * 100) | 0;\n\n      visible.push({\n        id: view.id,\n        x: currentWidth,\n        y: currentHeight,\n        view,\n        percent,\n        widthPercent: (fractionWidth * 100) | 0,\n      });\n    }\n\n    const first = visible[0],\n      last = visible[visible.length - 1];\n\n    if (sortByVisibility) {\n      visible.sort(function (a, b) {\n        const pc = a.percent - b.percent;\n        if (Math.abs(pc) > 0.001) {\n          return -pc;\n        }\n        return a.id - b.id; // ensure stability\n      });\n    }\n    return { first, last, views: visible };\n  }\n\n  /**\n   * Event handler to suppress context menu.\n   */\n  function noContextMenuHandler(evt) {\n    evt.preventDefault();\n  }\n\n  function isDataSchema(url) {\n    let i = 0;\n    const ii = url.length;\n    while (i < ii && url[i].trim() === \"\") {\n      i++;\n    }\n    return url.substring(i, i + 5).toLowerCase() === \"data:\";\n  }\n\n  /**\n   * Returns the filename or guessed filename from the url (see issue 3455).\n   * @param {string} url - The original PDF location.\n   * @param {string} defaultFilename - The value returned if the filename is\n   *   unknown, or the protocol is unsupported.\n   * @returns {string} Guessed PDF filename.\n   */\n  function getPDFFileNameFromURL(url, defaultFilename = \"document.pdf\") {\n    if (typeof url !== \"string\") {\n      return defaultFilename;\n    }\n    if (isDataSchema(url)) {\n      console.warn(\n        \"getPDFFileNameFromURL: \" +\n          'ignoring \"data:\" URL for performance reasons.'\n      );\n      return defaultFilename;\n    }\n    const reURI = /^(?:(?:[^:]+:)?\\/\\/[^/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/;\n    //              SCHEME        HOST        1.PATH  2.QUERY   3.REF\n    // Pattern to get last matching NAME.pdf\n    const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n    const splitURI = reURI.exec(url);\n    let suggestedFilename =\n      reFilename.exec(splitURI[1]) ||\n      reFilename.exec(splitURI[2]) ||\n      reFilename.exec(splitURI[3]);\n    if (suggestedFilename) {\n      suggestedFilename = suggestedFilename[0];\n      if (suggestedFilename.includes(\"%\")) {\n        // URL-encoded %2Fpath%2Fto%2Ffile.pdf should be file.pdf\n        try {\n          suggestedFilename = reFilename.exec(\n            decodeURIComponent(suggestedFilename)\n          )[0];\n        } catch (ex) {\n          // Possible (extremely rare) errors:\n          // URIError \"Malformed URI\", e.g. for \"%AA.pdf\"\n          // TypeError \"null has no properties\", e.g. for \"%2F.pdf\"\n        }\n      }\n    }\n    return suggestedFilename || defaultFilename;\n  }\n\n  function normalizeWheelEventDirection(evt) {\n    let delta = Math.sqrt(evt.deltaX * evt.deltaX + evt.deltaY * evt.deltaY);\n    const angle = Math.atan2(evt.deltaY, evt.deltaX);\n    if (-0.25 * Math.PI < angle && angle < 0.75 * Math.PI) {\n      // All that is left-up oriented has to change the sign.\n      delta = -delta;\n    }\n    return delta;\n  }\n\n  function normalizeWheelEventDelta(evt) {\n    let delta = normalizeWheelEventDirection(evt);\n\n    const MOUSE_DOM_DELTA_PIXEL_MODE = 0;\n    const MOUSE_DOM_DELTA_LINE_MODE = 1;\n    const MOUSE_PIXELS_PER_LINE = 30;\n    const MOUSE_LINES_PER_PAGE = 30;\n\n    // Converts delta to per-page units\n    if (evt.deltaMode === MOUSE_DOM_DELTA_PIXEL_MODE) {\n      delta /= MOUSE_PIXELS_PER_LINE * MOUSE_LINES_PER_PAGE;\n    } else if (evt.deltaMode === MOUSE_DOM_DELTA_LINE_MODE) {\n      delta /= MOUSE_LINES_PER_PAGE;\n    }\n    return delta;\n  }\n\n  function isValidRotation(angle) {\n    return Number.isInteger(angle) && angle % 90 === 0;\n  }\n\n  function isValidScrollMode(mode) {\n    return (\n      Number.isInteger(mode) &&\n      Object.values(ScrollMode).includes(mode) &&\n      mode !== ScrollMode.UNKNOWN\n    );\n  }\n\n  function isValidSpreadMode(mode) {\n    return (\n      Number.isInteger(mode) &&\n      Object.values(SpreadMode).includes(mode) &&\n      mode !== SpreadMode.UNKNOWN\n    );\n  }\n\n  function isPortraitOrientation(size) {\n    return size.width <= size.height;\n  }\n\n  const WaitOnType = {\n    EVENT: \"event\",\n    TIMEOUT: \"timeout\",\n  };\n\n  /**\n   * @typedef {Object} WaitOnEventOrTimeoutParameters\n   * @property {Object} target - The event target, can for example be:\n   *   `window`, `document`, a DOM element, or an {EventBus} instance.\n   * @property {string} name - The name of the event.\n   * @property {number} delay - The delay, in milliseconds, after which the\n   *   timeout occurs (if the event wasn't already dispatched).\n   */\n\n  /**\n   * Allows waiting for an event or a timeout, whichever occurs first.\n   * Can be used to ensure that an action always occurs, even when an event\n   * arrives late or not at all.\n   *\n   * @param {WaitOnEventOrTimeoutParameters}\n   * @returns {Promise} A promise that is resolved with a {WaitOnType} value.\n   */\n  function waitOnEventOrTimeout({ target, name, delay = 0 }) {\n    return new Promise(function (resolve, reject) {\n      if (\n        typeof target !== \"object\" ||\n        !(name && typeof name === \"string\") ||\n        !(Number.isInteger(delay) && delay >= 0)\n      ) {\n        throw new Error(\"waitOnEventOrTimeout - invalid parameters.\");\n      }\n\n      function handler(type) {\n        if (target instanceof EventBus) {\n          target._off(name, eventHandler);\n        } else {\n          target.removeEventListener(name, eventHandler);\n        }\n\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n        resolve(type);\n      }\n\n      const eventHandler = handler.bind(null, WaitOnType.EVENT);\n      if (target instanceof EventBus) {\n        target._on(name, eventHandler);\n      } else {\n        target.addEventListener(name, eventHandler);\n      }\n\n      const timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);\n      const timeout = setTimeout(timeoutHandler, delay);\n    });\n  }\n\n  /**\n   * Promise that is resolved when DOM window becomes visible.\n   */\n  const animationStarted = new Promise(function (resolve) {\n    if (\n      typeof PDFJSDev !== \"undefined\" &&\n      PDFJSDev.test(\"LIB && TESTING\") &&\n      typeof window === \"undefined\"\n    ) {\n      // Prevent \"ReferenceError: window is not defined\" errors when running the\n      // unit-tests in Node.js/Travis.\n      setTimeout(resolve, 20);\n      return;\n    }\n    window.requestAnimationFrame(resolve);\n  });\n\n  /**\n   * NOTE: Only used to support various PDF viewer tests in `mozilla-central`.\n   */\n  function dispatchDOMEvent(eventName, args = null) {\n    if (typeof PDFJSDev !== \"undefined\" && !PDFJSDev.test(\"MOZCENTRAL\")) {\n      throw new Error(\"Not implemented: dispatchDOMEvent\");\n    }\n    const details = Object.create(null);\n    if (args && args.length > 0) {\n      const obj = args[0];\n      for (const key in obj) {\n        const value = obj[key];\n        if (key === \"source\") {\n          if (value === window || value === document) {\n            return; // No need to re-dispatch (already) global events.\n          }\n          continue; // Ignore the `source` property.\n        }\n        details[key] = value;\n      }\n    }\n    const event = document.createEvent(\"CustomEvent\");\n    event.initCustomEvent(eventName, true, true, details);\n    document.dispatchEvent(event);\n  }\n\n  /**\n   * Simple event bus for an application. Listeners are attached using the `on`\n   * and `off` methods. To raise an event, the `dispatch` method shall be used.\n   */\n  class EventBus {\n    constructor(options) {\n      this._listeners = Object.create(null);\n\n      if (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"MOZCENTRAL\")) {\n        ///this._isInAutomation = options?.isInAutomation === true; // lwf\n        this._isInAutomation = options && (options.isInAutomation === true);\n      }\n    }\n\n    /**\n     * @param {string} eventName\n     * @param {function} listener\n     * @param {Object} [options]\n     */\n    on(eventName, listener, options = null) {\n      this._on(eventName, listener, {\n        external: true,\n        ///once: options?.once, // lwf\n        once: options && options.once, \n      });\n    }\n\n    /**\n     * @param {string} eventName\n     * @param {function} listener\n     * @param {Object} [options]\n     */\n    off(eventName, listener, options = null) {\n      this._off(eventName, listener, {\n        external: true,\n        ///once: options?.once, // lwf\n        once: options && options.once, \n      });\n    }\n\n    dispatch(eventName) {\n      const eventListeners = this._listeners[eventName];\n      if (!eventListeners || eventListeners.length === 0) {\n        if (\n          (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"MOZCENTRAL\")) &&\n          this._isInAutomation\n        ) {\n          const args = Array.prototype.slice.call(arguments, 1);\n          dispatchDOMEvent(eventName, args);\n        }\n        return;\n      }\n      // Passing all arguments after the eventName to the listeners.\n      const args = Array.prototype.slice.call(arguments, 1);\n      let externalListeners;\n      // Making copy of the listeners array in case if it will be modified\n      // during dispatch.\n      eventListeners.slice(0).forEach(({ listener, external, once }) => {\n        if (once) {\n          this._off(eventName, listener);\n        }\n        if (external) {\n          ///(externalListeners ||= []).push(listener); // lwf \n          (externalListeners || (externalListeners = [])).push(listener);\n          return;\n        }\n        listener.apply(null, args);\n      });\n      // Dispatch any \"external\" listeners *after* the internal ones, to give the\n      // viewer components time to handle events and update their state first.\n      if (externalListeners) {\n        externalListeners.forEach(listener => {\n          listener.apply(null, args);\n        });\n        externalListeners = null;\n      }\n      if (\n        (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"MOZCENTRAL\")) &&\n        this._isInAutomation\n      ) {\n        dispatchDOMEvent(eventName, args);\n      }\n    }\n\n    /**\n     * @ignore\n     */\n    _on(eventName, listener, options = null) {\n      ///const eventListeners = (this._listeners[eventName] ||= []); // lwf\n      const eventListeners = (this._listeners[eventName] || (this._listeners[eventName]= []));\n      eventListeners.push({\n        listener,\n        ///external: options?.external === true, // lwf\n        ///once: options?.once === true,         // lwf\n        external: options && options.external === true, \n        once: options && options.once === true,     \n      });\n    }\n\n    /**\n     * @ignore\n     */\n    _off(eventName, listener, options = null) {\n      const eventListeners = this._listeners[eventName];\n      if (!eventListeners) {\n        return;\n      }\n      for (let i = 0, ii = eventListeners.length; i < ii; i++) {\n        if (eventListeners[i].listener === listener) {\n          eventListeners.splice(i, 1);\n          return;\n        }\n      }\n    }\n  }\n\n  function clamp(v, min, max) {\n    return Math.min(Math.max(v, min), max);\n  }\n\n  class ProgressBar {\n    constructor(id, { height, width, units } = {}) {\n      this.visible = true;\n\n      // Fetch the sub-elements for later.\n      this.div = document.querySelector(id + \" .progress\");\n      // Get the loading bar element, so it can be resized to fit the viewer.\n      this.bar = this.div.parentNode;\n\n      // Get options, with sensible defaults.\n      this.height = height || 100;\n      this.width = width || 100;\n      this.units = units || \"%\";\n\n      // Initialize heights.\n      this.div.style.height = this.height + this.units;\n      this.percent = 0;\n    }\n\n    _updateBar() {\n      if (this._indeterminate) {\n        this.div.classList.add(\"indeterminate\");\n        this.div.style.width = this.width + this.units;\n        return;\n      }\n\n      this.div.classList.remove(\"indeterminate\");\n      const progressSize = (this.width * this._percent) / 100;\n      this.div.style.width = progressSize + this.units;\n    }\n\n    get percent() {\n      return this._percent;\n    }\n\n    set percent(val) {\n      this._indeterminate = isNaN(val);\n      this._percent = clamp(val, 0, 100);\n      this._updateBar();\n    }\n\n    setWidth(viewer) {\n      if (!viewer) {\n        return;\n      }\n      const container = viewer.parentNode;\n      const scrollbarWidth = container.offsetWidth - viewer.offsetWidth;\n      if (scrollbarWidth > 0) {\n        const doc = document.documentElement;\n        doc.style.setProperty(LOADINGBAR_END_OFFSET_VAR, `${scrollbarWidth}px`);\n      }\n    }\n\n    hide() {\n      if (!this.visible) {\n        return;\n      }\n      this.visible = false;\n      this.bar.classList.add(\"hidden\");\n    }\n\n    show() {\n      if (this.visible) {\n        return;\n      }\n      this.visible = true;\n      this.bar.classList.remove(\"hidden\");\n    }\n  }\n\n  /**\n   * Moves all elements of an array that satisfy condition to the end of the\n   * array, preserving the order of the rest.\n   */\n  function moveToEndOfArray(arr, condition) {\n    const moved = [],\n      len = arr.length;\n    let write = 0;\n    for (let read = 0; read < len; ++read) {\n      if (condition(arr[read])) {\n        moved.push(arr[read]);\n      } else {\n        arr[write] = arr[read];\n        ++write;\n      }\n    }\n    for (let read = 0; write < len; ++read, ++write) {\n      arr[write] = moved[read];\n    }\n  }\n\n  /**\n   * Get the active or focused element in current DOM.\n   *\n   * Recursively search for the truly active or focused element in case there are\n   * shadow DOMs.\n   *\n   * @returns {Element} the truly active or focused element.\n   */\n  function getActiveOrFocusedElement() {\n    let curRoot = document;\n    let curActiveOrFocused =\n      curRoot.activeElement || curRoot.querySelector(\":focus\");\n\n    while (curActiveOrFocused && curActiveOrFocused.shadowRoot) {\n      curRoot = curActiveOrFocused.shadowRoot;\n      curActiveOrFocused =\n        curRoot.activeElement || curRoot.querySelector(\":focus\");\n    }\n\n    return curActiveOrFocused;\n  }\n\n  return {\n    animationStarted,\n    approximateFraction,\n    AutoPrintRegExp,\n    backtrackBeforeAllVisibleElements, // only exported for testing\n    binarySearchFirstItem,\n    CSS_UNITS,\n    DEFAULT_SCALE,\n    DEFAULT_SCALE_VALUE,\n    EventBus,\n    getActiveOrFocusedElement,\n    getOutputScale,\n    getPageSizeInches,\n    getPDFFileNameFromURL,\n    getVisibleElements,\n    isPortraitOrientation,\n    isValidRotation,\n    isValidScrollMode,\n    isValidSpreadMode,\n    MAX_AUTO_SCALE,\n    MAX_SCALE,\n    MIN_SCALE,\n    moveToEndOfArray,\n    noContextMenuHandler,\n    normalizeWheelEventDelta,\n    normalizeWheelEventDirection,\n    NullL10n,\n    parseQueryString,\n    PresentationModeState,\n    ProgressBar,\n    RendererType,\n    roundToDivide,\n    SCROLLBAR_PADDING,\n    scrollIntoView,\n    ScrollMode,\n    SidebarView,\n    SpreadMode,\n    TextLayerMode,\n    UNKNOWN_SCALE,\n    VERTICAL_PADDING,\n    waitOnEventOrTimeout,\n    WaitOnType,\n    watchScroll,\n  };\n});"]}