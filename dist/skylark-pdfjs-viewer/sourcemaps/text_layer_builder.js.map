{"version":3,"sources":["text_layer_builder.js"],"names":["define","pdfjsLib","PDFJSDev","renderTextLayer","EXPAND_DIVS_TIMEOUT","TextLayerBuilder","[object Object]","textLayerDiv","eventBus","pageIndex","viewport","findController","enhanceTextSelection","this","textContent","textContentItemsStr","textContentStream","renderingDone","pageIdx","pageNumber","matches","textDivs","textLayerRenderTask","_onUpdateTextLayerMatches","_bindMouse","endOfContent","document","createElement","className","appendChild","dispatch","source","numTextDivs","length","timeout","cancel","textLayerFrag","createDocumentFragment","container","promise","then","_finishRendering","_updateMatches","reason","evt","_on","_off","readableStream","matchesLength","i","iIndex","end","result","m","mm","matchIdx","console","error","match","begin","divIdx","offset","push","isSelectedPage","selected","selectedMatchIdx","prevEnd","infinity","undefined","beginText","appendTextToDiv","fromOffset","toOffset","div","content","substring","node","createTextNode","span","i0","i1","state","highlightAll","isSelected","highlightSuffix","scrollMatchIntoView","element","matchIndex","n0","n1","clearedUntilDivIdx","ii","n","Math","max","highlightMatches","pageMatches","pageMatchesLength","_convertMatches","_renderMatches","expandDivsTimer","addEventListener","expandTextDivs","test","clearTimeout","querySelector","adjustTop","target","window","getComputedStyle","getPropertyValue","divBounds","getBoundingClientRect","r","pageY","top","height","style","toFixed","classList","add","setTimeout","remove","DefaultTextLayerFactory"],"mappings":";;;;;;;AAAAA,QACE,wBACA,eACA,SAASC,EAASC,GAgBlB,MAAMC,gBAAEA,GAAoBF,EAEtBG,EAAsB,UAmBtBC,EACJC,aAAYC,aACVA,EAAYC,SACZA,EAAQC,UACRA,EAASC,SACTA,EAAQC,eACRA,EAAiB,KAAIC,qBACrBA,GAAuB,IAEvBC,KAAKN,aAAeA,EACpBM,KAAKL,SAAWA,EAChBK,KAAKC,YAAc,KACnBD,KAAKE,uBACLF,KAAKG,kBAAoB,KACzBH,KAAKI,eAAgB,EACrBJ,KAAKK,QAAUT,EACfI,KAAKM,WAAaN,KAAKK,QAAU,EACjCL,KAAKO,WACLP,KAAKH,SAAWA,EAChBG,KAAKQ,YACLR,KAAKF,eAAiBA,EACtBE,KAAKS,oBAAsB,KAC3BT,KAAKD,qBAAuBA,EAE5BC,KAAKU,0BAA4B,KACjCV,KAAKW,aAMPlB,mBAGE,GAFAO,KAAKI,eAAgB,GAEhBJ,KAAKD,qBAAsB,CAC9B,MAAMa,EAAeC,SAASC,cAAc,OAC5CF,EAAaG,UAAY,eACzBf,KAAKN,aAAasB,YAAYJ,GAGhCZ,KAAKL,SAASsB,SAAS,qBACrBC,OAAQlB,KACRM,WAAYN,KAAKM,WACjBa,YAAanB,KAAKQ,SAASY,SAU/B3B,OAAO4B,EAAU,GACf,IAAMrB,KAAKC,cAAeD,KAAKG,mBAAsBH,KAAKI,cACxD,OAEFJ,KAAKsB,SAELtB,KAAKQ,YACL,MAAMe,EAAgBV,SAASW,yBAC/BxB,KAAKS,oBAAsBnB,GACzBW,YAAaD,KAAKC,YAClBE,kBAAmBH,KAAKG,kBACxBsB,UAAWF,EACX1B,SAAUG,KAAKH,SACfW,SAAUR,KAAKQ,SACfN,oBAAqBF,KAAKE,oBAC1BmB,QAAAA,EACAtB,qBAAsBC,KAAKD,uBAE7BC,KAAKS,oBAAoBiB,QAAQC,KAC/B,KACE3B,KAAKN,aAAasB,YAAYO,GAC9BvB,KAAK4B,mBACL5B,KAAK6B,kBAEP,SAAUC,MAKP9B,KAAKU,4BACRV,KAAKU,0BAA4BqB,CAAAA,IAC3BA,EAAInC,YAAcI,KAAKK,UAA8B,IAAnB0B,EAAInC,WACxCI,KAAK6B,mBAGT7B,KAAKL,SAASqC,IACZ,yBACAhC,KAAKU,4BAQXjB,SACMO,KAAKS,sBACPT,KAAKS,oBAAoBa,SACzBtB,KAAKS,oBAAsB,MAEzBT,KAAKU,4BACPV,KAAKL,SAASsC,KACZ,yBACAjC,KAAKU,2BAEPV,KAAKU,0BAA4B,MAIrCjB,qBAAqByC,GACnBlC,KAAKsB,SACLtB,KAAKG,kBAAoB+B,EAG3BzC,eAAeQ,GACbD,KAAKsB,SACLtB,KAAKC,YAAcA,EAGrBR,gBAAgBc,EAAS4B,GAEvB,IAAK5B,EACH,SAEF,MAAML,oBAAEA,GAAwBF,KAEhC,IAAIoC,EAAI,EACNC,EAAS,EACX,MAAMC,EAAMpC,EAAoBkB,OAAS,EACnCmB,KAEN,IAAK,IAAIC,EAAI,EAAGC,EAAKlC,EAAQa,OAAQoB,EAAIC,EAAID,IAAK,CAEhD,IAAIE,EAAWnC,EAAQiC,GAGvB,KAAOJ,IAAME,GAAOI,GAAYL,EAASnC,EAAoBkC,GAAGhB,QAC9DiB,GAAUnC,EAAoBkC,GAAGhB,OACjCgB,IAGEA,IAAMlC,EAAoBkB,QAC5BuB,QAAQC,MAAM,qCAGhB,MAAMC,GACJC,OACEC,OAAQX,EACRY,OAAQN,EAAWL,IASvB,IAJAK,GAAYP,EAAcK,GAInBJ,IAAME,GAAOI,EAAWL,EAASnC,EAAoBkC,GAAGhB,QAC7DiB,GAAUnC,EAAoBkC,GAAGhB,OACjCgB,IAGFS,EAAMP,KACJS,OAAQX,EACRY,OAAQN,EAAWL,GAErBE,EAAOU,KAAKJ,GAEd,OAAON,EAGT9C,eAAec,GAEb,GAAuB,IAAnBA,EAAQa,OACV,OAEF,MAAMtB,eAAEA,EAAcO,QAAEA,EAAOH,oBAAEA,EAAmBM,SAAEA,GAAaR,KAE7DkD,EAAiB7C,IAAYP,EAAeqD,SAAS9C,QACrD+C,EAAmBtD,EAAeqD,SAAST,SAEjD,IAAIW,EAAU,KACd,MAAMC,GACJP,QAAS,EACTC,YAAQO,GAGV,SAASC,EAAUV,EAAO/B,GACxB,MAAMgC,EAASD,EAAMC,OACrBvC,EAASuC,GAAQ9C,YAAc,GAC/BwD,EAAgBV,EAAQ,EAAGD,EAAME,OAAQjC,GAG3C,SAAS0C,EAAgBV,EAAQW,EAAYC,EAAU5C,GACrD,MAAM6C,EAAMpD,EAASuC,GACfc,EAAU3D,EAAoB6C,GAAQe,UAC1CJ,EACAC,GAEII,EAAOlD,SAASmD,eAAeH,GACrC,GAAI9C,EAAW,CACb,MAAMkD,EAAOpD,SAASC,cAAc,QAIpC,OAHAmD,EAAKlD,UAAYA,EACjBkD,EAAKjD,YAAY+C,QACjBH,EAAI5C,YAAYiD,GAGlBL,EAAI5C,YAAY+C,GAGlB,IAAIG,EAAKd,EACPe,EAAKD,EAAK,EACZ,GAhCqBpE,EAAesE,MAAMC,aAiCxCH,EAAK,EACLC,EAAK5D,EAAQa,YACR,IAAK8B,EAEV,OAGF,IAAK,IAAId,EAAI8B,EAAI9B,EAAI+B,EAAI/B,IAAK,CAC5B,MAAMS,EAAQtC,EAAQ6B,GAChBU,EAAQD,EAAMC,MACdR,EAAMO,EAAMP,IACZgC,EAAapB,GAAkBd,IAAMgB,EACrCmB,EAAkBD,EAAa,YAAc,GAuBnD,GArBIA,GAEFxE,EAAe0E,qBACbC,QAASjE,EAASsC,EAAMC,QACxBnD,UAAWS,EACXqE,WAAYtB,IAKXC,GAAWP,EAAMC,SAAWM,EAAQN,OAQvCU,EAAgBJ,EAAQN,OAAQM,EAAQL,OAAQF,EAAME,SANtC,OAAZK,GACFI,EAAgBJ,EAAQN,OAAQM,EAAQL,OAAQM,EAASN,QAG3DQ,EAAUV,IAKRA,EAAMC,SAAWT,EAAIS,OACvBU,EACEX,EAAMC,OACND,EAAME,OACNV,EAAIU,OACJ,YAAcuB,OAEX,CACLd,EACEX,EAAMC,OACND,EAAME,OACNM,EAASN,OACT,kBAAoBuB,GAEtB,IAAK,IAAII,EAAK7B,EAAMC,OAAS,EAAG6B,EAAKtC,EAAIS,OAAQ4B,EAAKC,EAAID,IACxDnE,EAASmE,GAAI5D,UAAY,mBAAqBwD,EAEhDf,EAAUlB,EAAK,gBAAkBiC,GAEnClB,EAAUf,EAGRe,GACFI,EAAgBJ,EAAQN,OAAQM,EAAQL,OAAQM,EAASN,QAI7DvD,iBAEE,IAAKO,KAAKI,cACR,OAEF,MAAMN,eACJA,EAAcS,QACdA,EAAOF,QACPA,EAAOH,oBACPA,EAAmBM,SACnBA,GACER,KACJ,IAAI6E,GAAsB,EAG1B,IAAK,IAAIzC,EAAI,EAAG0C,EAAKvE,EAAQa,OAAQgB,EAAI0C,EAAI1C,IAAK,CAChD,MAAMS,EAAQtC,EAAQ6B,GAEtB,IAAK,IAAI2C,EADKC,KAAKC,IAAIJ,EAAoBhC,EAAMC,MAAMC,QACnCT,EAAMO,EAAMP,IAAIS,OAAQgC,GAAKzC,EAAKyC,IAAK,CACzD,MAAMnB,EAAMpD,EAASuE,GACrBnB,EAAI3D,YAAcC,EAAoB6E,GACtCnB,EAAI7C,UAAY,GAElB8D,EAAqBhC,EAAMP,IAAIS,OAAS,EAG1C,IAAKjD,IAAmBA,EAAeoF,iBACrC,OAIF,MAAMC,EAAcrF,EAAeqF,YAAY9E,IAAY,KACrD+E,EAAoBtF,EAAesF,kBAAkB/E,IAAY,KAEvEL,KAAKO,QAAUP,KAAKqF,gBAAgBF,EAAaC,GACjDpF,KAAKsF,eAAetF,KAAKO,SAU3Bd,aACE,MAAMmE,EAAM5D,KAAKN,aACjB,IAAI6F,EAAkB,KAEtB3B,EAAI4B,iBAAiB,YAAazD,IAChC,GAAI/B,KAAKD,sBAAwBC,KAAKS,oBASpC,OARAT,KAAKS,oBAAoBgF,gBAAe,aAEjB,IAAbpG,GAA6BA,EAASqG,KAAK,gBACnDH,IAEAI,aAAaJ,GACbA,EAAkB,OAKtB,MAAMjD,EAAMsB,EAAIgC,cAAc,iBAC9B,GAAKtD,EAAL,CAGA,QAAwB,IAAbjD,IAA6BA,EAASqG,KAAK,cAAe,CAKnE,IAAIG,EAAY9D,EAAI+D,SAAWlC,EAQ/B,SAPwB,IAAbvE,GAA4BA,EAASqG,KAAK,cACnDG,EACEA,GAG4C,SAF5CE,OACGC,iBAAiB1D,GACjB2D,iBAAiB,qBAEpBJ,EAAW,CACb,MAAMK,EAAYtC,EAAIuC,wBAChBC,EAAIpB,KAAKC,IAAI,GAAIlD,EAAIsE,MAAQH,EAAUI,KAAOJ,EAAUK,QAC9DjE,EAAIkE,MAAMF,KAAW,IAAJF,GAASK,QAAQ,GAAK,KAG3CnE,EAAIoE,UAAUC,IAAI,aAGpB/C,EAAI4B,iBAAiB,UAAW,KAC9B,GAAIxF,KAAKD,sBAAwBC,KAAKS,oBAWpC,iBAVwB,IAAbpB,GAA6BA,EAASqG,KAAK,cAQpD1F,KAAKS,oBAAoBgF,gBAAe,GAPxCF,EAAkBqB,WAAW,KACvB5G,KAAKS,qBACPT,KAAKS,oBAAoBgF,gBAAe,GAE1CF,EAAkB,MACjBhG,IAOP,MAAM+C,EAAMsB,EAAIgC,cAAc,iBACzBtD,SAGmB,IAAbjD,GAA6BA,EAASqG,KAAK,gBACpDpD,EAAIkE,MAAMF,IAAM,IAElBhE,EAAIoE,UAAUG,OAAO,cAkC3B,OACEC,8BAlBArH,uBACEC,EACAE,EACAC,EACAE,GAAuB,EACvBJ,GAEA,OAAO,IAAIH,GACTE,aAAAA,EACAE,UAAAA,EACAC,SAAAA,EACAE,qBAAAA,EACAJ,SAAAA,MAOJH,iBAAAA","file":"../text_layer_builder.js","sourcesContent":["define([\n  \"skylark-pdfjs-display\",\n  \"./pdfjs_dev\"\n],function(pdfjsLib,PDFJSDev){\n  /* Copyright 2012 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { renderTextLayer } = pdfjsLib;\n\n  const EXPAND_DIVS_TIMEOUT = 300; // ms\n\n  /**\n   * @typedef {Object} TextLayerBuilderOptions\n   * @property {HTMLDivElement} textLayerDiv - The text layer container.\n   * @property {EventBus} eventBus - The application event bus.\n   * @property {number} pageIndex - The page index.\n   * @property {PageViewport} viewport - The viewport of the text layer.\n   * @property {PDFFindController} findController\n   * @property {boolean} enhanceTextSelection - Option to turn on improved\n   *   text selection.\n   */\n\n  /**\n   * The text layer builder provides text selection functionality for the PDF.\n   * It does this by creating overlay divs over the PDF's text. These divs\n   * contain text that matches the PDF text they are overlaying. This object\n   * also provides a way to highlight text that is being searched for.\n   */\n  class TextLayerBuilder {\n    constructor({\n      textLayerDiv,\n      eventBus,\n      pageIndex,\n      viewport,\n      findController = null,\n      enhanceTextSelection = false,\n    }) {\n      this.textLayerDiv = textLayerDiv;\n      this.eventBus = eventBus;\n      this.textContent = null;\n      this.textContentItemsStr = [];\n      this.textContentStream = null;\n      this.renderingDone = false;\n      this.pageIdx = pageIndex;\n      this.pageNumber = this.pageIdx + 1;\n      this.matches = [];\n      this.viewport = viewport;\n      this.textDivs = [];\n      this.findController = findController;\n      this.textLayerRenderTask = null;\n      this.enhanceTextSelection = enhanceTextSelection;\n\n      this._onUpdateTextLayerMatches = null;\n      this._bindMouse();\n    }\n\n    /**\n     * @private\n     */\n    _finishRendering() {\n      this.renderingDone = true;\n\n      if (!this.enhanceTextSelection) {\n        const endOfContent = document.createElement(\"div\");\n        endOfContent.className = \"endOfContent\";\n        this.textLayerDiv.appendChild(endOfContent);\n      }\n\n      this.eventBus.dispatch(\"textlayerrendered\", {\n        source: this,\n        pageNumber: this.pageNumber,\n        numTextDivs: this.textDivs.length,\n      });\n    }\n\n    /**\n     * Renders the text layer.\n     *\n     * @param {number} [timeout] - Wait for a specified amount of milliseconds\n     *                             before rendering.\n     */\n    render(timeout = 0) {\n      if (!(this.textContent || this.textContentStream) || this.renderingDone) {\n        return;\n      }\n      this.cancel();\n\n      this.textDivs = [];\n      const textLayerFrag = document.createDocumentFragment();\n      this.textLayerRenderTask = renderTextLayer({\n        textContent: this.textContent,\n        textContentStream: this.textContentStream,\n        container: textLayerFrag,\n        viewport: this.viewport,\n        textDivs: this.textDivs,\n        textContentItemsStr: this.textContentItemsStr,\n        timeout,\n        enhanceTextSelection: this.enhanceTextSelection,\n      });\n      this.textLayerRenderTask.promise.then(\n        () => {\n          this.textLayerDiv.appendChild(textLayerFrag);\n          this._finishRendering();\n          this._updateMatches();\n        },\n        function (reason) {\n          // Cancelled or failed to render text layer; skipping errors.\n        }\n      );\n\n      if (!this._onUpdateTextLayerMatches) {\n        this._onUpdateTextLayerMatches = evt => {\n          if (evt.pageIndex === this.pageIdx || evt.pageIndex === -1) {\n            this._updateMatches();\n          }\n        };\n        this.eventBus._on(\n          \"updatetextlayermatches\",\n          this._onUpdateTextLayerMatches\n        );\n      }\n    }\n\n    /**\n     * Cancel rendering of the text layer.\n     */\n    cancel() {\n      if (this.textLayerRenderTask) {\n        this.textLayerRenderTask.cancel();\n        this.textLayerRenderTask = null;\n      }\n      if (this._onUpdateTextLayerMatches) {\n        this.eventBus._off(\n          \"updatetextlayermatches\",\n          this._onUpdateTextLayerMatches\n        );\n        this._onUpdateTextLayerMatches = null;\n      }\n    }\n\n    setTextContentStream(readableStream) {\n      this.cancel();\n      this.textContentStream = readableStream;\n    }\n\n    setTextContent(textContent) {\n      this.cancel();\n      this.textContent = textContent;\n    }\n\n    _convertMatches(matches, matchesLength) {\n      // Early exit if there is nothing to convert.\n      if (!matches) {\n        return [];\n      }\n      const { textContentItemsStr } = this;\n\n      let i = 0,\n        iIndex = 0;\n      const end = textContentItemsStr.length - 1;\n      const result = [];\n\n      for (let m = 0, mm = matches.length; m < mm; m++) {\n        // Calculate the start position.\n        let matchIdx = matches[m];\n\n        // Loop over the divIdxs.\n        while (i !== end && matchIdx >= iIndex + textContentItemsStr[i].length) {\n          iIndex += textContentItemsStr[i].length;\n          i++;\n        }\n\n        if (i === textContentItemsStr.length) {\n          console.error(\"Could not find a matching mapping\");\n        }\n\n        const match = {\n          begin: {\n            divIdx: i,\n            offset: matchIdx - iIndex,\n          },\n        };\n\n        // Calculate the end position.\n        matchIdx += matchesLength[m];\n\n        // Somewhat the same array as above, but use > instead of >= to get\n        // the end position right.\n        while (i !== end && matchIdx > iIndex + textContentItemsStr[i].length) {\n          iIndex += textContentItemsStr[i].length;\n          i++;\n        }\n\n        match.end = {\n          divIdx: i,\n          offset: matchIdx - iIndex,\n        };\n        result.push(match);\n      }\n      return result;\n    }\n\n    _renderMatches(matches) {\n      // Early exit if there is nothing to render.\n      if (matches.length === 0) {\n        return;\n      }\n      const { findController, pageIdx, textContentItemsStr, textDivs } = this;\n\n      const isSelectedPage = pageIdx === findController.selected.pageIdx;\n      const selectedMatchIdx = findController.selected.matchIdx;\n      const highlightAll = findController.state.highlightAll;\n      let prevEnd = null;\n      const infinity = {\n        divIdx: -1,\n        offset: undefined,\n      };\n\n      function beginText(begin, className) {\n        const divIdx = begin.divIdx;\n        textDivs[divIdx].textContent = \"\";\n        appendTextToDiv(divIdx, 0, begin.offset, className);\n      }\n\n      function appendTextToDiv(divIdx, fromOffset, toOffset, className) {\n        const div = textDivs[divIdx];\n        const content = textContentItemsStr[divIdx].substring(\n          fromOffset,\n          toOffset\n        );\n        const node = document.createTextNode(content);\n        if (className) {\n          const span = document.createElement(\"span\");\n          span.className = className;\n          span.appendChild(node);\n          div.appendChild(span);\n          return;\n        }\n        div.appendChild(node);\n      }\n\n      let i0 = selectedMatchIdx,\n        i1 = i0 + 1;\n      if (highlightAll) {\n        i0 = 0;\n        i1 = matches.length;\n      } else if (!isSelectedPage) {\n        // Not highlighting all and this isn't the selected page, so do nothing.\n        return;\n      }\n\n      for (let i = i0; i < i1; i++) {\n        const match = matches[i];\n        const begin = match.begin;\n        const end = match.end;\n        const isSelected = isSelectedPage && i === selectedMatchIdx;\n        const highlightSuffix = isSelected ? \" selected\" : \"\";\n\n        if (isSelected) {\n          // Attempt to scroll the selected match into view.\n          findController.scrollMatchIntoView({\n            element: textDivs[begin.divIdx],\n            pageIndex: pageIdx,\n            matchIndex: selectedMatchIdx,\n          });\n        }\n\n        // Match inside new div.\n        if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {\n          // If there was a previous div, then add the text at the end.\n          if (prevEnd !== null) {\n            appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);\n          }\n          // Clear the divs and set the content until the starting point.\n          beginText(begin);\n        } else {\n          appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);\n        }\n\n        if (begin.divIdx === end.divIdx) {\n          appendTextToDiv(\n            begin.divIdx,\n            begin.offset,\n            end.offset,\n            \"highlight\" + highlightSuffix\n          );\n        } else {\n          appendTextToDiv(\n            begin.divIdx,\n            begin.offset,\n            infinity.offset,\n            \"highlight begin\" + highlightSuffix\n          );\n          for (let n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {\n            textDivs[n0].className = \"highlight middle\" + highlightSuffix;\n          }\n          beginText(end, \"highlight end\" + highlightSuffix);\n        }\n        prevEnd = end;\n      }\n\n      if (prevEnd) {\n        appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);\n      }\n    }\n\n    _updateMatches() {\n      // Only show matches when all rendering is done.\n      if (!this.renderingDone) {\n        return;\n      }\n      const {\n        findController,\n        matches,\n        pageIdx,\n        textContentItemsStr,\n        textDivs,\n      } = this;\n      let clearedUntilDivIdx = -1;\n\n      // Clear all current matches.\n      for (let i = 0, ii = matches.length; i < ii; i++) {\n        const match = matches[i];\n        const begin = Math.max(clearedUntilDivIdx, match.begin.divIdx);\n        for (let n = begin, end = match.end.divIdx; n <= end; n++) {\n          const div = textDivs[n];\n          div.textContent = textContentItemsStr[n];\n          div.className = \"\";\n        }\n        clearedUntilDivIdx = match.end.divIdx + 1;\n      }\n\n      if (!findController || !findController.highlightMatches) {\n        return;\n      }\n      // Convert the matches on the `findController` into the match format\n      // used for the textLayer.\n      const pageMatches = findController.pageMatches[pageIdx] || null;\n      const pageMatchesLength = findController.pageMatchesLength[pageIdx] || null;\n\n      this.matches = this._convertMatches(pageMatches, pageMatchesLength);\n      this._renderMatches(this.matches);\n    }\n\n    /**\n     * Improves text selection by adding an additional div where the mouse was\n     * clicked. This reduces flickering of the content if the mouse is slowly\n     * dragged up or down.\n     *\n     * @private\n     */\n    _bindMouse() {\n      const div = this.textLayerDiv;\n      let expandDivsTimer = null;\n\n      div.addEventListener(\"mousedown\", evt => {\n        if (this.enhanceTextSelection && this.textLayerRenderTask) {\n          this.textLayerRenderTask.expandTextDivs(true);\n          if (\n            (typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"MOZCENTRAL\")) &&\n            expandDivsTimer\n          ) {\n            clearTimeout(expandDivsTimer);\n            expandDivsTimer = null;\n          }\n          return;\n        }\n\n        const end = div.querySelector(\".endOfContent\");\n        if (!end) {\n          return;\n        }\n        if (typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"MOZCENTRAL\")) {\n          // On non-Firefox browsers, the selection will feel better if the height\n          // of the `endOfContent` div is adjusted to start at mouse click\n          // location. This avoids flickering when the selection moves up.\n          // However it does not work when selection is started on empty space.\n          let adjustTop = evt.target !== div;\n          if (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) {\n            adjustTop =\n              adjustTop &&\n              window\n                .getComputedStyle(end)\n                .getPropertyValue(\"-moz-user-select\") !== \"none\";\n          }\n          if (adjustTop) {\n            const divBounds = div.getBoundingClientRect();\n            const r = Math.max(0, (evt.pageY - divBounds.top) / divBounds.height);\n            end.style.top = (r * 100).toFixed(2) + \"%\";\n          }\n        }\n        end.classList.add(\"active\");\n      });\n\n      div.addEventListener(\"mouseup\", () => {\n        if (this.enhanceTextSelection && this.textLayerRenderTask) {\n          if (typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"MOZCENTRAL\")) {\n            expandDivsTimer = setTimeout(() => {\n              if (this.textLayerRenderTask) {\n                this.textLayerRenderTask.expandTextDivs(false);\n              }\n              expandDivsTimer = null;\n            }, EXPAND_DIVS_TIMEOUT);\n          } else {\n            this.textLayerRenderTask.expandTextDivs(false);\n          }\n          return;\n        }\n\n        const end = div.querySelector(\".endOfContent\");\n        if (!end) {\n          return;\n        }\n        if (typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"MOZCENTRAL\")) {\n          end.style.top = \"\";\n        }\n        end.classList.remove(\"active\");\n      });\n    }\n  }\n\n  /**\n   * @implements IPDFTextLayerFactory\n   */\n  class DefaultTextLayerFactory {\n    /**\n     * @param {HTMLDivElement} textLayerDiv\n     * @param {number} pageIndex\n     * @param {PageViewport} viewport\n     * @param {boolean} enhanceTextSelection\n     * @param {EventBus} eventBus\n     * @returns {TextLayerBuilder}\n     */\n    createTextLayerBuilder(\n      textLayerDiv,\n      pageIndex,\n      viewport,\n      enhanceTextSelection = false,\n      eventBus\n    ) {\n      return new TextLayerBuilder({\n        textLayerDiv,\n        pageIndex,\n        viewport,\n        enhanceTextSelection,\n        eventBus,\n      });\n    }\n  }\n\n  return { \n    DefaultTextLayerFactory, \n    TextLayerBuilder \n  };\n});"]}