{"version":3,"sources":["pdf_rendering_queue.js"],"names":["define","pdfjsLib","RenderingCancelledException","CLEANUP_TIMEOUT","RenderingStates","INITIAL","RUNNING","PAUSED","FINISHED","PDFRenderingQueue","[object Object]","this","pdfViewer","pdfThumbnailViewer","onIdle","highestPriorityPage","idleTimeout","printing","isThumbnailViewEnabled","view","renderingId","currentlyVisiblePages","clearTimeout","forceRendering","setTimeout","bind","visible","views","scrolledDown","visibleViews","numVisible","length","i","isViewFinished","nextPageIndex","last","id","previousPageIndex","first","renderingState","resume","draw","finally","renderHighestPriority","catch","reason","console","error"],"mappings":";;;;;;;AAAAA,QACE,yBACA,SAASC,GAgBT,MAAMC,4BAAEA,GAAgCD,EAElCE,EAAkB,IAElBC,GACJC,QAAS,EACTC,QAAS,EACTC,OAAQ,EACRC,SAAU,GAkKZ,OACEC,wBA5JAC,cACEC,KAAKC,UAAY,KACjBD,KAAKE,mBAAqB,KAC1BF,KAAKG,OAAS,KACdH,KAAKI,oBAAsB,KAC3BJ,KAAKK,YAAc,KACnBL,KAAKM,UAAW,EAChBN,KAAKO,wBAAyB,EAMhCR,UAAUE,GACRD,KAAKC,UAAYA,EAMnBF,mBAAmBG,GACjBF,KAAKE,mBAAqBA,EAO5BH,kBAAkBS,GAChB,OAAOR,KAAKI,sBAAwBI,EAAKC,YAM3CV,sBAAsBW,GAChBV,KAAKK,cACPM,aAAaX,KAAKK,aAClBL,KAAKK,YAAc,MAIjBL,KAAKC,UAAUW,eAAeF,IAI9BV,KAAKE,oBAAsBF,KAAKO,wBAC9BP,KAAKE,mBAAmBU,kBAK1BZ,KAAKM,UAKLN,KAAKG,SACPH,KAAKK,YAAcQ,WAAWb,KAAKG,OAAOW,KAAKd,MAAOR,IAS1DO,mBAAmBgB,EAASC,EAAOC,GAUjC,MAAMC,EAAeH,EAAQC,MAEvBG,EAAaD,EAAaE,OAChC,GAAmB,IAAfD,EACF,OAAO,KAET,IAAK,IAAIE,EAAI,EAAGA,EAAIF,IAAcE,EAAG,CACnC,MAAMb,EAAOU,EAAaG,GAAGb,KAC7B,IAAKR,KAAKsB,eAAed,GACvB,OAAOA,EAKX,GAAIS,EAAc,CAChB,MAAMM,EAAgBR,EAAQS,KAAKC,GAEnC,GAAIT,EAAMO,KAAmBvB,KAAKsB,eAAeN,EAAMO,IACrD,OAAOP,EAAMO,OAEV,CACL,MAAMG,EAAoBX,EAAQY,MAAMF,GAAK,EAC7C,GACET,EAAMU,KACL1B,KAAKsB,eAAeN,EAAMU,IAE3B,OAAOV,EAAMU,GAIjB,OAAO,KAOT3B,eAAeS,GACb,OAAOA,EAAKoB,iBAAmBnC,EAAgBI,SAUjDE,WAAWS,GACT,OAAQA,EAAKoB,gBACX,KAAKnC,EAAgBI,SACnB,OAAO,EACT,KAAKJ,EAAgBG,OACnBI,KAAKI,oBAAsBI,EAAKC,YAChCD,EAAKqB,SACL,MACF,KAAKpC,EAAgBE,QACnBK,KAAKI,oBAAsBI,EAAKC,YAChC,MACF,KAAKhB,EAAgBC,QACnBM,KAAKI,oBAAsBI,EAAKC,YAChCD,EACGsB,OACAC,QAAQ,KACP/B,KAAKgC,0BAENC,MAAMC,IACDA,aAAkB3C,GAGtB4C,QAAQC,sBAAsBF,QAItC,OAAO,IAMTzC,gBAAAA","file":"../pdf_rendering_queue.js","sourcesContent":["define([\n  \"skylark-pdfjs-display\"\n],function(pdfjsLib){\n  /* Copyright 2012 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { RenderingCancelledException } = pdfjsLib;\n\n  const CLEANUP_TIMEOUT = 30000;\n\n  const RenderingStates = {\n    INITIAL: 0,\n    RUNNING: 1,\n    PAUSED: 2,\n    FINISHED: 3,\n  };\n\n  /**\n   * Controls rendering of the views for pages and thumbnails.\n   */\n  class PDFRenderingQueue {\n    constructor() {\n      this.pdfViewer = null;\n      this.pdfThumbnailViewer = null;\n      this.onIdle = null;\n      this.highestPriorityPage = null;\n      this.idleTimeout = null;\n      this.printing = false;\n      this.isThumbnailViewEnabled = false;\n    }\n\n    /**\n     * @param {PDFViewer} pdfViewer\n     */\n    setViewer(pdfViewer) {\n      this.pdfViewer = pdfViewer;\n    }\n\n    /**\n     * @param {PDFThumbnailViewer} pdfThumbnailViewer\n     */\n    setThumbnailViewer(pdfThumbnailViewer) {\n      this.pdfThumbnailViewer = pdfThumbnailViewer;\n    }\n\n    /**\n     * @param {IRenderableView} view\n     * @returns {boolean}\n     */\n    isHighestPriority(view) {\n      return this.highestPriorityPage === view.renderingId;\n    }\n\n    /**\n     * @param {Object} currentlyVisiblePages\n     */\n    renderHighestPriority(currentlyVisiblePages) {\n      if (this.idleTimeout) {\n        clearTimeout(this.idleTimeout);\n        this.idleTimeout = null;\n      }\n\n      // Pages have a higher priority than thumbnails, so check them first.\n      if (this.pdfViewer.forceRendering(currentlyVisiblePages)) {\n        return;\n      }\n      // No pages needed rendering, so check thumbnails.\n      if (this.pdfThumbnailViewer && this.isThumbnailViewEnabled) {\n        if (this.pdfThumbnailViewer.forceRendering()) {\n          return;\n        }\n      }\n\n      if (this.printing) {\n        // If printing is currently ongoing do not reschedule cleanup.\n        return;\n      }\n\n      if (this.onIdle) {\n        this.idleTimeout = setTimeout(this.onIdle.bind(this), CLEANUP_TIMEOUT);\n      }\n    }\n\n    /**\n     * @param {Object} visible\n     * @param {Array} views\n     * @param {boolean} scrolledDown\n     */\n    getHighestPriority(visible, views, scrolledDown) {\n      /**\n       * The state has changed. Figure out which page has the highest priority to\n       * render next (if any).\n       *\n       * Priority:\n       * 1. visible pages\n       * 2. if last scrolled down, the page after the visible pages, or\n       *    if last scrolled up, the page before the visible pages\n       */\n      const visibleViews = visible.views;\n\n      const numVisible = visibleViews.length;\n      if (numVisible === 0) {\n        return null;\n      }\n      for (let i = 0; i < numVisible; ++i) {\n        const view = visibleViews[i].view;\n        if (!this.isViewFinished(view)) {\n          return view;\n        }\n      }\n\n      // All the visible views have rendered; try to render next/previous pages.\n      if (scrolledDown) {\n        const nextPageIndex = visible.last.id;\n        // IDs start at 1, so no need to add 1.\n        if (views[nextPageIndex] && !this.isViewFinished(views[nextPageIndex])) {\n          return views[nextPageIndex];\n        }\n      } else {\n        const previousPageIndex = visible.first.id - 2;\n        if (\n          views[previousPageIndex] &&\n          !this.isViewFinished(views[previousPageIndex])\n        ) {\n          return views[previousPageIndex];\n        }\n      }\n      // Everything that needs to be rendered has been.\n      return null;\n    }\n\n    /**\n     * @param {IRenderableView} view\n     * @returns {boolean}\n     */\n    isViewFinished(view) {\n      return view.renderingState === RenderingStates.FINISHED;\n    }\n\n    /**\n     * Render a page or thumbnail view. This calls the appropriate function\n     * based on the views state. If the view is already rendered it will return\n     * `false`.\n     *\n     * @param {IRenderableView} view\n     */\n    renderView(view) {\n      switch (view.renderingState) {\n        case RenderingStates.FINISHED:\n          return false;\n        case RenderingStates.PAUSED:\n          this.highestPriorityPage = view.renderingId;\n          view.resume();\n          break;\n        case RenderingStates.RUNNING:\n          this.highestPriorityPage = view.renderingId;\n          break;\n        case RenderingStates.INITIAL:\n          this.highestPriorityPage = view.renderingId;\n          view\n            .draw()\n            .finally(() => {\n              this.renderHighestPriority();\n            })\n            .catch(reason => {\n              if (reason instanceof RenderingCancelledException) {\n                return;\n              }\n              console.error(`renderView: \"${reason}\"`);\n            });\n          break;\n      }\n      return true;\n    }\n  }\n\n  return { \n    PDFRenderingQueue, \n    RenderingStates \n  };\n});"]}