{"version":3,"sources":["pdf_outline_viewer.js"],"names":["define","pdfjsLib","ui_utils","base_tree_viewer","addLinkAttributes","createPromiseCapability","LinkTarget","BaseTreeViewer","SidebarView","PDFOutlineViewer","[object Object]","options","super","this","linkService","eventBus","_on","_toggleAllTreeItems","bind","_currentOutlineItem","evt","_currentPageNumber","pageNumber","_isPagesLoaded","pagesCount","_sidebarView","view","reset","_outline","_pageNumberToDestHashCapability","outlineCount","dispatch","source","enableCurrentOutlineItemButton","_pdfDocument","loadingParams","disableAutoFetch","element","url","newWindow","dest","target","BLANK","externalLinkTarget","rel","externalLinkRel","enabled","externalLinkEnabled","href","getDestinationHash","onclick","_updateCurrentTreeItem","parentNode","goToDestination","bold","italic","style","fontWeight","fontStyle","div","count","items","hidden","totalCount","length","queue","nestedCount","nestedItems","shift","push","Math","abs","_addToggleButton","outline","pdfDocument","_dispatchEvent","fragment","document","createDocumentFragment","parent","hasAnyNesting","levelData","item","createElement","className","_bindLink","_setStyles","textContent","_normalizeTextContent","title","appendChild","itemsDiv","_finishRendering","Error","pageNumberToDestHash","_getPageNumberToDestHash","OUTLINE","i","destHash","get","linkElement","container","querySelector","_scrollToCurrentTreeItem","promise","Map","pageNumberNesting","nesting","currentNesting","explicitDest","getDestination","Array","isArray","destRef","_cachedPageNumber","getPageIndex","cachePageRef","ex","Number","isInteger","has","set","resolve","size"],"mappings":"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","file":"../pdf_outline_viewer.js","sourcesContent":["define([\n  \"skylark-pdfjs-display\",\n  \"./ui_utils\",\n  \"./base_tree_viewer\"\n],function(pdfjsLib,ui_utils,base_tree_viewer){\n  /* Copyright 2012 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const {\n    addLinkAttributes,\n    createPromiseCapability,\n    LinkTarget,\n  } = pdfjsLib;\n\n  const { BaseTreeViewer } = base_tree_viewer;\n  const { SidebarView } = ui_utils;\n\n  /**\n   * @typedef {Object} PDFOutlineViewerOptions\n   * @property {HTMLDivElement} container - The viewer element.\n   * @property {IPDFLinkService} linkService - The navigation/linking service.\n   * @property {EventBus} eventBus - The application event bus.\n   */\n\n  /**\n   * @typedef {Object} PDFOutlineViewerRenderParameters\n   * @property {Array|null} outline - An array of outline objects.\n   * @property {PDFDocument} pdfDocument - A {PDFDocument} instance.\n   */\n\n  class PDFOutlineViewer extends BaseTreeViewer {\n    /**\n     * @param {PDFOutlineViewerOptions} options\n     */\n    constructor(options) {\n      super(options);\n      this.linkService = options.linkService;\n\n      this.eventBus._on(\"toggleoutlinetree\", this._toggleAllTreeItems.bind(this));\n      this.eventBus._on(\n        \"currentoutlineitem\",\n        this._currentOutlineItem.bind(this)\n      );\n\n      this.eventBus._on(\"pagechanging\", evt => {\n        this._currentPageNumber = evt.pageNumber;\n      });\n      this.eventBus._on(\"pagesloaded\", evt => {\n        this._isPagesLoaded = !!evt.pagesCount;\n      });\n      this.eventBus._on(\"sidebarviewchanged\", evt => {\n        this._sidebarView = evt.view;\n      });\n    }\n\n    reset() {\n      super.reset();\n      this._outline = null;\n\n      this._pageNumberToDestHashCapability = null;\n      this._currentPageNumber = 1;\n      this._isPagesLoaded = false;\n    }\n\n    /**\n     * @private\n     */\n    _dispatchEvent(outlineCount) {\n      this.eventBus.dispatch(\"outlineloaded\", {\n        source: this,\n        outlineCount,\n        enableCurrentOutlineItemButton:\n          ///outlineCount > 0 && !this._pdfDocument?.loadingParams.disableAutoFetch, // lwf\n          outlineCount > 0 && !(this._pdfDocument && this._pdfDocument.loadingParams.disableAutoFetch),\n      });\n    }\n\n    /**\n     * @private\n     */\n    _bindLink(element, { url, newWindow, dest }) {\n      const { linkService } = this;\n\n      if (url) {\n        addLinkAttributes(element, {\n          url,\n          target: newWindow ? LinkTarget.BLANK : linkService.externalLinkTarget,\n          rel: linkService.externalLinkRel,\n          enabled: linkService.externalLinkEnabled,\n        });\n        return;\n      }\n\n      element.href = linkService.getDestinationHash(dest);\n      element.onclick = evt => {\n        this._updateCurrentTreeItem(evt.target.parentNode);\n\n        if (dest) {\n          linkService.goToDestination(dest);\n        }\n        return false;\n      };\n    }\n\n    /**\n     * @private\n     */\n    _setStyles(element, { bold, italic }) {\n      if (bold) {\n        element.style.fontWeight = \"bold\";\n      }\n      if (italic) {\n        element.style.fontStyle = \"italic\";\n      }\n    }\n\n    /**\n     * @private\n     */\n    _addToggleButton(div, { count, items }) {\n      let hidden = false;\n      if (count < 0) {\n        let totalCount = items.length;\n        if (totalCount > 0) {\n          const queue = [...items];\n          while (queue.length > 0) {\n            const { count: nestedCount, items: nestedItems } = queue.shift();\n            if (nestedCount > 0 && nestedItems.length > 0) {\n              totalCount += nestedItems.length;\n              queue.push(...nestedItems);\n            }\n          }\n        }\n        if (Math.abs(count) === totalCount) {\n          hidden = true;\n        }\n      }\n      super._addToggleButton(div, hidden);\n    }\n\n    /**\n     * @private\n     */\n    _toggleAllTreeItems() {\n      if (!this._outline) {\n        return;\n      }\n      super._toggleAllTreeItems();\n    }\n\n    /**\n     * @param {PDFOutlineViewerRenderParameters} params\n     */\n    render({ outline, pdfDocument }) {\n      if (this._outline) {\n        this.reset();\n      }\n      this._outline = outline || null;\n      this._pdfDocument = pdfDocument || null;\n\n      if (!outline) {\n        this._dispatchEvent(/* outlineCount = */ 0);\n        return;\n      }\n\n      const fragment = document.createDocumentFragment();\n      const queue = [{ parent: fragment, items: outline }];\n      let outlineCount = 0,\n        hasAnyNesting = false;\n      while (queue.length > 0) {\n        const levelData = queue.shift();\n        for (const item of levelData.items) {\n          const div = document.createElement(\"div\");\n          div.className = \"treeItem\";\n\n          const element = document.createElement(\"a\");\n          this._bindLink(element, item);\n          this._setStyles(element, item);\n          element.textContent = this._normalizeTextContent(item.title);\n\n          div.appendChild(element);\n\n          if (item.items.length > 0) {\n            hasAnyNesting = true;\n            this._addToggleButton(div, item);\n\n            const itemsDiv = document.createElement(\"div\");\n            itemsDiv.className = \"treeItems\";\n            div.appendChild(itemsDiv);\n\n            queue.push({ parent: itemsDiv, items: item.items });\n          }\n\n          levelData.parent.appendChild(div);\n          outlineCount++;\n        }\n      }\n\n      this._finishRendering(fragment, outlineCount, hasAnyNesting);\n    }\n\n    /**\n     * Find/highlight the current outline item, corresponding to the active page.\n     * @private\n     */\n    async _currentOutlineItem() {\n      if (!this._isPagesLoaded) {\n        throw new Error(\"_currentOutlineItem: All pages have not been loaded.\");\n      }\n      if (!this._outline || !this._pdfDocument) {\n        return;\n      }\n\n      const pageNumberToDestHash = await this._getPageNumberToDestHash(\n        this._pdfDocument\n      );\n      if (!pageNumberToDestHash) {\n        return;\n      }\n      this._updateCurrentTreeItem(/* treeItem = */ null);\n\n      if (this._sidebarView !== SidebarView.OUTLINE) {\n        return; // The outline view is no longer visible, hence do nothing.\n      }\n      // When there is no destination on the current page, always check the\n      // previous ones in (reverse) order.\n      for (let i = this._currentPageNumber; i > 0; i--) {\n        const destHash = pageNumberToDestHash.get(i);\n        if (!destHash) {\n          continue;\n        }\n        const linkElement = this.container.querySelector(`a[href=\"${destHash}\"]`);\n        if (!linkElement) {\n          continue;\n        }\n        this._scrollToCurrentTreeItem(linkElement.parentNode);\n        break;\n      }\n    }\n\n    /**\n     * To (significantly) simplify the overall implementation, we will only\n     * consider *one* destination per page when finding/highlighting the current\n     * outline item (similar to e.g. Adobe Reader); more specifically, we choose\n     * the *first* outline item at the *lowest* level of the outline tree.\n     * @private\n     */\n    async _getPageNumberToDestHash(pdfDocument) {\n      if (this._pageNumberToDestHashCapability) {\n        return this._pageNumberToDestHashCapability.promise;\n      }\n      this._pageNumberToDestHashCapability = createPromiseCapability();\n\n      const pageNumberToDestHash = new Map(),\n        pageNumberNesting = new Map();\n      const queue = [{ nesting: 0, items: this._outline }];\n      while (queue.length > 0) {\n        const levelData = queue.shift(),\n          currentNesting = levelData.nesting;\n        for (const { dest, items } of levelData.items) {\n          let explicitDest, pageNumber;\n          if (typeof dest === \"string\") {\n            explicitDest = await pdfDocument.getDestination(dest);\n\n            if (pdfDocument !== this._pdfDocument) {\n              return null; // The document was closed while the data resolved.\n            }\n          } else {\n            explicitDest = dest;\n          }\n          if (Array.isArray(explicitDest)) {\n            const [destRef] = explicitDest;\n\n            if (typeof destRef === \"object\") {\n              pageNumber = this.linkService._cachedPageNumber(destRef);\n\n              if (!pageNumber) {\n                try {\n                  pageNumber = (await pdfDocument.getPageIndex(destRef)) + 1;\n\n                  if (pdfDocument !== this._pdfDocument) {\n                    return null; // The document was closed while the data resolved.\n                  }\n                  this.linkService.cachePageRef(pageNumber, destRef);\n                } catch (ex) {\n                  // Invalid page reference, ignore it and continue parsing.\n                }\n              }\n            } else if (Number.isInteger(destRef)) {\n              pageNumber = destRef + 1;\n            }\n\n            if (\n              Number.isInteger(pageNumber) &&\n              (!pageNumberToDestHash.has(pageNumber) ||\n                currentNesting > pageNumberNesting.get(pageNumber))\n            ) {\n              const destHash = this.linkService.getDestinationHash(dest);\n              pageNumberToDestHash.set(pageNumber, destHash);\n              pageNumberNesting.set(pageNumber, currentNesting);\n            }\n          }\n\n          if (items.length > 0) {\n            queue.push({ nesting: currentNesting + 1, items });\n          }\n        }\n      }\n\n      this._pageNumberToDestHashCapability.resolve(\n        pageNumberToDestHash.size > 0 ? pageNumberToDestHash : null\n      );\n      return this._pageNumberToDestHashCapability.promise;\n    }\n  }\n\n  return { PDFOutlineViewer };\n});"]}