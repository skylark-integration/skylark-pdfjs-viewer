{"version":3,"sources":["pdf_find_controller.js"],"names":["define","pdfjsLib","ui_utils","pdf_find_utils","createPromiseCapability","getCharacterType","scrollIntoView","FindState","FOUND","NOT_FOUND","WRAPPED","PENDING","FIND_TIMEOUT","MATCH_SCROLL_OFFSET_TOP","MATCH_SCROLL_OFFSET_LEFT","CHARACTERS_TO_NORMALIZE","‘","’","‚","‛","“","”","„","‟","¼","½","¾","normalizationRegex","normalize","text","replace","Object","keys","join","RegExp","diffs","ch","index","normalizedCh","diff","length","push","getOriginalIndex","matchIndex","totalDiff","currentIndex","PDFFindController","[object Object]","linkService","eventBus","this","_linkService","_eventBus","_reset","_on","_onFindBarClose","bind","highlightMatches","_highlightMatches","pageMatches","_pageMatches","pageMatchesLength","_pageMatchesLength","selected","_selected","state","_state","pdfDocument","_pdfDocument","_firstPageCapability","resolve","cmd","_shouldDirtyMatch","_dirtyMatch","_updateUIState","promise","then","_extractText","findbarClosed","pendingTimeout","_findTimeout","clearTimeout","setTimeout","_nextMatch","highlightAll","_updateAllPages","element","pageIndex","_scrollMatches","matchIdx","pageIdx","top","left","_offset","wrapped","_extractTextPromises","_pageContents","_pageDiffs","_matchesCountTotal","_pagesToSearch","_pendingFindMatches","create","_resumePageIdx","_query","query","_rawQuery","_normalizedQuery","pageNumber","pagesCount","page","isPageVisible","matchesWithLength","matches","matchesLength","isSubTerm","currentElem","nextElem","match","skipped","i","prevElem","matchLength","sort","a","b","len","content","startIdx","first","charCodeAt","limit","endIdx","last","pageContent","pageDiffs","entireWord","queryLen","indexOf","_isEntireWord","originalMatchIdx","originalQueryLen","queryArray","subquery","subqueryLen","_prepareMatches","caseSensitive","phraseSearch","toLowerCase","_calculatePhraseMatch","_calculateWordMatch","_updatePage","_nextPageMatch","pageMatchesCount","_updateUIResultsCount","Promise","ii","extractTextCapability","getPage","pdfPage","getTextContent","normalizeWhitespace","textContent","textItems","items","strBuf","j","jj","str","reason","console","error","dispatch","source","previous","findPrevious","currentPageIndex","numPages","_calculateMatch","offset","numPageMatches","_updateMatch","_advanceOffsetPage","numMatches","_matchesReady","found","previousPage","evt","current","total","matchesCount","_requestMatchesCount","rawQuery"],"mappings":"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","file":"../pdf_find_controller.js","sourcesContent":["define([\n  \"skylark-pdfjs-display\",\n  \"./ui_utils\",\n  \"./pdf_find_utils\"\n],function(pdfjsLib,ui_utils,pdf_find_utils){\n  /* Copyright 2012 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { createPromiseCapability } = pdfjsLib;\n  const { getCharacterType } = pdf_find_utils;\n  const { scrollIntoView } = ui_utils;\n\n  const FindState = {\n    FOUND: 0,\n    NOT_FOUND: 1,\n    WRAPPED: 2,\n    PENDING: 3,\n  };\n\n  const FIND_TIMEOUT = 250; // ms\n  const MATCH_SCROLL_OFFSET_TOP = -50; // px\n  const MATCH_SCROLL_OFFSET_LEFT = -400; // px\n\n  const CHARACTERS_TO_NORMALIZE = {\n    \"\\u2018\": \"'\", // Left single quotation mark\n    \"\\u2019\": \"'\", // Right single quotation mark\n    \"\\u201A\": \"'\", // Single low-9 quotation mark\n    \"\\u201B\": \"'\", // Single high-reversed-9 quotation mark\n    \"\\u201C\": '\"', // Left double quotation mark\n    \"\\u201D\": '\"', // Right double quotation mark\n    \"\\u201E\": '\"', // Double low-9 quotation mark\n    \"\\u201F\": '\"', // Double high-reversed-9 quotation mark\n    \"\\u00BC\": \"1/4\", // Vulgar fraction one quarter\n    \"\\u00BD\": \"1/2\", // Vulgar fraction one half\n    \"\\u00BE\": \"3/4\", // Vulgar fraction three quarters\n  };\n\n  let normalizationRegex = null;\n  function normalize(text) {\n    if (!normalizationRegex) {\n      // Compile the regular expression for text normalization once.\n      const replace = Object.keys(CHARACTERS_TO_NORMALIZE).join(\"\");\n      normalizationRegex = new RegExp(`[${replace}]`, \"g\");\n    }\n    let diffs = null;\n    const normalizedText = text.replace(normalizationRegex, function (ch, index) {\n      const normalizedCh = CHARACTERS_TO_NORMALIZE[ch],\n        diff = normalizedCh.length - ch.length;\n      if (diff !== 0) {\n        ///(diffs ||= []).push([index, diff]); // lwf\n        (diffs || (diffs = [])).push([index, diff]);\n      }\n      return normalizedCh;\n    });\n\n    return [normalizedText, diffs];\n  }\n\n  // Determine the original, non-normalized, match index such that highlighting of\n  // search results is correct in the `textLayer` for strings containing e.g. \"½\"\n  // characters; essentially \"inverting\" the result of the `normalize` function.\n  function getOriginalIndex(matchIndex, diffs = null) {\n    if (!diffs) {\n      return matchIndex;\n    }\n    let totalDiff = 0;\n    for (const [index, diff] of diffs) {\n      const currentIndex = index + totalDiff;\n\n      if (currentIndex >= matchIndex) {\n        break;\n      }\n      if (currentIndex + diff > matchIndex) {\n        totalDiff += matchIndex - currentIndex;\n        break;\n      }\n      totalDiff += diff;\n    }\n    return matchIndex - totalDiff;\n  }\n\n  /**\n   * @typedef {Object} PDFFindControllerOptions\n   * @property {IPDFLinkService} linkService - The navigation/linking service.\n   * @property {EventBus} eventBus - The application event bus.\n   */\n\n  /**\n   * Provides search functionality to find a given string in a PDF document.\n   */\n  class PDFFindController {\n    /**\n     * @param {PDFFindControllerOptions} options\n     */\n    constructor({ linkService, eventBus }) {\n      this._linkService = linkService;\n      this._eventBus = eventBus;\n\n      this._reset();\n      eventBus._on(\"findbarclose\", this._onFindBarClose.bind(this));\n    }\n\n    get highlightMatches() {\n      return this._highlightMatches;\n    }\n\n    get pageMatches() {\n      return this._pageMatches;\n    }\n\n    get pageMatchesLength() {\n      return this._pageMatchesLength;\n    }\n\n    get selected() {\n      return this._selected;\n    }\n\n    get state() {\n      return this._state;\n    }\n\n    /**\n     * Set a reference to the PDF document in order to search it.\n     * Note that searching is not possible if this method is not called.\n     *\n     * @param {PDFDocumentProxy} pdfDocument - The PDF document to search.\n     */\n    setDocument(pdfDocument) {\n      if (this._pdfDocument) {\n        this._reset();\n      }\n      if (!pdfDocument) {\n        return;\n      }\n      this._pdfDocument = pdfDocument;\n      this._firstPageCapability.resolve();\n    }\n\n    executeCommand(cmd, state) {\n      if (!state) {\n        return;\n      }\n      const pdfDocument = this._pdfDocument;\n\n      if (this._state === null || this._shouldDirtyMatch(cmd, state)) {\n        this._dirtyMatch = true;\n      }\n      this._state = state;\n      if (cmd !== \"findhighlightallchange\") {\n        this._updateUIState(FindState.PENDING);\n      }\n\n      this._firstPageCapability.promise.then(() => {\n        // If the document was closed before searching began, or if the search\n        // operation was relevant for a previously opened document, do nothing.\n        if (\n          !this._pdfDocument ||\n          (pdfDocument && this._pdfDocument !== pdfDocument)\n        ) {\n          return;\n        }\n        this._extractText();\n\n        const findbarClosed = !this._highlightMatches;\n        const pendingTimeout = !!this._findTimeout;\n\n        if (this._findTimeout) {\n          clearTimeout(this._findTimeout);\n          this._findTimeout = null;\n        }\n        if (cmd === \"find\") {\n          // Trigger the find action with a small delay to avoid starting the\n          // search when the user is still typing (saving resources).\n          this._findTimeout = setTimeout(() => {\n            this._nextMatch();\n            this._findTimeout = null;\n          }, FIND_TIMEOUT);\n        } else if (this._dirtyMatch) {\n          // Immediately trigger searching for non-'find' operations, when the\n          // current state needs to be reset and matches re-calculated.\n          this._nextMatch();\n        } else if (cmd === \"findagain\") {\n          this._nextMatch();\n\n          // When the findbar was previously closed, and `highlightAll` is set,\n          // ensure that the matches on all active pages are highlighted again.\n          if (findbarClosed && this._state.highlightAll) {\n            this._updateAllPages();\n          }\n        } else if (cmd === \"findhighlightallchange\") {\n          // If there was a pending search operation, synchronously trigger a new\n          // search *first* to ensure that the correct matches are highlighted.\n          if (pendingTimeout) {\n            this._nextMatch();\n          } else {\n            this._highlightMatches = true;\n          }\n          this._updateAllPages(); // Update the highlighting on all active pages.\n        } else {\n          this._nextMatch();\n        }\n      });\n    }\n\n    scrollMatchIntoView({ element = null, pageIndex = -1, matchIndex = -1 }) {\n      if (!this._scrollMatches || !element) {\n        return;\n      } else if (matchIndex === -1 || matchIndex !== this._selected.matchIdx) {\n        return;\n      } else if (pageIndex === -1 || pageIndex !== this._selected.pageIdx) {\n        return;\n      }\n      this._scrollMatches = false; // Ensure that scrolling only happens once.\n\n      const spot = {\n        top: MATCH_SCROLL_OFFSET_TOP,\n        left: MATCH_SCROLL_OFFSET_LEFT,\n      };\n      scrollIntoView(element, spot, /* skipOverflowHiddenElements = */ true);\n    }\n\n    _reset() {\n      this._highlightMatches = false;\n      this._scrollMatches = false;\n      this._pdfDocument = null;\n      this._pageMatches = [];\n      this._pageMatchesLength = [];\n      this._state = null;\n      // Currently selected match.\n      this._selected = {\n        pageIdx: -1,\n        matchIdx: -1,\n      };\n      // Where the find algorithm currently is in the document.\n      this._offset = {\n        pageIdx: null,\n        matchIdx: null,\n        wrapped: false,\n      };\n      this._extractTextPromises = [];\n      this._pageContents = []; // Stores the normalized text for each page.\n      this._pageDiffs = [];\n      this._matchesCountTotal = 0;\n      this._pagesToSearch = null;\n      this._pendingFindMatches = Object.create(null);\n      this._resumePageIdx = null;\n      this._dirtyMatch = false;\n      clearTimeout(this._findTimeout);\n      this._findTimeout = null;\n\n      this._firstPageCapability = createPromiseCapability();\n    }\n\n    /**\n     * @type {string} The (current) normalized search query.\n     */\n    get _query() {\n      if (this._state.query !== this._rawQuery) {\n        this._rawQuery = this._state.query;\n        [this._normalizedQuery] = normalize(this._state.query);\n      }\n      return this._normalizedQuery;\n    }\n\n    _shouldDirtyMatch(cmd, state) {\n      // When the search query changes, regardless of the actual search command\n      // used, always re-calculate matches to avoid errors (fixes bug 1030622).\n      if (state.query !== this._state.query) {\n        return true;\n      }\n      switch (cmd) {\n        case \"findagain\":\n          const pageNumber = this._selected.pageIdx + 1;\n          const linkService = this._linkService;\n          // Only treat a 'findagain' event as a new search operation when it's\n          // *absolutely* certain that the currently selected match is no longer\n          // visible, e.g. as a result of the user scrolling in the document.\n          //\n          // NOTE: If only a simple `this._linkService.page` check was used here,\n          // there's a risk that consecutive 'findagain' operations could \"skip\"\n          // over matches at the top/bottom of pages thus making them completely\n          // inaccessible when there's multiple pages visible in the viewer.\n          if (\n            pageNumber >= 1 &&\n            pageNumber <= linkService.pagesCount &&\n            pageNumber !== linkService.page &&\n            !linkService.isPageVisible(pageNumber)\n          ) {\n            return true;\n          }\n          return false;\n        case \"findhighlightallchange\":\n          return false;\n      }\n      return true;\n    }\n\n    /**\n     * Helper for multi-term search that fills the `matchesWithLength` array\n     * and handles cases where one search term includes another search term (for\n     * example, \"tamed tame\" or \"this is\"). It looks for intersecting terms in\n     * the `matches` and keeps elements with a longer match length.\n     */\n    _prepareMatches(matchesWithLength, matches, matchesLength) {\n      function isSubTerm(currentIndex) {\n        const currentElem = matchesWithLength[currentIndex];\n        const nextElem = matchesWithLength[currentIndex + 1];\n\n        // Check for cases like \"TAMEd TAME\".\n        if (\n          currentIndex < matchesWithLength.length - 1 &&\n          currentElem.match === nextElem.match\n        ) {\n          currentElem.skipped = true;\n          return true;\n        }\n\n        // Check for cases like \"thIS IS\".\n        for (let i = currentIndex - 1; i >= 0; i--) {\n          const prevElem = matchesWithLength[i];\n          if (prevElem.skipped) {\n            continue;\n          }\n          if (prevElem.match + prevElem.matchLength < currentElem.match) {\n            break;\n          }\n          if (\n            prevElem.match + prevElem.matchLength >=\n            currentElem.match + currentElem.matchLength\n          ) {\n            currentElem.skipped = true;\n            return true;\n          }\n        }\n        return false;\n      }\n\n      // Sort the array of `{ match: <match>, matchLength: <matchLength> }`\n      // objects on increasing index first and on the length otherwise.\n      matchesWithLength.sort(function (a, b) {\n        return a.match === b.match\n          ? a.matchLength - b.matchLength\n          : a.match - b.match;\n      });\n      for (let i = 0, len = matchesWithLength.length; i < len; i++) {\n        if (isSubTerm(i)) {\n          continue;\n        }\n        matches.push(matchesWithLength[i].match);\n        matchesLength.push(matchesWithLength[i].matchLength);\n      }\n    }\n\n    /**\n     * Determine if the search query constitutes a \"whole word\", by comparing the\n     * first/last character type with the preceding/following character type.\n     */\n    _isEntireWord(content, startIdx, length) {\n      if (startIdx > 0) {\n        const first = content.charCodeAt(startIdx);\n        const limit = content.charCodeAt(startIdx - 1);\n        if (getCharacterType(first) === getCharacterType(limit)) {\n          return false;\n        }\n      }\n      const endIdx = startIdx + length - 1;\n      if (endIdx < content.length - 1) {\n        const last = content.charCodeAt(endIdx);\n        const limit = content.charCodeAt(endIdx + 1);\n        if (getCharacterType(last) === getCharacterType(limit)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    _calculatePhraseMatch(query, pageIndex, pageContent, pageDiffs, entireWord) {\n      const matches = [],\n        matchesLength = [];\n      const queryLen = query.length;\n\n      let matchIdx = -queryLen;\n      while (true) {\n        matchIdx = pageContent.indexOf(query, matchIdx + queryLen);\n        if (matchIdx === -1) {\n          break;\n        }\n        if (entireWord && !this._isEntireWord(pageContent, matchIdx, queryLen)) {\n          continue;\n        }\n        const originalMatchIdx = getOriginalIndex(matchIdx, pageDiffs),\n          matchEnd = matchIdx + queryLen - 1,\n          originalQueryLen =\n            getOriginalIndex(matchEnd, pageDiffs) - originalMatchIdx + 1;\n\n        matches.push(originalMatchIdx);\n        matchesLength.push(originalQueryLen);\n      }\n      this._pageMatches[pageIndex] = matches;\n      this._pageMatchesLength[pageIndex] = matchesLength;\n    }\n\n    _calculateWordMatch(query, pageIndex, pageContent, pageDiffs, entireWord) {\n      const matchesWithLength = [];\n\n      // Divide the query into pieces and search for text in each piece.\n      const queryArray = query.match(/\\S+/g);\n      for (let i = 0, len = queryArray.length; i < len; i++) {\n        const subquery = queryArray[i];\n        const subqueryLen = subquery.length;\n\n        let matchIdx = -subqueryLen;\n        while (true) {\n          matchIdx = pageContent.indexOf(subquery, matchIdx + subqueryLen);\n          if (matchIdx === -1) {\n            break;\n          }\n          if (\n            entireWord &&\n            !this._isEntireWord(pageContent, matchIdx, subqueryLen)\n          ) {\n            continue;\n          }\n          const originalMatchIdx = getOriginalIndex(matchIdx, pageDiffs),\n            matchEnd = matchIdx + subqueryLen - 1,\n            originalQueryLen =\n              getOriginalIndex(matchEnd, pageDiffs) - originalMatchIdx + 1;\n\n          // Other searches do not, so we store the length.\n          matchesWithLength.push({\n            match: originalMatchIdx,\n            matchLength: originalQueryLen,\n            skipped: false,\n          });\n        }\n      }\n\n      // Prepare arrays for storing the matches.\n      this._pageMatchesLength[pageIndex] = [];\n      this._pageMatches[pageIndex] = [];\n\n      // Sort `matchesWithLength`, remove intersecting terms and put the result\n      // into the two arrays.\n      this._prepareMatches(\n        matchesWithLength,\n        this._pageMatches[pageIndex],\n        this._pageMatchesLength[pageIndex]\n      );\n    }\n\n    _calculateMatch(pageIndex) {\n      let pageContent = this._pageContents[pageIndex];\n      const pageDiffs = this._pageDiffs[pageIndex];\n      let query = this._query;\n      const { caseSensitive, entireWord, phraseSearch } = this._state;\n\n      if (query.length === 0) {\n        // Do nothing: the matches should be wiped out already.\n        return;\n      }\n\n      if (!caseSensitive) {\n        pageContent = pageContent.toLowerCase();\n        query = query.toLowerCase();\n      }\n\n      if (phraseSearch) {\n        this._calculatePhraseMatch(\n          query,\n          pageIndex,\n          pageContent,\n          pageDiffs,\n          entireWord\n        );\n      } else {\n        this._calculateWordMatch(\n          query,\n          pageIndex,\n          pageContent,\n          pageDiffs,\n          entireWord\n        );\n      }\n\n      // When `highlightAll` is set, ensure that the matches on previously\n      // rendered (and still active) pages are correctly highlighted.\n      if (this._state.highlightAll) {\n        this._updatePage(pageIndex);\n      }\n      if (this._resumePageIdx === pageIndex) {\n        this._resumePageIdx = null;\n        this._nextPageMatch();\n      }\n\n      // Update the match count.\n      const pageMatchesCount = this._pageMatches[pageIndex].length;\n      if (pageMatchesCount > 0) {\n        this._matchesCountTotal += pageMatchesCount;\n        this._updateUIResultsCount();\n      }\n    }\n\n    _extractText() {\n      // Perform text extraction once if this method is called multiple times.\n      if (this._extractTextPromises.length > 0) {\n        return;\n      }\n\n      let promise = Promise.resolve();\n      for (let i = 0, ii = this._linkService.pagesCount; i < ii; i++) {\n        const extractTextCapability = createPromiseCapability();\n        this._extractTextPromises[i] = extractTextCapability.promise;\n\n        promise = promise.then(() => {\n          return this._pdfDocument\n            .getPage(i + 1)\n            .then(pdfPage => {\n              return pdfPage.getTextContent({\n                normalizeWhitespace: true,\n              });\n            })\n            .then(\n              textContent => {\n                const textItems = textContent.items;\n                const strBuf = [];\n\n                for (let j = 0, jj = textItems.length; j < jj; j++) {\n                  strBuf.push(textItems[j].str);\n                }\n\n                // Store the normalized page content (text items) as one string.\n                [this._pageContents[i], this._pageDiffs[i]] = normalize(\n                  strBuf.join(\"\")\n                );\n                extractTextCapability.resolve(i);\n              },\n              reason => {\n                console.error(\n                  `Unable to get text content for page ${i + 1}`,\n                  reason\n                );\n                // Page error -- assuming no text content.\n                this._pageContents[i] = \"\";\n                this._pageDiffs[i] = null;\n                extractTextCapability.resolve(i);\n              }\n            );\n        });\n      }\n    }\n\n    _updatePage(index) {\n      if (this._scrollMatches && this._selected.pageIdx === index) {\n        // If the page is selected, scroll the page into view, which triggers\n        // rendering the page, which adds the text layer. Once the text layer\n        // is built, it will attempt to scroll the selected match into view.\n        this._linkService.page = index + 1;\n      }\n\n      this._eventBus.dispatch(\"updatetextlayermatches\", {\n        source: this,\n        pageIndex: index,\n      });\n    }\n\n    _updateAllPages() {\n      this._eventBus.dispatch(\"updatetextlayermatches\", {\n        source: this,\n        pageIndex: -1,\n      });\n    }\n\n    _nextMatch() {\n      const previous = this._state.findPrevious;\n      const currentPageIndex = this._linkService.page - 1;\n      const numPages = this._linkService.pagesCount;\n\n      this._highlightMatches = true;\n\n      if (this._dirtyMatch) {\n        // Need to recalculate the matches, reset everything.\n        this._dirtyMatch = false;\n        this._selected.pageIdx = this._selected.matchIdx = -1;\n        this._offset.pageIdx = currentPageIndex;\n        this._offset.matchIdx = null;\n        this._offset.wrapped = false;\n        this._resumePageIdx = null;\n        this._pageMatches.length = 0;\n        this._pageMatchesLength.length = 0;\n        this._matchesCountTotal = 0;\n\n        this._updateAllPages(); // Wipe out any previously highlighted matches.\n\n        for (let i = 0; i < numPages; i++) {\n          // Start finding the matches as soon as the text is extracted.\n          if (this._pendingFindMatches[i] === true) {\n            continue;\n          }\n          this._pendingFindMatches[i] = true;\n          this._extractTextPromises[i].then(pageIdx => {\n            delete this._pendingFindMatches[pageIdx];\n            this._calculateMatch(pageIdx);\n          });\n        }\n      }\n\n      // If there's no query there's no point in searching.\n      if (this._query === \"\") {\n        this._updateUIState(FindState.FOUND);\n        return;\n      }\n      // If we're waiting on a page, we return since we can't do anything else.\n      if (this._resumePageIdx) {\n        return;\n      }\n\n      const offset = this._offset;\n      // Keep track of how many pages we should maximally iterate through.\n      this._pagesToSearch = numPages;\n      // If there's already a `matchIdx` that means we are iterating through a\n      // page's matches.\n      if (offset.matchIdx !== null) {\n        const numPageMatches = this._pageMatches[offset.pageIdx].length;\n        if (\n          (!previous && offset.matchIdx + 1 < numPageMatches) ||\n          (previous && offset.matchIdx > 0)\n        ) {\n          // The simple case; we just have advance the matchIdx to select\n          // the next match on the page.\n          offset.matchIdx = previous ? offset.matchIdx - 1 : offset.matchIdx + 1;\n          this._updateMatch(/* found = */ true);\n          return;\n        }\n        // We went beyond the current page's matches, so we advance to\n        // the next page.\n        this._advanceOffsetPage(previous);\n      }\n      // Start searching through the page.\n      this._nextPageMatch();\n    }\n\n    _matchesReady(matches) {\n      const offset = this._offset;\n      const numMatches = matches.length;\n      const previous = this._state.findPrevious;\n\n      if (numMatches) {\n        // There were matches for the page, so initialize `matchIdx`.\n        offset.matchIdx = previous ? numMatches - 1 : 0;\n        this._updateMatch(/* found = */ true);\n        return true;\n      }\n      // No matches, so attempt to search the next page.\n      this._advanceOffsetPage(previous);\n      if (offset.wrapped) {\n        offset.matchIdx = null;\n        if (this._pagesToSearch < 0) {\n          // No point in wrapping again, there were no matches.\n          this._updateMatch(/* found = */ false);\n          // While matches were not found, searching for a page\n          // with matches should nevertheless halt.\n          return true;\n        }\n      }\n      // Matches were not found (and searching is not done).\n      return false;\n    }\n\n    _nextPageMatch() {\n      if (this._resumePageIdx !== null) {\n        console.error(\"There can only be one pending page.\");\n      }\n\n      let matches = null;\n      do {\n        const pageIdx = this._offset.pageIdx;\n        matches = this._pageMatches[pageIdx];\n        if (!matches) {\n          // The matches don't exist yet for processing by `_matchesReady`,\n          // so set a resume point for when they do exist.\n          this._resumePageIdx = pageIdx;\n          break;\n        }\n      } while (!this._matchesReady(matches));\n    }\n\n    _advanceOffsetPage(previous) {\n      const offset = this._offset;\n      const numPages = this._linkService.pagesCount;\n      offset.pageIdx = previous ? offset.pageIdx - 1 : offset.pageIdx + 1;\n      offset.matchIdx = null;\n\n      this._pagesToSearch--;\n\n      if (offset.pageIdx >= numPages || offset.pageIdx < 0) {\n        offset.pageIdx = previous ? numPages - 1 : 0;\n        offset.wrapped = true;\n      }\n    }\n\n    _updateMatch(found = false) {\n      let state = FindState.NOT_FOUND;\n      const wrapped = this._offset.wrapped;\n      this._offset.wrapped = false;\n\n      if (found) {\n        const previousPage = this._selected.pageIdx;\n        this._selected.pageIdx = this._offset.pageIdx;\n        this._selected.matchIdx = this._offset.matchIdx;\n        state = wrapped ? FindState.WRAPPED : FindState.FOUND;\n\n        // Update the currently selected page to wipe out any selected matches.\n        if (previousPage !== -1 && previousPage !== this._selected.pageIdx) {\n          this._updatePage(previousPage);\n        }\n      }\n\n      this._updateUIState(state, this._state.findPrevious);\n      if (this._selected.pageIdx !== -1) {\n        // Ensure that the match will be scrolled into view.\n        this._scrollMatches = true;\n\n        this._updatePage(this._selected.pageIdx);\n      }\n    }\n\n    _onFindBarClose(evt) {\n      const pdfDocument = this._pdfDocument;\n      // Since searching is asynchronous, ensure that the removal of highlighted\n      // matches (from the UI) is async too such that the 'updatetextlayermatches'\n      // events will always be dispatched in the expected order.\n      this._firstPageCapability.promise.then(() => {\n        // Only update the UI if the document is open, and is the current one.\n        if (\n          !this._pdfDocument ||\n          (pdfDocument && this._pdfDocument !== pdfDocument)\n        ) {\n          return;\n        }\n        // Ensure that a pending, not yet started, search operation is aborted.\n        if (this._findTimeout) {\n          clearTimeout(this._findTimeout);\n          this._findTimeout = null;\n        }\n        // Abort any long running searches, to avoid a match being scrolled into\n        // view *after* the findbar has been closed. In this case `this._offset`\n        // will most likely differ from `this._selected`, hence we also ensure\n        // that any new search operation will always start with a clean slate.\n        if (this._resumePageIdx) {\n          this._resumePageIdx = null;\n          this._dirtyMatch = true;\n        }\n        // Avoid the UI being in a pending state when the findbar is re-opened.\n        this._updateUIState(FindState.FOUND);\n\n        this._highlightMatches = false;\n        this._updateAllPages(); // Wipe out any previously highlighted matches.\n      });\n    }\n\n    _requestMatchesCount() {\n      const { pageIdx, matchIdx } = this._selected;\n      let current = 0,\n        total = this._matchesCountTotal;\n      if (matchIdx !== -1) {\n        for (let i = 0; i < pageIdx; i++) {\n          current += (this._pageMatches[i] && this._pageMatches[i].length) || 0;\n        }\n        current += matchIdx + 1;\n      }\n      // When searching starts, this method may be called before the `pageMatches`\n      // have been counted (in `_calculateMatch`). Ensure that the UI won't show\n      // temporarily broken state when the active find result doesn't make sense.\n      if (current < 1 || current > total) {\n        current = total = 0;\n      }\n      return { current, total };\n    }\n\n    _updateUIResultsCount() {\n      this._eventBus.dispatch(\"updatefindmatchescount\", {\n        source: this,\n        matchesCount: this._requestMatchesCount(),\n      });\n    }\n\n    _updateUIState(state, previous) {\n      this._eventBus.dispatch(\"updatefindcontrolstate\", {\n        source: this,\n        state,\n        previous,\n        matchesCount: this._requestMatchesCount(),\n        rawQuery: this._state ? this._state.query : null,\n      });\n    }\n  }\n\n  return { FindState, PDFFindController };\n});"]}