{"version":3,"sources":["skylark-pdfjs-viewer.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-pdfjs-viewer.js","sourcesContent":["define('skylark-pdfjs-viewer/pdfjs_dev',[],function(){\r\n\tfunction evalInScope(js, contextAsScope) {\r\n\t    //# Return the results of the in-line anonymous function we .call with the passed context\r\n\t    return function() { with(this) { return eval(js); }; }.call(contextAsScope);\r\n\t}\r\n\r\n\r\n\tvar DEFINES = {\r\n\t  BUNDLE_VERSION : \"2.7.570\",\r\n\t  BUNDLE_BUILD : 0,\r\n\t  PRODUCTION: true,\r\n\t  SKIP_BABEL: true,\r\n\t  TESTING: false,\r\n\t  // The main build targets:\r\n\t  GENERIC: true,\r\n\t  MOZCENTRAL: false,\r\n\t  CHROME: false,\r\n\t  MINIFIED: false,\r\n\t  COMPONENTS: false,\r\n\t  LIB: false,\r\n\t  IMAGE_DECODERS: false,\r\n\t};\r\n\r\n\r\n\treturn   {\r\n\t\tDEFINES,\r\n\r\n\t\teval(s) {\r\n\t\t\treturn evalInScope(s,DEFINES);\r\n\t\t},\r\n\r\n\r\n\t\ttest(s) {\r\n\t\t\treturn !!evalInScope(s,DEFINES);\r\n\r\n\t\t}\r\n\r\n\r\n\t}\r\n\r\n});\ndefine('skylark-pdfjs-viewer/viewer_compatibility',[\n  \"./pdfjs_dev\"\n],function(PDFJSDev){\n  /* Copyright 2018 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const compatibilityParams = Object.create(null);\n  if (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) {\n    const userAgent =\n      (typeof navigator !== \"undefined\" && navigator.userAgent) || \"\";\n    const platform =\n      (typeof navigator !== \"undefined\" && navigator.platform) || \"\";\n    const maxTouchPoints =\n      (typeof navigator !== \"undefined\" && navigator.maxTouchPoints) || 1;\n\n    const isAndroid = /Android/.test(userAgent);\n    const isIOS =\n      /\\b(iPad|iPhone|iPod)(?=;)/.test(userAgent) ||\n      (platform === \"MacIntel\" && maxTouchPoints > 1);\n    const isIOSChrome = /CriOS/.test(userAgent);\n\n    // Checks if possible to use URL.createObjectURL()\n    // Support: IE, Chrome on iOS\n    (function checkOnBlobSupport() {\n      // Sometimes Chrome on iOS loses data created with createObjectURL(),\n      // see issue #8081.\n      if (isIOSChrome) {\n        compatibilityParams.disableCreateObjectURL = true;\n      }\n    })();\n\n    // Limit canvas size to 5 mega-pixels on mobile.\n    // Support: Android, iOS\n    (function checkCanvasSizeLimitation() {\n      if (isIOS || isAndroid) {\n        compatibilityParams.maxCanvasPixels = 5242880;\n      }\n    })();\n  }\n  const viewerCompatibilityParams = Object.freeze(compatibilityParams);\n\n  return { viewerCompatibilityParams };\n});\ndefine('skylark-pdfjs-viewer/app_options',[\n  \"./viewer_compatibility\",\n  \"./pdfjs_dev\"\n],function(viewer_compatibility,PDFJSDev){\n\n  /* Copyright 2018 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { viewerCompatibilityParams } = viewer_compatibility;\n\n  const OptionKind = {\n    VIEWER: 0x02,\n    API: 0x04,\n    WORKER: 0x08,\n    PREFERENCE: 0x80,\n  };\n\n  /**\n   * PLEASE NOTE: To avoid introducing unnecessary dependencies, we specify the\n   *              values below *explicitly* rather than relying on imported types.\n   */\n  const defaultOptions = {\n    cursorToolOnLoad: {\n      /** @type {number} */\n      value: 0,\n      kind: OptionKind.VIEWER + OptionKind.PREFERENCE,\n    },\n    defaultUrl: {\n      /** @type {string} */\n      value: \"compressed.tracemonkey-pldi-09.pdf\",\n      kind: OptionKind.VIEWER,\n    },\n    defaultZoomValue: {\n      /** @type {string} */\n      value: \"\",\n      kind: OptionKind.VIEWER + OptionKind.PREFERENCE,\n    },\n    disableHistory: {\n      /** @type {boolean} */\n      value: false,\n      kind: OptionKind.VIEWER,\n    },\n    disablePageLabels: {\n      /** @type {boolean} */\n      value: false,\n      kind: OptionKind.VIEWER + OptionKind.PREFERENCE,\n    },\n    /**\n     * The `disablePreferences` is, conditionally, defined below.\n     */\n    enablePermissions: {\n      /** @type {boolean} */\n      value: false,\n      kind: OptionKind.VIEWER + OptionKind.PREFERENCE,\n    },\n    enablePrintAutoRotate: {\n      /** @type {boolean} */\n      value: false,\n      kind: OptionKind.VIEWER + OptionKind.PREFERENCE,\n    },\n    enableScripting: {\n      /** @type {boolean} */\n      value: typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"TESTING\"),\n      kind: OptionKind.VIEWER + OptionKind.PREFERENCE,\n    },\n    enableWebGL: {\n      /** @type {boolean} */\n      value: false,\n      kind: OptionKind.VIEWER + OptionKind.PREFERENCE,\n    },\n    externalLinkRel: {\n      /** @type {string} */\n      value: \"noopener noreferrer nofollow\",\n      kind: OptionKind.VIEWER,\n    },\n    externalLinkTarget: {\n      /** @type {number} */\n      value: 0,\n      kind: OptionKind.VIEWER + OptionKind.PREFERENCE,\n    },\n    historyUpdateUrl: {\n      /** @type {boolean} */\n      value: false,\n      kind: OptionKind.VIEWER + OptionKind.PREFERENCE,\n    },\n    ignoreDestinationZoom: {\n      /** @type {boolean} */\n      value: false,\n      kind: OptionKind.VIEWER + OptionKind.PREFERENCE,\n    },\n    imageResourcesPath: {\n      /** @type {string} */\n      value: \"./images/\",\n      kind: OptionKind.VIEWER,\n    },\n    /**\n     * The `locale` is, conditionally, defined below.\n     */\n    maxCanvasPixels: {\n      /** @type {number} */\n      value: 16777216,\n      compatibility: viewerCompatibilityParams.maxCanvasPixels,\n      kind: OptionKind.VIEWER,\n    },\n    pdfBugEnabled: {\n      /** @type {boolean} */\n      value: typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"PRODUCTION\"),\n      kind: OptionKind.VIEWER + OptionKind.PREFERENCE,\n    },\n    printResolution: {\n      /** @type {number} */\n      value: 150,\n      kind: OptionKind.VIEWER,\n    },\n    renderer: {\n      /** @type {string} */\n      value: \"canvas\",\n      kind: OptionKind.VIEWER + OptionKind.PREFERENCE,\n    },\n    renderInteractiveForms: {\n      /** @type {boolean} */\n      value: true,\n      kind: OptionKind.VIEWER + OptionKind.PREFERENCE,\n    },\n    sidebarViewOnLoad: {\n      /** @type {number} */\n      value: -1,\n      kind: OptionKind.VIEWER + OptionKind.PREFERENCE,\n    },\n    scrollModeOnLoad: {\n      /** @type {number} */\n      value: -1,\n      kind: OptionKind.VIEWER + OptionKind.PREFERENCE,\n    },\n    spreadModeOnLoad: {\n      /** @type {number} */\n      value: -1,\n      kind: OptionKind.VIEWER + OptionKind.PREFERENCE,\n    },\n    textLayerMode: {\n      /** @type {number} */\n      value: 1,\n      kind: OptionKind.VIEWER + OptionKind.PREFERENCE,\n    },\n    useOnlyCssZoom: {\n      /** @type {boolean} */\n      value: false,\n      kind: OptionKind.VIEWER + OptionKind.PREFERENCE,\n    },\n    viewerCssTheme: {\n      /** @type {number} */\n      value: 0,\n      kind: OptionKind.VIEWER + OptionKind.PREFERENCE,\n    },\n    viewOnLoad: {\n      /** @type {boolean} */\n      value: 0,\n      kind: OptionKind.VIEWER + OptionKind.PREFERENCE,\n    },\n\n    cMapPacked: {\n      /** @type {boolean} */\n      value: true,\n      kind: OptionKind.API,\n    },\n    cMapUrl: {\n      /** @type {string} */\n      value:\n        typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"PRODUCTION\")\n          ? \"../external/bcmaps/\"\n          : \"../web/cmaps/\",\n      kind: OptionKind.API,\n    },\n    disableAutoFetch: {\n      /** @type {boolean} */\n      value: false,\n      kind: OptionKind.API + OptionKind.PREFERENCE,\n    },\n    disableFontFace: {\n      /** @type {boolean} */\n      value: false,\n      kind: OptionKind.API + OptionKind.PREFERENCE,\n    },\n    disableRange: {\n      /** @type {boolean} */\n      value: false,\n      kind: OptionKind.API + OptionKind.PREFERENCE,\n    },\n    disableStream: {\n      /** @type {boolean} */\n      value: false,\n      kind: OptionKind.API + OptionKind.PREFERENCE,\n    },\n    docBaseUrl: {\n      /** @type {string} */\n      value: \"\",\n      kind: OptionKind.API,\n    },\n    fontExtraProperties: {\n      /** @type {boolean} */\n      value: false,\n      kind: OptionKind.API,\n    },\n    isEvalSupported: {\n      /** @type {boolean} */\n      value: true,\n      kind: OptionKind.API,\n    },\n    maxImageSize: {\n      /** @type {number} */\n      value: -1,\n      kind: OptionKind.API,\n    },\n    pdfBug: {\n      /** @type {boolean} */\n      value: false,\n      kind: OptionKind.API,\n    },\n    verbosity: {\n      /** @type {number} */\n      value: 1,\n      kind: OptionKind.API,\n    },\n\n    workerPort: {\n      /** @type {Object} */\n      value: null,\n      kind: OptionKind.WORKER,\n    },\n    workerSrc: {\n      /** @type {string} */\n      value:\n        typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"PRODUCTION\")\n          ? \"../src/worker_loader.js\"\n          : \"../build/pdf.worker.js\",\n      kind: OptionKind.WORKER,\n    },\n  };\n  if (\n    typeof PDFJSDev === \"undefined\" ||\n    PDFJSDev.test(\"!PRODUCTION || (GENERIC && !LIB)\")\n  ) {\n    defaultOptions.disablePreferences = {\n      /** @type {boolean} */\n      value: typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"TESTING\"),\n      kind: OptionKind.VIEWER,\n    };\n    defaultOptions.locale = {\n      /** @type {string} */\n      value: typeof navigator !== \"undefined\" ? navigator.language : \"en-US\",\n      kind: OptionKind.VIEWER,\n    };\n    defaultOptions.sandboxBundleSrc = {\n      /** @type {string} */\n      value:\n        typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"PRODUCTION\")\n          ? \"../build/dev-sandbox/pdf.sandbox.js\"\n          : \"../build/pdf.sandbox.js\",\n      kind: OptionKind.VIEWER,\n    };\n  } else if (PDFJSDev.test(\"CHROME\")) {\n    defaultOptions.sandboxBundleSrc = {\n      /** @type {string} */\n      value: \"../build/pdf.sandbox.js\",\n      kind: OptionKind.VIEWER,\n    };\n  }\n\n  const userOptions = Object.create(null);\n\n  class AppOptions {\n    constructor() {\n      throw new Error(\"Cannot initialize AppOptions.\");\n    }\n\n    static get(name) {\n      const userOption = userOptions[name];\n      if (userOption !== undefined) {\n        return userOption;\n      }\n      const defaultOption = defaultOptions[name];\n      if (defaultOption !== undefined) {\n        return defaultOption.compatibility || defaultOption.value;\n      }\n      return undefined;\n    }\n\n    static getAll(kind = null) {\n      const options = Object.create(null);\n      for (const name in defaultOptions) {\n        const defaultOption = defaultOptions[name];\n        if (kind) {\n          if ((kind & defaultOption.kind) === 0) {\n            continue;\n          }\n          if (kind === OptionKind.PREFERENCE) {\n            const value = defaultOption.value,\n              valueType = typeof value;\n\n            if (\n              valueType === \"boolean\" ||\n              valueType === \"string\" ||\n              (valueType === \"number\" && Number.isInteger(value))\n            ) {\n              options[name] = value;\n              continue;\n            }\n            throw new Error(`Invalid type for preference: ${name}`);\n          }\n        }\n        const userOption = userOptions[name];\n        options[name] =\n          userOption !== undefined\n            ? userOption\n            : defaultOption.compatibility || defaultOption.value;\n      }\n      return options;\n    }\n\n    static set(name, value) {\n      userOptions[name] = value;\n    }\n\n    static setAll(options) {\n      for (const name in options) {\n        userOptions[name] = options[name];\n      }\n    }\n\n    static remove(name) {\n      delete userOptions[name];\n    }\n  }\n\n  return { AppOptions, OptionKind };\n});\ndefine('skylark-pdfjs-viewer/ui_utils',[\n  \"./pdfjs_dev\"\n],function(PDFJSDev){\n  /* Copyright 2012 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const CSS_UNITS = 96.0 / 72.0;\n  const DEFAULT_SCALE_VALUE = \"auto\";\n  const DEFAULT_SCALE = 1.0;\n  const MIN_SCALE = 0.1;\n  const MAX_SCALE = 10.0;\n  const UNKNOWN_SCALE = 0;\n  const MAX_AUTO_SCALE = 1.25;\n  const SCROLLBAR_PADDING = 40;\n  const VERTICAL_PADDING = 5;\n\n  const LOADINGBAR_END_OFFSET_VAR = \"--loadingBar-end-offset\";\n\n  const PresentationModeState = {\n    UNKNOWN: 0,\n    NORMAL: 1,\n    CHANGING: 2,\n    FULLSCREEN: 3,\n  };\n\n  const SidebarView = {\n    UNKNOWN: -1,\n    NONE: 0,\n    THUMBS: 1, // Default value.\n    OUTLINE: 2,\n    ATTACHMENTS: 3,\n    LAYERS: 4,\n  };\n\n  const RendererType = {\n    CANVAS: \"canvas\",\n    SVG: \"svg\",\n  };\n\n  const TextLayerMode = {\n    DISABLE: 0,\n    ENABLE: 1,\n    ENABLE_ENHANCE: 2,\n  };\n\n  const ScrollMode = {\n    UNKNOWN: -1,\n    VERTICAL: 0, // Default value.\n    HORIZONTAL: 1,\n    WRAPPED: 2,\n  };\n\n  const SpreadMode = {\n    UNKNOWN: -1,\n    NONE: 0, // Default value.\n    ODD: 1,\n    EVEN: 2,\n  };\n\n  // Used by `PDFViewerApplication`, and by the API unit-tests.\n  const AutoPrintRegExp = /\\bprint\\s*\\(/;\n\n  // Replaces {{arguments}} with their values.\n  function formatL10nValue(text, args) {\n    if (!args) {\n      return text;\n    }\n    return text.replace(/\\{\\{\\s*(\\w+)\\s*\\}\\}/g, (all, name) => {\n      return name in args ? args[name] : \"{{\" + name + \"}}\";\n    });\n  }\n\n  /**\n   * No-op implementation of the localization service.\n   * @implements {IL10n}\n   */\n  const NullL10n = {\n    async getLanguage() {\n      return \"en-us\";\n    },\n\n    async getDirection() {\n      return \"ltr\";\n    },\n\n    async get(property, args, fallback) {\n      return formatL10nValue(fallback, args);\n    },\n\n    async translate(element) {},\n  };\n\n  /**\n   * Returns scale factor for the canvas. It makes sense for the HiDPI displays.\n   * @returns {Object} The object with horizontal (sx) and vertical (sy)\n   *                   scales. The scaled property is set to false if scaling is\n   *                   not required, true otherwise.\n   */\n  function getOutputScale(ctx) {\n    const devicePixelRatio = window.devicePixelRatio || 1;\n    const backingStoreRatio =\n      ctx.webkitBackingStorePixelRatio ||\n      ctx.mozBackingStorePixelRatio ||\n      ctx.backingStorePixelRatio ||\n      1;\n    const pixelRatio = devicePixelRatio / backingStoreRatio;\n    return {\n      sx: pixelRatio,\n      sy: pixelRatio,\n      scaled: pixelRatio !== 1,\n    };\n  }\n\n  /**\n   * Scrolls specified element into view of its parent.\n   * @param {Object} element - The element to be visible.\n   * @param {Object} spot - An object with optional top and left properties,\n   *   specifying the offset from the top left edge.\n   * @param {boolean} skipOverflowHiddenElements - Ignore elements that have\n   *   the CSS rule `overflow: hidden;` set. The default is false.\n   */\n  function scrollIntoView(element, spot, skipOverflowHiddenElements = false) {\n    // Assuming offsetParent is available (it's not available when viewer is in\n    // hidden iframe or object). We have to scroll: if the offsetParent is not set\n    // producing the error. See also animationStarted.\n    let parent = element.offsetParent;\n    if (!parent) {\n      console.error(\"offsetParent is not set -- cannot scroll\");\n      return;\n    }\n    let offsetY = element.offsetTop + element.clientTop;\n    let offsetX = element.offsetLeft + element.clientLeft;\n    while (\n      (parent.clientHeight === parent.scrollHeight &&\n        parent.clientWidth === parent.scrollWidth) ||\n      (skipOverflowHiddenElements &&\n        getComputedStyle(parent).overflow === \"hidden\")\n    ) {\n      if (parent.dataset._scaleY) {\n        offsetY /= parent.dataset._scaleY;\n        offsetX /= parent.dataset._scaleX;\n      }\n      offsetY += parent.offsetTop;\n      offsetX += parent.offsetLeft;\n      parent = parent.offsetParent;\n      if (!parent) {\n        return; // no need to scroll\n      }\n    }\n    if (spot) {\n      if (spot.top !== undefined) {\n        offsetY += spot.top;\n      }\n      if (spot.left !== undefined) {\n        offsetX += spot.left;\n        parent.scrollLeft = offsetX;\n      }\n    }\n    parent.scrollTop = offsetY;\n  }\n\n  /**\n   * Helper function to start monitoring the scroll event and converting them into\n   * PDF.js friendly one: with scroll debounce and scroll direction.\n   */\n  function watchScroll(viewAreaElement, callback) {\n    const debounceScroll = function (evt) {\n      if (rAF) {\n        return;\n      }\n      // schedule an invocation of scroll for next animation frame.\n      rAF = window.requestAnimationFrame(function viewAreaElementScrolled() {\n        rAF = null;\n\n        const currentX = viewAreaElement.scrollLeft;\n        const lastX = state.lastX;\n        if (currentX !== lastX) {\n          state.right = currentX > lastX;\n        }\n        state.lastX = currentX;\n        const currentY = viewAreaElement.scrollTop;\n        const lastY = state.lastY;\n        if (currentY !== lastY) {\n          state.down = currentY > lastY;\n        }\n        state.lastY = currentY;\n        callback(state);\n      });\n    };\n\n    const state = {\n      right: true,\n      down: true,\n      lastX: viewAreaElement.scrollLeft,\n      lastY: viewAreaElement.scrollTop,\n      _eventHandler: debounceScroll,\n    };\n\n    let rAF = null;\n    viewAreaElement.addEventListener(\"scroll\", debounceScroll, true);\n    return state;\n  }\n\n  /**\n   * Helper function to parse query string (e.g. ?param1=value&parm2=...).\n   */\n  function parseQueryString(query) {\n    const parts = query.split(\"&\");\n    const params = Object.create(null);\n    for (let i = 0, ii = parts.length; i < ii; ++i) {\n      const param = parts[i].split(\"=\");\n      const key = param[0].toLowerCase();\n      const value = param.length > 1 ? param[1] : null;\n      params[decodeURIComponent(key)] = decodeURIComponent(value);\n    }\n    return params;\n  }\n\n  /**\n   * Use binary search to find the index of the first item in a given array which\n   * passes a given condition. The items are expected to be sorted in the sense\n   * that if the condition is true for one item in the array, then it is also true\n   * for all following items.\n   *\n   * @returns {number} Index of the first array element to pass the test,\n   *                   or |items.length| if no such element exists.\n   */\n  function binarySearchFirstItem(items, condition) {\n    let minIndex = 0;\n    let maxIndex = items.length - 1;\n\n    if (maxIndex < 0 || !condition(items[maxIndex])) {\n      return items.length;\n    }\n    if (condition(items[minIndex])) {\n      return minIndex;\n    }\n\n    while (minIndex < maxIndex) {\n      const currentIndex = (minIndex + maxIndex) >> 1;\n      const currentItem = items[currentIndex];\n      if (condition(currentItem)) {\n        maxIndex = currentIndex;\n      } else {\n        minIndex = currentIndex + 1;\n      }\n    }\n    return minIndex; /* === maxIndex */\n  }\n\n  /**\n   *  Approximates float number as a fraction using Farey sequence (max order\n   *  of 8).\n   *  @param {number} x - Positive float number.\n   *  @returns {Array} Estimated fraction: the first array item is a numerator,\n   *                   the second one is a denominator.\n   */\n  function approximateFraction(x) {\n    // Fast paths for int numbers or their inversions.\n    if (Math.floor(x) === x) {\n      return [x, 1];\n    }\n    const xinv = 1 / x;\n    const limit = 8;\n    if (xinv > limit) {\n      return [1, limit];\n    } else if (Math.floor(xinv) === xinv) {\n      return [1, xinv];\n    }\n\n    const x_ = x > 1 ? xinv : x;\n    // a/b and c/d are neighbours in Farey sequence.\n    let a = 0,\n      b = 1,\n      c = 1,\n      d = 1;\n    // Limiting search to order 8.\n    while (true) {\n      // Generating next term in sequence (order of q).\n      const p = a + c,\n        q = b + d;\n      if (q > limit) {\n        break;\n      }\n      if (x_ <= p / q) {\n        c = p;\n        d = q;\n      } else {\n        a = p;\n        b = q;\n      }\n    }\n    let result;\n    // Select closest of the neighbours to x.\n    if (x_ - a / b < c / d - x_) {\n      result = x_ === x ? [a, b] : [b, a];\n    } else {\n      result = x_ === x ? [c, d] : [d, c];\n    }\n    return result;\n  }\n\n  function roundToDivide(x, div) {\n    const r = x % div;\n    return r === 0 ? x : Math.round(x - r + div);\n  }\n\n  /**\n   * Gets the size of the specified page, converted from PDF units to inches.\n   * @param {Object} An Object containing the properties: {Array} `view`,\n   *   {number} `userUnit`, and {number} `rotate`.\n   * @returns {Object} An Object containing the properties: {number} `width`\n   *   and {number} `height`, given in inches.\n   */\n  function getPageSizeInches({ view, userUnit, rotate }) {\n    const [x1, y1, x2, y2] = view;\n    // We need to take the page rotation into account as well.\n    const changeOrientation = rotate % 180 !== 0;\n\n    const width = ((x2 - x1) / 72) * userUnit;\n    const height = ((y2 - y1) / 72) * userUnit;\n\n    return {\n      width: changeOrientation ? height : width,\n      height: changeOrientation ? width : height,\n    };\n  }\n\n  /**\n   * Helper function for getVisibleElements.\n   *\n   * @param {number} index - initial guess at the first visible element\n   * @param {Array} views - array of pages, into which `index` is an index\n   * @param {number} top - the top of the scroll pane\n   * @returns {number} less than or equal to `index` that is definitely at or\n   *   before the first visible element in `views`, but not by too much. (Usually,\n   *   this will be the first element in the first partially visible row in\n   *   `views`, although sometimes it goes back one row further.)\n   */\n  function backtrackBeforeAllVisibleElements(index, views, top) {\n    // binarySearchFirstItem's assumption is that the input is ordered, with only\n    // one index where the conditions flips from false to true: [false ...,\n    // true...]. With vertical scrolling and spreads, it is possible to have\n    // [false ..., true, false, true ...]. With wrapped scrolling we can have a\n    // similar sequence, with many more mixed true and false in the middle.\n    //\n    // So there is no guarantee that the binary search yields the index of the\n    // first visible element. It could have been any of the other visible elements\n    // that were preceded by a hidden element.\n\n    // Of course, if either this element or the previous (hidden) element is also\n    // the first element, there's nothing to worry about.\n    if (index < 2) {\n      return index;\n    }\n\n    // That aside, the possible cases are represented below.\n    //\n    //     ****  = fully hidden\n    //     A*B*  = mix of partially visible and/or hidden pages\n    //     CDEF  = fully visible\n    //\n    // (1) Binary search could have returned A, in which case we can stop.\n    // (2) Binary search could also have returned B, in which case we need to\n    // check the whole row.\n    // (3) Binary search could also have returned C, in which case we need to\n    // check the whole previous row.\n    //\n    // There's one other possibility:\n    //\n    //     ****  = fully hidden\n    //     ABCD  = mix of fully and/or partially visible pages\n    //\n    // (4) Binary search could only have returned A.\n\n    // Initially assume that we need to find the beginning of the current row\n    // (case 1, 2, or 4), which means finding a page that is above the current\n    // page's top. If the found page is partially visible, we're definitely not in\n    // case 3, and this assumption is correct.\n    let elt = views[index].div;\n    let pageTop = elt.offsetTop + elt.clientTop;\n\n    if (pageTop >= top) {\n      // The found page is fully visible, so we're actually either in case 3 or 4,\n      // and unfortunately we can't tell the difference between them without\n      // scanning the entire previous row, so we just conservatively assume that\n      // we do need to backtrack to that row. In both cases, the previous page is\n      // in the previous row, so use its top instead.\n      elt = views[index - 1].div;\n      pageTop = elt.offsetTop + elt.clientTop;\n    }\n\n    // Now we backtrack to the first page that still has its bottom below\n    // `pageTop`, which is the top of a page in the first visible row (unless\n    // we're in case 4, in which case it's the row before that).\n    // `index` is found by binary search, so the page at `index - 1` is\n    // invisible and we can start looking for potentially visible pages from\n    // `index - 2`. (However, if this loop terminates on its first iteration,\n    // which is the case when pages are stacked vertically, `index` should remain\n    // unchanged, so we use a distinct loop variable.)\n    for (let i = index - 2; i >= 0; --i) {\n      elt = views[i].div;\n      if (elt.offsetTop + elt.clientTop + elt.clientHeight <= pageTop) {\n        // We have reached the previous row, so stop now.\n        // This loop is expected to terminate relatively quickly because the\n        // number of pages per row is expected to be small.\n        break;\n      }\n      index = i;\n    }\n    return index;\n  }\n\n  /**\n   * @typedef {Object} GetVisibleElementsParameters\n   * @property {HTMLElement} scrollEl - A container that can possibly scroll.\n   * @property {Array} views - Objects with a `div` property that contains an\n   *   HTMLElement, which should all be descendants of `scrollEl` satisfying the\n   *   relevant layout assumptions.\n   * @property {boolean} sortByVisibility - If `true`, the returned elements are\n   *   sorted in descending order of the percent of their padding box that is\n   *   visible. The default value is `false`.\n   * @property {boolean} horizontal - If `true`, the elements are assumed to be\n   *   laid out horizontally instead of vertically. The default value is `false`.\n   * @property {boolean} rtl - If `true`, the `scrollEl` container is assumed to\n   *   be in right-to-left mode. The default value is `false`.\n   */\n\n  /**\n   * Generic helper to find out what elements are visible within a scroll pane.\n   *\n   * Well, pretty generic. There are some assumptions placed on the elements\n   * referenced by `views`:\n   *   - If `horizontal`, no left of any earlier element is to the right of the\n   *     left of any later element.\n   *   - Otherwise, `views` can be split into contiguous rows where, within a row,\n   *     no top of any element is below the bottom of any other element, and\n   *     between rows, no bottom of any element in an earlier row is below the\n   *     top of any element in a later row.\n   *\n   * (Here, top, left, etc. all refer to the padding edge of the element in\n   * question. For pages, that ends up being equivalent to the bounding box of the\n   * rendering canvas. Earlier and later refer to index in `views`, not page\n   * layout.)\n   *\n   * @param {GetVisibleElementsParameters}\n   * @returns {Object} `{ first, last, views: [{ id, x, y, view, percent }] }`\n   */\n  function getVisibleElements({\n    scrollEl,\n    views,\n    sortByVisibility = false,\n    horizontal = false,\n    rtl = false,\n  }) {\n    const top = scrollEl.scrollTop,\n      bottom = top + scrollEl.clientHeight;\n    const left = scrollEl.scrollLeft,\n      right = left + scrollEl.clientWidth;\n\n    // Throughout this \"generic\" function, comments will assume we're working with\n    // PDF document pages, which is the most important and complex case. In this\n    // case, the visible elements we're actually interested is the page canvas,\n    // which is contained in a wrapper which adds no padding/border/margin, which\n    // is itself contained in `view.div` which adds no padding (but does add a\n    // border). So, as specified in this function's doc comment, this function\n    // does all of its work on the padding edge of the provided views, starting at\n    // offsetLeft/Top (which includes margin) and adding clientLeft/Top (which is\n    // the border). Adding clientWidth/Height gets us the bottom-right corner of\n    // the padding edge.\n    function isElementBottomAfterViewTop(view) {\n      const element = view.div;\n      const elementBottom =\n        element.offsetTop + element.clientTop + element.clientHeight;\n      return elementBottom > top;\n    }\n    function isElementNextAfterViewHorizontally(view) {\n      const element = view.div;\n      const elementLeft = element.offsetLeft + element.clientLeft;\n      const elementRight = elementLeft + element.clientWidth;\n      return rtl ? elementLeft < right : elementRight > left;\n    }\n\n    const visible = [],\n      numViews = views.length;\n    let firstVisibleElementInd = binarySearchFirstItem(\n      views,\n      horizontal\n        ? isElementNextAfterViewHorizontally\n        : isElementBottomAfterViewTop\n    );\n\n    // Please note the return value of the `binarySearchFirstItem` function when\n    // no valid element is found (hence the `firstVisibleElementInd` check below).\n    if (\n      firstVisibleElementInd > 0 &&\n      firstVisibleElementInd < numViews &&\n      !horizontal\n    ) {\n      // In wrapped scrolling (or vertical scrolling with spreads), with some page\n      // sizes, isElementBottomAfterViewTop doesn't satisfy the binary search\n      // condition: there can be pages with bottoms above the view top between\n      // pages with bottoms below. This function detects and corrects that error;\n      // see it for more comments.\n      firstVisibleElementInd = backtrackBeforeAllVisibleElements(\n        firstVisibleElementInd,\n        views,\n        top\n      );\n    }\n\n    // lastEdge acts as a cutoff for us to stop looping, because we know all\n    // subsequent pages will be hidden.\n    //\n    // When using wrapped scrolling or vertical scrolling with spreads, we can't\n    // simply stop the first time we reach a page below the bottom of the view;\n    // the tops of subsequent pages on the same row could still be visible. In\n    // horizontal scrolling, we don't have that issue, so we can stop as soon as\n    // we pass `right`, without needing the code below that handles the -1 case.\n    let lastEdge = horizontal ? right : -1;\n\n    for (let i = firstVisibleElementInd; i < numViews; i++) {\n      const view = views[i],\n        element = view.div;\n      const currentWidth = element.offsetLeft + element.clientLeft;\n      const currentHeight = element.offsetTop + element.clientTop;\n      const viewWidth = element.clientWidth,\n        viewHeight = element.clientHeight;\n      const viewRight = currentWidth + viewWidth;\n      const viewBottom = currentHeight + viewHeight;\n\n      if (lastEdge === -1) {\n        // As commented above, this is only needed in non-horizontal cases.\n        // Setting lastEdge to the bottom of the first page that is partially\n        // visible ensures that the next page fully below lastEdge is on the\n        // next row, which has to be fully hidden along with all subsequent rows.\n        if (viewBottom >= bottom) {\n          lastEdge = viewBottom;\n        }\n      } else if ((horizontal ? currentWidth : currentHeight) > lastEdge) {\n        break;\n      }\n\n      if (\n        viewBottom <= top ||\n        currentHeight >= bottom ||\n        viewRight <= left ||\n        currentWidth >= right\n      ) {\n        continue;\n      }\n\n      const hiddenHeight =\n        Math.max(0, top - currentHeight) + Math.max(0, viewBottom - bottom);\n      const hiddenWidth =\n        Math.max(0, left - currentWidth) + Math.max(0, viewRight - right);\n\n      const fractionHeight = (viewHeight - hiddenHeight) / viewHeight,\n        fractionWidth = (viewWidth - hiddenWidth) / viewWidth;\n      const percent = (fractionHeight * fractionWidth * 100) | 0;\n\n      visible.push({\n        id: view.id,\n        x: currentWidth,\n        y: currentHeight,\n        view,\n        percent,\n        widthPercent: (fractionWidth * 100) | 0,\n      });\n    }\n\n    const first = visible[0],\n      last = visible[visible.length - 1];\n\n    if (sortByVisibility) {\n      visible.sort(function (a, b) {\n        const pc = a.percent - b.percent;\n        if (Math.abs(pc) > 0.001) {\n          return -pc;\n        }\n        return a.id - b.id; // ensure stability\n      });\n    }\n    return { first, last, views: visible };\n  }\n\n  /**\n   * Event handler to suppress context menu.\n   */\n  function noContextMenuHandler(evt) {\n    evt.preventDefault();\n  }\n\n  function isDataSchema(url) {\n    let i = 0;\n    const ii = url.length;\n    while (i < ii && url[i].trim() === \"\") {\n      i++;\n    }\n    return url.substring(i, i + 5).toLowerCase() === \"data:\";\n  }\n\n  /**\n   * Returns the filename or guessed filename from the url (see issue 3455).\n   * @param {string} url - The original PDF location.\n   * @param {string} defaultFilename - The value returned if the filename is\n   *   unknown, or the protocol is unsupported.\n   * @returns {string} Guessed PDF filename.\n   */\n  function getPDFFileNameFromURL(url, defaultFilename = \"document.pdf\") {\n    if (typeof url !== \"string\") {\n      return defaultFilename;\n    }\n    if (isDataSchema(url)) {\n      console.warn(\n        \"getPDFFileNameFromURL: \" +\n          'ignoring \"data:\" URL for performance reasons.'\n      );\n      return defaultFilename;\n    }\n    const reURI = /^(?:(?:[^:]+:)?\\/\\/[^/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/;\n    //              SCHEME        HOST        1.PATH  2.QUERY   3.REF\n    // Pattern to get last matching NAME.pdf\n    const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n    const splitURI = reURI.exec(url);\n    let suggestedFilename =\n      reFilename.exec(splitURI[1]) ||\n      reFilename.exec(splitURI[2]) ||\n      reFilename.exec(splitURI[3]);\n    if (suggestedFilename) {\n      suggestedFilename = suggestedFilename[0];\n      if (suggestedFilename.includes(\"%\")) {\n        // URL-encoded %2Fpath%2Fto%2Ffile.pdf should be file.pdf\n        try {\n          suggestedFilename = reFilename.exec(\n            decodeURIComponent(suggestedFilename)\n          )[0];\n        } catch (ex) {\n          // Possible (extremely rare) errors:\n          // URIError \"Malformed URI\", e.g. for \"%AA.pdf\"\n          // TypeError \"null has no properties\", e.g. for \"%2F.pdf\"\n        }\n      }\n    }\n    return suggestedFilename || defaultFilename;\n  }\n\n  function normalizeWheelEventDirection(evt) {\n    let delta = Math.sqrt(evt.deltaX * evt.deltaX + evt.deltaY * evt.deltaY);\n    const angle = Math.atan2(evt.deltaY, evt.deltaX);\n    if (-0.25 * Math.PI < angle && angle < 0.75 * Math.PI) {\n      // All that is left-up oriented has to change the sign.\n      delta = -delta;\n    }\n    return delta;\n  }\n\n  function normalizeWheelEventDelta(evt) {\n    let delta = normalizeWheelEventDirection(evt);\n\n    const MOUSE_DOM_DELTA_PIXEL_MODE = 0;\n    const MOUSE_DOM_DELTA_LINE_MODE = 1;\n    const MOUSE_PIXELS_PER_LINE = 30;\n    const MOUSE_LINES_PER_PAGE = 30;\n\n    // Converts delta to per-page units\n    if (evt.deltaMode === MOUSE_DOM_DELTA_PIXEL_MODE) {\n      delta /= MOUSE_PIXELS_PER_LINE * MOUSE_LINES_PER_PAGE;\n    } else if (evt.deltaMode === MOUSE_DOM_DELTA_LINE_MODE) {\n      delta /= MOUSE_LINES_PER_PAGE;\n    }\n    return delta;\n  }\n\n  function isValidRotation(angle) {\n    return Number.isInteger(angle) && angle % 90 === 0;\n  }\n\n  function isValidScrollMode(mode) {\n    return (\n      Number.isInteger(mode) &&\n      Object.values(ScrollMode).includes(mode) &&\n      mode !== ScrollMode.UNKNOWN\n    );\n  }\n\n  function isValidSpreadMode(mode) {\n    return (\n      Number.isInteger(mode) &&\n      Object.values(SpreadMode).includes(mode) &&\n      mode !== SpreadMode.UNKNOWN\n    );\n  }\n\n  function isPortraitOrientation(size) {\n    return size.width <= size.height;\n  }\n\n  const WaitOnType = {\n    EVENT: \"event\",\n    TIMEOUT: \"timeout\",\n  };\n\n  /**\n   * @typedef {Object} WaitOnEventOrTimeoutParameters\n   * @property {Object} target - The event target, can for example be:\n   *   `window`, `document`, a DOM element, or an {EventBus} instance.\n   * @property {string} name - The name of the event.\n   * @property {number} delay - The delay, in milliseconds, after which the\n   *   timeout occurs (if the event wasn't already dispatched).\n   */\n\n  /**\n   * Allows waiting for an event or a timeout, whichever occurs first.\n   * Can be used to ensure that an action always occurs, even when an event\n   * arrives late or not at all.\n   *\n   * @param {WaitOnEventOrTimeoutParameters}\n   * @returns {Promise} A promise that is resolved with a {WaitOnType} value.\n   */\n  function waitOnEventOrTimeout({ target, name, delay = 0 }) {\n    return new Promise(function (resolve, reject) {\n      if (\n        typeof target !== \"object\" ||\n        !(name && typeof name === \"string\") ||\n        !(Number.isInteger(delay) && delay >= 0)\n      ) {\n        throw new Error(\"waitOnEventOrTimeout - invalid parameters.\");\n      }\n\n      function handler(type) {\n        if (target instanceof EventBus) {\n          target._off(name, eventHandler);\n        } else {\n          target.removeEventListener(name, eventHandler);\n        }\n\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n        resolve(type);\n      }\n\n      const eventHandler = handler.bind(null, WaitOnType.EVENT);\n      if (target instanceof EventBus) {\n        target._on(name, eventHandler);\n      } else {\n        target.addEventListener(name, eventHandler);\n      }\n\n      const timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);\n      const timeout = setTimeout(timeoutHandler, delay);\n    });\n  }\n\n  /**\n   * Promise that is resolved when DOM window becomes visible.\n   */\n  const animationStarted = new Promise(function (resolve) {\n    if (\n      typeof PDFJSDev !== \"undefined\" &&\n      PDFJSDev.test(\"LIB && TESTING\") &&\n      typeof window === \"undefined\"\n    ) {\n      // Prevent \"ReferenceError: window is not defined\" errors when running the\n      // unit-tests in Node.js/Travis.\n      setTimeout(resolve, 20);\n      return;\n    }\n    window.requestAnimationFrame(resolve);\n  });\n\n  /**\n   * NOTE: Only used to support various PDF viewer tests in `mozilla-central`.\n   */\n  function dispatchDOMEvent(eventName, args = null) {\n    if (typeof PDFJSDev !== \"undefined\" && !PDFJSDev.test(\"MOZCENTRAL\")) {\n      throw new Error(\"Not implemented: dispatchDOMEvent\");\n    }\n    const details = Object.create(null);\n    if (args && args.length > 0) {\n      const obj = args[0];\n      for (const key in obj) {\n        const value = obj[key];\n        if (key === \"source\") {\n          if (value === window || value === document) {\n            return; // No need to re-dispatch (already) global events.\n          }\n          continue; // Ignore the `source` property.\n        }\n        details[key] = value;\n      }\n    }\n    const event = document.createEvent(\"CustomEvent\");\n    event.initCustomEvent(eventName, true, true, details);\n    document.dispatchEvent(event);\n  }\n\n  /**\n   * Simple event bus for an application. Listeners are attached using the `on`\n   * and `off` methods. To raise an event, the `dispatch` method shall be used.\n   */\n  class EventBus {\n    constructor(options) {\n      this._listeners = Object.create(null);\n\n      if (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"MOZCENTRAL\")) {\n        ///this._isInAutomation = options?.isInAutomation === true; // lwf\n        this._isInAutomation = options && (options.isInAutomation === true);\n      }\n    }\n\n    /**\n     * @param {string} eventName\n     * @param {function} listener\n     * @param {Object} [options]\n     */\n    on(eventName, listener, options = null) {\n      this._on(eventName, listener, {\n        external: true,\n        ///once: options?.once, // lwf\n        once: options && options.once, \n      });\n    }\n\n    /**\n     * @param {string} eventName\n     * @param {function} listener\n     * @param {Object} [options]\n     */\n    off(eventName, listener, options = null) {\n      this._off(eventName, listener, {\n        external: true,\n        ///once: options?.once, // lwf\n        once: options && options.once, \n      });\n    }\n\n    dispatch(eventName) {\n      const eventListeners = this._listeners[eventName];\n      if (!eventListeners || eventListeners.length === 0) {\n        if (\n          (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"MOZCENTRAL\")) &&\n          this._isInAutomation\n        ) {\n          const args = Array.prototype.slice.call(arguments, 1);\n          dispatchDOMEvent(eventName, args);\n        }\n        return;\n      }\n      // Passing all arguments after the eventName to the listeners.\n      const args = Array.prototype.slice.call(arguments, 1);\n      let externalListeners;\n      // Making copy of the listeners array in case if it will be modified\n      // during dispatch.\n      eventListeners.slice(0).forEach(({ listener, external, once }) => {\n        if (once) {\n          this._off(eventName, listener);\n        }\n        if (external) {\n          ///(externalListeners ||= []).push(listener); // lwf \n          (externalListeners || (externalListeners = [])).push(listener);\n          return;\n        }\n        listener.apply(null, args);\n      });\n      // Dispatch any \"external\" listeners *after* the internal ones, to give the\n      // viewer components time to handle events and update their state first.\n      if (externalListeners) {\n        externalListeners.forEach(listener => {\n          listener.apply(null, args);\n        });\n        externalListeners = null;\n      }\n      if (\n        (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"MOZCENTRAL\")) &&\n        this._isInAutomation\n      ) {\n        dispatchDOMEvent(eventName, args);\n      }\n    }\n\n    /**\n     * @ignore\n     */\n    _on(eventName, listener, options = null) {\n      ///const eventListeners = (this._listeners[eventName] ||= []); // lwf\n      const eventListeners = (this._listeners[eventName] || (this._listeners[eventName]= []));\n      eventListeners.push({\n        listener,\n        ///external: options?.external === true, // lwf\n        ///once: options?.once === true,         // lwf\n        external: options && options.external === true, \n        once: options && options.once === true,     \n      });\n    }\n\n    /**\n     * @ignore\n     */\n    _off(eventName, listener, options = null) {\n      const eventListeners = this._listeners[eventName];\n      if (!eventListeners) {\n        return;\n      }\n      for (let i = 0, ii = eventListeners.length; i < ii; i++) {\n        if (eventListeners[i].listener === listener) {\n          eventListeners.splice(i, 1);\n          return;\n        }\n      }\n    }\n  }\n\n  function clamp(v, min, max) {\n    return Math.min(Math.max(v, min), max);\n  }\n\n  class ProgressBar {\n    constructor(id, { height, width, units } = {}) {\n      this.visible = true;\n\n      // Fetch the sub-elements for later.\n      this.div = document.querySelector(id + \" .progress\");\n      // Get the loading bar element, so it can be resized to fit the viewer.\n      this.bar = this.div.parentNode;\n\n      // Get options, with sensible defaults.\n      this.height = height || 100;\n      this.width = width || 100;\n      this.units = units || \"%\";\n\n      // Initialize heights.\n      this.div.style.height = this.height + this.units;\n      this.percent = 0;\n    }\n\n    _updateBar() {\n      if (this._indeterminate) {\n        this.div.classList.add(\"indeterminate\");\n        this.div.style.width = this.width + this.units;\n        return;\n      }\n\n      this.div.classList.remove(\"indeterminate\");\n      const progressSize = (this.width * this._percent) / 100;\n      this.div.style.width = progressSize + this.units;\n    }\n\n    get percent() {\n      return this._percent;\n    }\n\n    set percent(val) {\n      this._indeterminate = isNaN(val);\n      this._percent = clamp(val, 0, 100);\n      this._updateBar();\n    }\n\n    setWidth(viewer) {\n      if (!viewer) {\n        return;\n      }\n      const container = viewer.parentNode;\n      const scrollbarWidth = container.offsetWidth - viewer.offsetWidth;\n      if (scrollbarWidth > 0) {\n        const doc = document.documentElement;\n        doc.style.setProperty(LOADINGBAR_END_OFFSET_VAR, `${scrollbarWidth}px`);\n      }\n    }\n\n    hide() {\n      if (!this.visible) {\n        return;\n      }\n      this.visible = false;\n      this.bar.classList.add(\"hidden\");\n    }\n\n    show() {\n      if (this.visible) {\n        return;\n      }\n      this.visible = true;\n      this.bar.classList.remove(\"hidden\");\n    }\n  }\n\n  /**\n   * Moves all elements of an array that satisfy condition to the end of the\n   * array, preserving the order of the rest.\n   */\n  function moveToEndOfArray(arr, condition) {\n    const moved = [],\n      len = arr.length;\n    let write = 0;\n    for (let read = 0; read < len; ++read) {\n      if (condition(arr[read])) {\n        moved.push(arr[read]);\n      } else {\n        arr[write] = arr[read];\n        ++write;\n      }\n    }\n    for (let read = 0; write < len; ++read, ++write) {\n      arr[write] = moved[read];\n    }\n  }\n\n  /**\n   * Get the active or focused element in current DOM.\n   *\n   * Recursively search for the truly active or focused element in case there are\n   * shadow DOMs.\n   *\n   * @returns {Element} the truly active or focused element.\n   */\n  function getActiveOrFocusedElement() {\n    let curRoot = document;\n    let curActiveOrFocused =\n      curRoot.activeElement || curRoot.querySelector(\":focus\");\n\n    while (curActiveOrFocused && curActiveOrFocused.shadowRoot) {\n      curRoot = curActiveOrFocused.shadowRoot;\n      curActiveOrFocused =\n        curRoot.activeElement || curRoot.querySelector(\":focus\");\n    }\n\n    return curActiveOrFocused;\n  }\n\n  return {\n    animationStarted,\n    approximateFraction,\n    AutoPrintRegExp,\n    backtrackBeforeAllVisibleElements, // only exported for testing\n    binarySearchFirstItem,\n    CSS_UNITS,\n    DEFAULT_SCALE,\n    DEFAULT_SCALE_VALUE,\n    EventBus,\n    getActiveOrFocusedElement,\n    getOutputScale,\n    getPageSizeInches,\n    getPDFFileNameFromURL,\n    getVisibleElements,\n    isPortraitOrientation,\n    isValidRotation,\n    isValidScrollMode,\n    isValidSpreadMode,\n    MAX_AUTO_SCALE,\n    MAX_SCALE,\n    MIN_SCALE,\n    moveToEndOfArray,\n    noContextMenuHandler,\n    normalizeWheelEventDelta,\n    normalizeWheelEventDirection,\n    NullL10n,\n    parseQueryString,\n    PresentationModeState,\n    ProgressBar,\n    RendererType,\n    roundToDivide,\n    SCROLLBAR_PADDING,\n    scrollIntoView,\n    ScrollMode,\n    SidebarView,\n    SpreadMode,\n    TextLayerMode,\n    UNKNOWN_SCALE,\n    VERTICAL_PADDING,\n    waitOnEventOrTimeout,\n    WaitOnType,\n    watchScroll,\n  };\n});\ndefine('skylark-pdfjs-viewer/grab_to_pan',[],function(){\n  /* Copyright 2013 Rob Wu <rob@robwu.nl>\n   * https://github.com/Rob--W/grab-to-pan.js\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  /**\n   * Construct a GrabToPan instance for a given HTML element.\n   * @param options.element {Element}\n   * @param options.ignoreTarget {function} optional. See `ignoreTarget(node)`\n   * @param options.onActiveChanged {function(boolean)} optional. Called\n   *  when grab-to-pan is (de)activated. The first argument is a boolean that\n   *  shows whether grab-to-pan is activated.\n   */\n  function GrabToPan(options) {\n    this.element = options.element;\n    this.document = options.element.ownerDocument;\n    if (typeof options.ignoreTarget === \"function\") {\n      this.ignoreTarget = options.ignoreTarget;\n    }\n    this.onActiveChanged = options.onActiveChanged;\n\n    // Bind the contexts to ensure that `this` always points to\n    // the GrabToPan instance.\n    this.activate = this.activate.bind(this);\n    this.deactivate = this.deactivate.bind(this);\n    this.toggle = this.toggle.bind(this);\n    this._onmousedown = this._onmousedown.bind(this);\n    this._onmousemove = this._onmousemove.bind(this);\n    this._endPan = this._endPan.bind(this);\n\n    // This overlay will be inserted in the document when the mouse moves during\n    // a grab operation, to ensure that the cursor has the desired appearance.\n    const overlay = (this.overlay = document.createElement(\"div\"));\n    overlay.className = \"grab-to-pan-grabbing\";\n  }\n  GrabToPan.prototype = {\n    /**\n     * Class name of element which can be grabbed\n     */\n    CSS_CLASS_GRAB: \"grab-to-pan-grab\",\n\n    /**\n     * Bind a mousedown event to the element to enable grab-detection.\n     */\n    activate: function GrabToPan_activate() {\n      if (!this.active) {\n        this.active = true;\n        this.element.addEventListener(\"mousedown\", this._onmousedown, true);\n        this.element.classList.add(this.CSS_CLASS_GRAB);\n        if (this.onActiveChanged) {\n          this.onActiveChanged(true);\n        }\n      }\n    },\n\n    /**\n     * Removes all events. Any pending pan session is immediately stopped.\n     */\n    deactivate: function GrabToPan_deactivate() {\n      if (this.active) {\n        this.active = false;\n        this.element.removeEventListener(\"mousedown\", this._onmousedown, true);\n        this._endPan();\n        this.element.classList.remove(this.CSS_CLASS_GRAB);\n        if (this.onActiveChanged) {\n          this.onActiveChanged(false);\n        }\n      }\n    },\n\n    toggle: function GrabToPan_toggle() {\n      if (this.active) {\n        this.deactivate();\n      } else {\n        this.activate();\n      }\n    },\n\n    /**\n     * Whether to not pan if the target element is clicked.\n     * Override this method to change the default behaviour.\n     *\n     * @param node {Element} The target of the event\n     * @returns {boolean} Whether to not react to the click event.\n     */\n    ignoreTarget: function GrabToPan_ignoreTarget(node) {\n      // Use matchesSelector to check whether the clicked element\n      // is (a child of) an input element / link\n      return node[matchesSelector](\n        \"a[href], a[href] *, input, textarea, button, button *, select, option\"\n      );\n    },\n\n    /**\n     * @private\n     */\n    _onmousedown: function GrabToPan__onmousedown(event) {\n      if (event.button !== 0 || this.ignoreTarget(event.target)) {\n        return;\n      }\n      if (event.originalTarget) {\n        try {\n          // eslint-disable-next-line no-unused-expressions\n          event.originalTarget.tagName;\n        } catch (e) {\n          // Mozilla-specific: element is a scrollbar (XUL element)\n          return;\n        }\n      }\n\n      this.scrollLeftStart = this.element.scrollLeft;\n      this.scrollTopStart = this.element.scrollTop;\n      this.clientXStart = event.clientX;\n      this.clientYStart = event.clientY;\n      this.document.addEventListener(\"mousemove\", this._onmousemove, true);\n      this.document.addEventListener(\"mouseup\", this._endPan, true);\n      // When a scroll event occurs before a mousemove, assume that the user\n      // dragged a scrollbar (necessary for Opera Presto, Safari and IE)\n      // (not needed for Chrome/Firefox)\n      this.element.addEventListener(\"scroll\", this._endPan, true);\n      event.preventDefault();\n      event.stopPropagation();\n\n      const focusedElement = document.activeElement;\n      if (focusedElement && !focusedElement.contains(event.target)) {\n        focusedElement.blur();\n      }\n    },\n\n    /**\n     * @private\n     */\n    _onmousemove: function GrabToPan__onmousemove(event) {\n      this.element.removeEventListener(\"scroll\", this._endPan, true);\n      if (isLeftMouseReleased(event)) {\n        this._endPan();\n        return;\n      }\n      const xDiff = event.clientX - this.clientXStart;\n      const yDiff = event.clientY - this.clientYStart;\n      const scrollTop = this.scrollTopStart - yDiff;\n      const scrollLeft = this.scrollLeftStart - xDiff;\n      if (this.element.scrollTo) {\n        this.element.scrollTo({\n          top: scrollTop,\n          left: scrollLeft,\n          behavior: \"instant\",\n        });\n      } else {\n        this.element.scrollTop = scrollTop;\n        this.element.scrollLeft = scrollLeft;\n      }\n      if (!this.overlay.parentNode) {\n        document.body.appendChild(this.overlay);\n      }\n    },\n\n    /**\n     * @private\n     */\n    _endPan: function GrabToPan__endPan() {\n      this.element.removeEventListener(\"scroll\", this._endPan, true);\n      this.document.removeEventListener(\"mousemove\", this._onmousemove, true);\n      this.document.removeEventListener(\"mouseup\", this._endPan, true);\n      // Note: ChildNode.remove doesn't throw if the parentNode is undefined.\n      this.overlay.remove();\n    },\n  };\n\n  // Get the correct (vendor-prefixed) name of the matches method.\n  let matchesSelector;\n  [\"webkitM\", \"mozM\", \"m\"].some(function (prefix) {\n    let name = prefix + \"atches\";\n    if (name in document.documentElement) {\n      matchesSelector = name;\n    }\n    name += \"Selector\";\n    if (name in document.documentElement) {\n      matchesSelector = name;\n    }\n    return matchesSelector; // If found, then truthy, and [].some() ends.\n  });\n\n  // Browser sniffing because it's impossible to feature-detect\n  // whether event.which for onmousemove is reliable\n  const isNotIEorIsIE10plus = !document.documentMode || document.documentMode > 9;\n  const chrome = window.chrome;\n  const isChrome15OrOpera15plus = chrome && (chrome.webstore || chrome.app);\n  //                                         ^ Chrome 15+       ^ Opera 15+\n  const isSafari6plus =\n    /Apple/.test(navigator.vendor) &&\n    /Version\\/([6-9]\\d*|[1-5]\\d+)/.test(navigator.userAgent);\n\n  /**\n   * Whether the left mouse is not pressed.\n   * @param event {MouseEvent}\n   * @returns {boolean} True if the left mouse button is not pressed,\n   *                    False if unsure or if the left mouse button is pressed.\n   */\n  function isLeftMouseReleased(event) {\n    if (\"buttons\" in event && isNotIEorIsIE10plus) {\n      // http://www.w3.org/TR/DOM-Level-3-Events/#events-MouseEvent-buttons\n      // Firefox 15+\n      // Internet Explorer 10+\n      return !(event.buttons & 1);\n    }\n    if (isChrome15OrOpera15plus || isSafari6plus) {\n      // Chrome 14+\n      // Opera 15+\n      // Safari 6.0+\n      return event.which === 0;\n    }\n    return false;\n  }\n\n  return { GrabToPan };\n});\ndefine('skylark-pdfjs-viewer/pdf_cursor_tools',[\n  \"./ui_utils\",\n  \"./grab_to_pan\"\n],function(ui_utils,grab_to_pan){\n  /* Copyright 2017 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { GrabToPan } = grab_to_pan;\n  const { PresentationModeState } = ui_utils;\n\n  const CursorTool = {\n    SELECT: 0, // The default value.\n    HAND: 1,\n    ZOOM: 2,\n  };\n\n  /**\n   * @typedef {Object} PDFCursorToolsOptions\n   * @property {HTMLDivElement} container - The document container.\n   * @property {EventBus} eventBus - The application event bus.\n   * @property {number} [cursorToolOnLoad] - The cursor tool that will be enabled\n   *   on load; the constants from {CursorTool} should be used. The default value\n   *   is `CursorTool.SELECT`.\n   */\n\n  class PDFCursorTools {\n    /**\n     * @param {PDFCursorToolsOptions} options\n     */\n    constructor({ container, eventBus, cursorToolOnLoad = CursorTool.SELECT }) {\n      this.container = container;\n      this.eventBus = eventBus;\n\n      this.active = CursorTool.SELECT;\n      this.activeBeforePresentationMode = null;\n\n      this.handTool = new GrabToPan({\n        element: this.container,\n      });\n\n      this._addEventListeners();\n\n      // Defer the initial `switchTool` call, to give other viewer components\n      // time to initialize *and* register 'cursortoolchanged' event listeners.\n      Promise.resolve().then(() => {\n        this.switchTool(cursorToolOnLoad);\n      });\n    }\n\n    /**\n     * @type {number} One of the values in {CursorTool}.\n     */\n    get activeTool() {\n      return this.active;\n    }\n\n    /**\n     * NOTE: This method is ignored while Presentation Mode is active.\n     * @param {number} tool - The cursor mode that should be switched to,\n     *                        must be one of the values in {CursorTool}.\n     */\n    switchTool(tool) {\n      if (this.activeBeforePresentationMode !== null) {\n        return; // Cursor tools cannot be used in Presentation Mode.\n      }\n      if (tool === this.active) {\n        return; // The requested tool is already active.\n      }\n\n      const disableActiveTool = () => {\n        switch (this.active) {\n          case CursorTool.SELECT:\n            break;\n          case CursorTool.HAND:\n            this.handTool.deactivate();\n            break;\n          case CursorTool.ZOOM:\n          /* falls through */\n        }\n      };\n\n      // Enable the new cursor tool.\n      switch (tool) {\n        case CursorTool.SELECT:\n          disableActiveTool();\n          break;\n        case CursorTool.HAND:\n          disableActiveTool();\n          this.handTool.activate();\n          break;\n        case CursorTool.ZOOM:\n        /* falls through */\n        default:\n          console.error(`switchTool: \"${tool}\" is an unsupported value.`);\n          return;\n      }\n      // Update the active tool *after* it has been validated above,\n      // in order to prevent setting it to an invalid state.\n      this.active = tool;\n\n      this._dispatchEvent();\n    }\n\n    /**\n     * @private\n     */\n    _dispatchEvent() {\n      this.eventBus.dispatch(\"cursortoolchanged\", {\n        source: this,\n        tool: this.active,\n      });\n    }\n\n    /**\n     * @private\n     */\n    _addEventListeners() {\n      this.eventBus._on(\"switchcursortool\", evt => {\n        this.switchTool(evt.tool);\n      });\n\n      this.eventBus._on(\"presentationmodechanged\", evt => {\n        switch (evt.state) {\n          case PresentationModeState.CHANGING:\n            break;\n          case PresentationModeState.FULLSCREEN: {\n            const previouslyActive = this.active;\n\n            this.switchTool(CursorTool.SELECT);\n            this.activeBeforePresentationMode = previouslyActive;\n            break;\n          }\n          case PresentationModeState.NORMAL: {\n            const previouslyActive = this.activeBeforePresentationMode;\n\n            this.activeBeforePresentationMode = null;\n            this.switchTool(previouslyActive);\n            break;\n          }\n        }\n      });\n    }\n  }\n\n  return { CursorTool, PDFCursorTools };\n});\ndefine('skylark-pdfjs-viewer/pdf_rendering_queue',[\n  \"skylark-pdfjs-display\"\n],function(pdfjsLib){\n  /* Copyright 2012 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { RenderingCancelledException } = pdfjsLib;\n\n  const CLEANUP_TIMEOUT = 30000;\n\n  const RenderingStates = {\n    INITIAL: 0,\n    RUNNING: 1,\n    PAUSED: 2,\n    FINISHED: 3,\n  };\n\n  /**\n   * Controls rendering of the views for pages and thumbnails.\n   */\n  class PDFRenderingQueue {\n    constructor() {\n      this.pdfViewer = null;\n      this.pdfThumbnailViewer = null;\n      this.onIdle = null;\n      this.highestPriorityPage = null;\n      this.idleTimeout = null;\n      this.printing = false;\n      this.isThumbnailViewEnabled = false;\n    }\n\n    /**\n     * @param {PDFViewer} pdfViewer\n     */\n    setViewer(pdfViewer) {\n      this.pdfViewer = pdfViewer;\n    }\n\n    /**\n     * @param {PDFThumbnailViewer} pdfThumbnailViewer\n     */\n    setThumbnailViewer(pdfThumbnailViewer) {\n      this.pdfThumbnailViewer = pdfThumbnailViewer;\n    }\n\n    /**\n     * @param {IRenderableView} view\n     * @returns {boolean}\n     */\n    isHighestPriority(view) {\n      return this.highestPriorityPage === view.renderingId;\n    }\n\n    /**\n     * @param {Object} currentlyVisiblePages\n     */\n    renderHighestPriority(currentlyVisiblePages) {\n      if (this.idleTimeout) {\n        clearTimeout(this.idleTimeout);\n        this.idleTimeout = null;\n      }\n\n      // Pages have a higher priority than thumbnails, so check them first.\n      if (this.pdfViewer.forceRendering(currentlyVisiblePages)) {\n        return;\n      }\n      // No pages needed rendering, so check thumbnails.\n      if (this.pdfThumbnailViewer && this.isThumbnailViewEnabled) {\n        if (this.pdfThumbnailViewer.forceRendering()) {\n          return;\n        }\n      }\n\n      if (this.printing) {\n        // If printing is currently ongoing do not reschedule cleanup.\n        return;\n      }\n\n      if (this.onIdle) {\n        this.idleTimeout = setTimeout(this.onIdle.bind(this), CLEANUP_TIMEOUT);\n      }\n    }\n\n    /**\n     * @param {Object} visible\n     * @param {Array} views\n     * @param {boolean} scrolledDown\n     */\n    getHighestPriority(visible, views, scrolledDown) {\n      /**\n       * The state has changed. Figure out which page has the highest priority to\n       * render next (if any).\n       *\n       * Priority:\n       * 1. visible pages\n       * 2. if last scrolled down, the page after the visible pages, or\n       *    if last scrolled up, the page before the visible pages\n       */\n      const visibleViews = visible.views;\n\n      const numVisible = visibleViews.length;\n      if (numVisible === 0) {\n        return null;\n      }\n      for (let i = 0; i < numVisible; ++i) {\n        const view = visibleViews[i].view;\n        if (!this.isViewFinished(view)) {\n          return view;\n        }\n      }\n\n      // All the visible views have rendered; try to render next/previous pages.\n      if (scrolledDown) {\n        const nextPageIndex = visible.last.id;\n        // IDs start at 1, so no need to add 1.\n        if (views[nextPageIndex] && !this.isViewFinished(views[nextPageIndex])) {\n          return views[nextPageIndex];\n        }\n      } else {\n        const previousPageIndex = visible.first.id - 2;\n        if (\n          views[previousPageIndex] &&\n          !this.isViewFinished(views[previousPageIndex])\n        ) {\n          return views[previousPageIndex];\n        }\n      }\n      // Everything that needs to be rendered has been.\n      return null;\n    }\n\n    /**\n     * @param {IRenderableView} view\n     * @returns {boolean}\n     */\n    isViewFinished(view) {\n      return view.renderingState === RenderingStates.FINISHED;\n    }\n\n    /**\n     * Render a page or thumbnail view. This calls the appropriate function\n     * based on the views state. If the view is already rendered it will return\n     * `false`.\n     *\n     * @param {IRenderableView} view\n     */\n    renderView(view) {\n      switch (view.renderingState) {\n        case RenderingStates.FINISHED:\n          return false;\n        case RenderingStates.PAUSED:\n          this.highestPriorityPage = view.renderingId;\n          view.resume();\n          break;\n        case RenderingStates.RUNNING:\n          this.highestPriorityPage = view.renderingId;\n          break;\n        case RenderingStates.INITIAL:\n          this.highestPriorityPage = view.renderingId;\n          view\n            .draw()\n            .finally(() => {\n              this.renderHighestPriority();\n            })\n            .catch(reason => {\n              if (reason instanceof RenderingCancelledException) {\n                return;\n              }\n              console.error(`renderView: \"${reason}\"`);\n            });\n          break;\n      }\n      return true;\n    }\n  }\n\n  return { \n    PDFRenderingQueue, \n    RenderingStates \n  };\n});\ndefine('skylark-pdfjs-viewer/overlay_manager',[],function(){\n  /* Copyright 2014 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  class OverlayManager {\n    constructor() {\n      this._overlays = {};\n      this._active = null;\n      this._keyDownBound = this._keyDown.bind(this);\n    }\n\n    get active() {\n      return this._active;\n    }\n\n    /**\n     * @param {string} name - The name of the overlay that is registered.\n     * @param {HTMLDivElement} element - The overlay's DOM element.\n     * @param {function} [callerCloseMethod] - The method that, if present, calls\n     *                   `OverlayManager.close` from the object registering the\n     *                   overlay. Access to this method is necessary in order to\n     *                   run cleanup code when e.g. the overlay is force closed.\n     *                   The default is `null`.\n     * @param {boolean} [canForceClose] - Indicates if opening the overlay closes\n     *                  an active overlay. The default is `false`.\n     * @returns {Promise} A promise that is resolved when the overlay has been\n     *                    registered.\n     */\n    async register(\n      name,\n      element,\n      callerCloseMethod = null,\n      canForceClose = false\n    ) {\n      let container;\n      if (!name || !element || !(container = element.parentNode)) {\n        throw new Error(\"Not enough parameters.\");\n      } else if (this._overlays[name]) {\n        throw new Error(\"The overlay is already registered.\");\n      }\n      this._overlays[name] = {\n        element,\n        container,\n        callerCloseMethod,\n        canForceClose,\n      };\n    }\n\n    /**\n     * @param {string} name - The name of the overlay that is unregistered.\n     * @returns {Promise} A promise that is resolved when the overlay has been\n     *                    unregistered.\n     */\n    async unregister(name) {\n      if (!this._overlays[name]) {\n        throw new Error(\"The overlay does not exist.\");\n      } else if (this._active === name) {\n        throw new Error(\"The overlay cannot be removed while it is active.\");\n      }\n      delete this._overlays[name];\n    }\n\n    /**\n     * @param {string} name - The name of the overlay that should be opened.\n     * @returns {Promise} A promise that is resolved when the overlay has been\n     *                    opened.\n     */\n    async open(name) {\n      if (!this._overlays[name]) {\n        throw new Error(\"The overlay does not exist.\");\n      } else if (this._active) {\n        if (this._overlays[name].canForceClose) {\n          this._closeThroughCaller();\n        } else if (this._active === name) {\n          throw new Error(\"The overlay is already active.\");\n        } else {\n          throw new Error(\"Another overlay is currently active.\");\n        }\n      }\n      this._active = name;\n      this._overlays[this._active].element.classList.remove(\"hidden\");\n      this._overlays[this._active].container.classList.remove(\"hidden\");\n\n      window.addEventListener(\"keydown\", this._keyDownBound);\n    }\n\n    /**\n     * @param {string} name - The name of the overlay that should be closed.\n     * @returns {Promise} A promise that is resolved when the overlay has been\n     *                    closed.\n     */\n    async close(name) {\n      if (!this._overlays[name]) {\n        throw new Error(\"The overlay does not exist.\");\n      } else if (!this._active) {\n        throw new Error(\"The overlay is currently not active.\");\n      } else if (this._active !== name) {\n        throw new Error(\"Another overlay is currently active.\");\n      }\n      this._overlays[this._active].container.classList.add(\"hidden\");\n      this._overlays[this._active].element.classList.add(\"hidden\");\n      this._active = null;\n\n      window.removeEventListener(\"keydown\", this._keyDownBound);\n    }\n\n    /**\n     * @private\n     */\n    _keyDown(evt) {\n      if (this._active && evt.keyCode === /* Esc = */ 27) {\n        this._closeThroughCaller();\n        evt.preventDefault();\n      }\n    }\n\n    /**\n     * @private\n     */\n    _closeThroughCaller() {\n      if (this._overlays[this._active].callerCloseMethod) {\n        this._overlays[this._active].callerCloseMethod();\n      }\n      if (this._active) {\n        this.close(this._active);\n      }\n    }\n  }\n\n  return { OverlayManager };\n});\ndefine('skylark-pdfjs-viewer/password_prompt',[\n  \"skylark-pdfjs-display\",\n  \"./ui_utils\"\n],function(pdfjsLib,ui_utils){\n  /* Copyright 2012 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { NullL10n } = ui_utils;\n  const { PasswordResponses } = pdfjsLib;\n\n  /**\n   * @typedef {Object} PasswordPromptOptions\n   * @property {string} overlayName - Name of the overlay for the overlay manager.\n   * @property {HTMLDivElement} container - Div container for the overlay.\n   * @property {HTMLParagraphElement} label - Label containing instructions for\n   *                                          entering the password.\n   * @property {HTMLInputElement} input - Input field for entering the password.\n   * @property {HTMLButtonElement} submitButton - Button for submitting the\n   *                                              password.\n   * @property {HTMLButtonElement} cancelButton - Button for cancelling password\n   *                                              entry.\n   */\n\n  class PasswordPrompt {\n    /**\n     * @param {PasswordPromptOptions} options\n     * @param {OverlayManager} overlayManager - Manager for the viewer overlays.\n     * @param {IL10n} l10n - Localization service.\n     */\n    constructor(options, overlayManager, l10n = NullL10n) {\n      this.overlayName = options.overlayName;\n      this.container = options.container;\n      this.label = options.label;\n      this.input = options.input;\n      this.submitButton = options.submitButton;\n      this.cancelButton = options.cancelButton;\n      this.overlayManager = overlayManager;\n      this.l10n = l10n;\n\n      this.updateCallback = null;\n      this.reason = null;\n\n      // Attach the event listeners.\n      this.submitButton.addEventListener(\"click\", this.verify.bind(this));\n      this.cancelButton.addEventListener(\"click\", this.close.bind(this));\n      this.input.addEventListener(\"keydown\", e => {\n        if (e.keyCode === /* Enter = */ 13) {\n          this.verify();\n        }\n      });\n\n      this.overlayManager.register(\n        this.overlayName,\n        this.container,\n        this.close.bind(this),\n        true\n      );\n    }\n\n    open() {\n      this.overlayManager.open(this.overlayName).then(() => {\n        this.input.focus();\n\n        let promptString;\n        if (this.reason === PasswordResponses.INCORRECT_PASSWORD) {\n          promptString = this.l10n.get(\n            \"password_invalid\",\n            null,\n            \"Invalid password. Please try again.\"\n          );\n        } else {\n          promptString = this.l10n.get(\n            \"password_label\",\n            null,\n            \"Enter the password to open this PDF file.\"\n          );\n        }\n\n        promptString.then(msg => {\n          this.label.textContent = msg;\n        });\n      });\n    }\n\n    close() {\n      this.overlayManager.close(this.overlayName).then(() => {\n        this.input.value = \"\";\n      });\n    }\n\n    verify() {\n      const password = this.input.value;\n      if (password && password.length > 0) {\n        this.close();\n        this.updateCallback(password);\n      }\n    }\n\n    setUpdateCallback(updateCallback, reason) {\n      this.updateCallback = updateCallback;\n      this.reason = reason;\n    }\n  }\n\n  return { PasswordPrompt };\n});\ndefine('skylark-pdfjs-viewer/base_tree_viewer',[\n  \"skylark-pdfjs-display\"\n],function(pdfjsLib){\n\n  /* Copyright 2020 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { removeNullCharacters } = pdfjsLib;\n\n  const TREEITEM_OFFSET_TOP = -100; // px\n  const TREEITEM_SELECTED_CLASS = \"selected\";\n\n  class BaseTreeViewer {\n    constructor(options) {\n      if (this.constructor === BaseTreeViewer) {\n        throw new Error(\"Cannot initialize BaseTreeViewer.\");\n      }\n      this.container = options.container;\n      this.eventBus = options.eventBus;\n\n      this.reset();\n    }\n\n    reset() {\n      this._pdfDocument = null;\n      this._lastToggleIsShow = true;\n      this._currentTreeItem = null;\n\n      // Remove the tree from the DOM.\n      this.container.textContent = \"\";\n      // Ensure that the left (right in RTL locales) margin is always reset,\n      // to prevent incorrect tree alignment if a new document is opened.\n      this.container.classList.remove(\"treeWithDeepNesting\");\n    }\n\n    /**\n     * @private\n     */\n    _dispatchEvent(count) {\n      throw new Error(\"Not implemented: _dispatchEvent\");\n    }\n\n    /**\n     * @private\n     */\n    _bindLink(element, params) {\n      throw new Error(\"Not implemented: _bindLink\");\n    }\n\n    /**\n     * @private\n     */\n    _normalizeTextContent(str) {\n      return removeNullCharacters(str) || /* en dash = */ \"\\u2013\";\n    }\n\n    /**\n     * Prepend a button before a tree item which allows the user to collapse or\n     * expand all tree items at that level; see `_toggleTreeItem`.\n     * @private\n     */\n    _addToggleButton(div, hidden = false) {\n      const toggler = document.createElement(\"div\");\n      toggler.className = \"treeItemToggler\";\n      if (hidden) {\n        toggler.classList.add(\"treeItemsHidden\");\n      }\n      toggler.onclick = evt => {\n        evt.stopPropagation();\n        toggler.classList.toggle(\"treeItemsHidden\");\n\n        if (evt.shiftKey) {\n          const shouldShowAll = !toggler.classList.contains(\"treeItemsHidden\");\n          this._toggleTreeItem(div, shouldShowAll);\n        }\n      };\n      div.insertBefore(toggler, div.firstChild);\n    }\n\n    /**\n     * Collapse or expand the subtree of a tree item.\n     *\n     * @param {Element} root - the root of the item (sub)tree.\n     * @param {boolean} show - whether to show the item (sub)tree. If false,\n     *   the item subtree rooted at `root` will be collapsed.\n     * @private\n     */\n    _toggleTreeItem(root, show = false) {\n      this._lastToggleIsShow = show;\n      for (const toggler of root.querySelectorAll(\".treeItemToggler\")) {\n        toggler.classList.toggle(\"treeItemsHidden\", !show);\n      }\n    }\n\n    /**\n     * Collapse or expand all subtrees of the `container`.\n     * @private\n     */\n    _toggleAllTreeItems() {\n      this._toggleTreeItem(this.container, !this._lastToggleIsShow);\n    }\n\n    /**\n     * @private\n     */\n    _finishRendering(fragment, count, hasAnyNesting = false) {\n      if (hasAnyNesting) {\n        this.container.classList.add(\"treeWithDeepNesting\");\n\n        this._lastToggleIsShow = !fragment.querySelector(\".treeItemsHidden\");\n      }\n      this.container.appendChild(fragment);\n\n      this._dispatchEvent(count);\n    }\n\n    render(params) {\n      throw new Error(\"Not implemented: render\");\n    }\n\n    /**\n     * @private\n     */\n    _updateCurrentTreeItem(treeItem = null) {\n      if (this._currentTreeItem) {\n        // Ensure that the current treeItem-selection is always removed.\n        this._currentTreeItem.classList.remove(TREEITEM_SELECTED_CLASS);\n        this._currentTreeItem = null;\n      }\n      if (treeItem) {\n        treeItem.classList.add(TREEITEM_SELECTED_CLASS);\n        this._currentTreeItem = treeItem;\n      }\n    }\n\n    /**\n     * @private\n     */\n    _scrollToCurrentTreeItem(treeItem) {\n      if (!treeItem) {\n        return;\n      }\n      // Ensure that the treeItem is *fully* expanded, such that it will first of\n      // all be visible and secondly that scrolling it into view works correctly.\n      let currentNode = treeItem.parentNode;\n      while (currentNode && currentNode !== this.container) {\n        if (currentNode.classList.contains(\"treeItem\")) {\n          const toggler = currentNode.firstElementChild;\n          ///toggler?.classList.remove(\"treeItemsHidden\"); // lwf\n          toggler && toggler.classList.remove(\"treeItemsHidden\");\n        }\n        currentNode = currentNode.parentNode;\n      }\n      this._updateCurrentTreeItem(treeItem);\n\n      this.container.scrollTo(\n        treeItem.offsetLeft,\n        treeItem.offsetTop + TREEITEM_OFFSET_TOP\n      );\n    }\n  }\n\n  return { BaseTreeViewer };\n});\ndefine('skylark-pdfjs-viewer/pdf_attachment_viewer',[\n  \"skylark-pdfjs-display\",\n  \"./pdfjs_dev\",\n  \"./base_tree_viewer\",\n  \"./viewer_compatibility\"\n],function(\n  pdfjsLib,\n  PDFJSDev,\n  base_tree_viewer,\n  viewer_compatibility\n){\n  /* Copyright 2012 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { createPromiseCapability, getFilenameFromUrl } = pdfjsLib;\n  const { BaseTreeViewer } = base_tree_viewer;\n  const { viewerCompatibilityParams } = viewer_compatibility;\n\n  const PdfFileRegExp = /\\.pdf$/i;\n\n  /**\n   * @typedef {Object} PDFAttachmentViewerOptions\n   * @property {HTMLDivElement} container - The viewer element.\n   * @property {EventBus} eventBus - The application event bus.\n   * @property {DownloadManager} downloadManager - The download manager.\n   */\n\n  /**\n   * @typedef {Object} PDFAttachmentViewerRenderParameters\n   * @property {Object|null} attachments - A lookup table of attachment objects.\n   */\n\n  class PDFAttachmentViewer extends BaseTreeViewer {\n    /**\n     * @param {PDFAttachmentViewerOptions} options\n     */\n    constructor(options) {\n      super(options);\n      this.downloadManager = options.downloadManager;\n\n      this.eventBus._on(\n        \"fileattachmentannotation\",\n        this._appendAttachment.bind(this)\n      );\n    }\n\n    reset(keepRenderedCapability = false) {\n      super.reset();\n      this._attachments = null;\n\n      if (!keepRenderedCapability) {\n        // The only situation in which the `_renderedCapability` should *not* be\n        // replaced is when appending FileAttachment annotations.\n        this._renderedCapability = createPromiseCapability();\n      }\n      if (this._pendingDispatchEvent) {\n        clearTimeout(this._pendingDispatchEvent);\n      }\n      this._pendingDispatchEvent = null;\n    }\n\n    /**\n     * @private\n     */\n    _dispatchEvent(attachmentsCount) {\n      this._renderedCapability.resolve();\n\n      if (this._pendingDispatchEvent) {\n        clearTimeout(this._pendingDispatchEvent);\n        this._pendingDispatchEvent = null;\n      }\n      if (attachmentsCount === 0) {\n        // Delay the event when no \"regular\" attachments exist, to allow time for\n        // parsing of any FileAttachment annotations that may be present on the\n        // *initially* rendered page; this reduces the likelihood of temporarily\n        // disabling the attachmentsView when the `PDFSidebar` handles the event.\n        this._pendingDispatchEvent = setTimeout(() => {\n          this.eventBus.dispatch(\"attachmentsloaded\", {\n            source: this,\n            attachmentsCount: 0,\n          });\n          this._pendingDispatchEvent = null;\n        });\n        return;\n      }\n\n      this.eventBus.dispatch(\"attachmentsloaded\", {\n        source: this,\n        attachmentsCount,\n      });\n    }\n\n    /**\n     * NOTE: Should only be used when `URL.createObjectURL` is natively supported.\n     * @private\n     */\n    _bindPdfLink(element, { content, filename }) {\n      let blobUrl;\n      element.onclick = () => {\n        if (!blobUrl) {\n          blobUrl = URL.createObjectURL(\n            new Blob([content], { type: \"application/pdf\" })\n          );\n        }\n        let viewerUrl;\n        if (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) {\n          // The current URL is the viewer, let's use it and append the file.\n          viewerUrl = \"?file=\" + encodeURIComponent(blobUrl + \"#\" + filename);\n        } else if (PDFJSDev.test(\"MOZCENTRAL\")) {\n          // Let Firefox's content handler catch the URL and display the PDF.\n          viewerUrl = blobUrl + \"#filename=\" + encodeURIComponent(filename);\n        } else if (PDFJSDev.test(\"CHROME\")) {\n          // In the Chrome extension, the URL is rewritten using the history API\n          // in viewer.js, so an absolute URL must be generated.\n          viewerUrl =\n            // eslint-disable-next-line no-undef\n            chrome.runtime.getURL(\"/content/web/viewer.html\") +\n            \"?file=\" +\n            encodeURIComponent(blobUrl + \"#\" + filename);\n        }\n        try {\n          window.open(viewerUrl);\n        } catch (ex) {\n          console.error(`_bindPdfLink: ${ex}`);\n          // Release the `blobUrl`, since opening it failed...\n          URL.revokeObjectURL(blobUrl);\n          blobUrl = null;\n          // ... and fallback to downloading the PDF file.\n          this.downloadManager.downloadData(content, filename, \"application/pdf\");\n        }\n        return false;\n      };\n    }\n\n    /**\n     * @private\n     */\n    _bindLink(element, { content, filename }) {\n      element.onclick = () => {\n        const contentType = PdfFileRegExp.test(filename) ? \"application/pdf\" : \"\";\n        this.downloadManager.downloadData(content, filename, contentType);\n        return false;\n      };\n    }\n\n    /**\n     * @param {PDFAttachmentViewerRenderParameters} params\n     */\n    render({ attachments, keepRenderedCapability = false }) {\n      if (this._attachments) {\n        this.reset(keepRenderedCapability);\n      }\n      this._attachments = attachments || null;\n\n      if (!attachments) {\n        this._dispatchEvent(/* attachmentsCount = */ 0);\n        return;\n      }\n      const names = Object.keys(attachments).sort(function (a, b) {\n        return a.toLowerCase().localeCompare(b.toLowerCase());\n      });\n\n      const fragment = document.createDocumentFragment();\n      let attachmentsCount = 0;\n      for (const name of names) {\n        const item = attachments[name];\n        const filename = getFilenameFromUrl(item.filename);\n\n        const div = document.createElement(\"div\");\n        div.className = \"treeItem\";\n\n        const element = document.createElement(\"a\");\n        if (\n          PdfFileRegExp.test(filename) &&\n          !viewerCompatibilityParams.disableCreateObjectURL\n        ) {\n          this._bindPdfLink(element, { content: item.content, filename });\n        } else {\n          this._bindLink(element, { content: item.content, filename });\n        }\n        element.textContent = this._normalizeTextContent(filename);\n\n        div.appendChild(element);\n\n        fragment.appendChild(div);\n        attachmentsCount++;\n      }\n\n      this._finishRendering(fragment, attachmentsCount);\n    }\n\n    /**\n     * Used to append FileAttachment annotations to the sidebar.\n     * @private\n     */\n    _appendAttachment({ id, filename, content }) {\n      const renderedPromise = this._renderedCapability.promise;\n\n      renderedPromise.then(() => {\n        if (renderedPromise !== this._renderedCapability.promise) {\n          return; // The FileAttachment annotation belongs to a previous document.\n        }\n        let attachments = this._attachments;\n\n        if (!attachments) {\n          attachments = Object.create(null);\n        } else {\n          for (const name in attachments) {\n            if (id === name) {\n              return; // Ignore the new attachment if it already exists.\n            }\n          }\n        }\n        attachments[id] = {\n          filename,\n          content,\n        };\n        this.render({\n          attachments,\n          keepRenderedCapability: true,\n        });\n      });\n    }\n  }\n\n  return { PDFAttachmentViewer };\n});\ndefine('skylark-pdfjs-viewer/pdf_document_properties',[\n  \"skylark-pdfjs-display\",\n  \"./ui_utils\"\n],function(pdfjsLib,ui_utils){\n  /* Copyright 2012 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { createPromiseCapability, PDFDateString } = pdfjsLib;\n  const {\n    getPageSizeInches,\n    getPDFFileNameFromURL,\n    isPortraitOrientation,\n    NullL10n,\n  } = ui_utils;\n\n  const DEFAULT_FIELD_CONTENT = \"-\";\n\n  // See https://en.wikibooks.org/wiki/Lentis/Conversion_to_the_Metric_Standard_in_the_United_States\n  const NON_METRIC_LOCALES = [\"en-us\", \"en-lr\", \"my\"];\n\n  // Should use the format: `width x height`, in portrait orientation.\n  // See https://en.wikipedia.org/wiki/Paper_size\n  const US_PAGE_NAMES = {\n    \"8.5x11\": \"Letter\",\n    \"8.5x14\": \"Legal\",\n  };\n  const METRIC_PAGE_NAMES = {\n    \"297x420\": \"A3\",\n    \"210x297\": \"A4\",\n  };\n\n  function getPageName(size, isPortrait, pageNames) {\n    const width = isPortrait ? size.width : size.height;\n    const height = isPortrait ? size.height : size.width;\n\n    return pageNames[`${width}x${height}`];\n  }\n\n  /**\n   * @typedef {Object} PDFDocumentPropertiesOptions\n   * @property {string} overlayName - Name/identifier for the overlay.\n   * @property {Object} fields - Names and elements of the overlay's fields.\n   * @property {HTMLDivElement} container - Div container for the overlay.\n   * @property {HTMLButtonElement} closeButton - Button for closing the overlay.\n   */\n\n  class PDFDocumentProperties {\n    /**\n     * @param {PDFDocumentPropertiesOptions} options\n     * @param {OverlayManager} overlayManager - Manager for the viewer overlays.\n     * @param {EventBus} eventBus - The application event bus.\n     * @param {IL10n} l10n - Localization service.\n     */\n    constructor(\n      { overlayName, fields, container, closeButton },\n      overlayManager,\n      eventBus,\n      l10n = NullL10n\n    ) {\n      this.overlayName = overlayName;\n      this.fields = fields;\n      this.container = container;\n      this.overlayManager = overlayManager;\n      this.l10n = l10n;\n\n      this._reset();\n      // Bind the event listener for the Close button.\n      closeButton.addEventListener(\"click\", this.close.bind(this));\n\n      this.overlayManager.register(\n        this.overlayName,\n        this.container,\n        this.close.bind(this)\n      );\n\n      eventBus._on(\"pagechanging\", evt => {\n        this._currentPageNumber = evt.pageNumber;\n      });\n      eventBus._on(\"rotationchanging\", evt => {\n        this._pagesRotation = evt.pagesRotation;\n      });\n\n      this._isNonMetricLocale = true; // The default viewer locale is 'en-us'.\n      l10n.getLanguage().then(locale => {\n        this._isNonMetricLocale = NON_METRIC_LOCALES.includes(locale);\n      });\n    }\n\n    /**\n     * Open the document properties overlay.\n     */\n    async open() {\n      const freezeFieldData = data => {\n        Object.defineProperty(this, \"fieldData\", {\n          value: Object.freeze(data),\n          writable: false,\n          enumerable: true,\n          configurable: true,\n        });\n      };\n\n      await Promise.all([\n        this.overlayManager.open(this.overlayName),\n        this._dataAvailableCapability.promise,\n      ]);\n      const currentPageNumber = this._currentPageNumber;\n      const pagesRotation = this._pagesRotation;\n\n      // If the document properties were previously fetched (for this PDF file),\n      // just update the dialog immediately to avoid redundant lookups.\n      if (\n        this.fieldData &&\n        currentPageNumber === this.fieldData._currentPageNumber &&\n        pagesRotation === this.fieldData._pagesRotation\n      ) {\n        this._updateUI();\n        return;\n      }\n\n      // Get the document properties.\n      const {\n        info,\n        /* metadata, */\n        contentDispositionFilename,\n        contentLength,\n      } = await this.pdfDocument.getMetadata();\n\n      const [\n        fileName,\n        fileSize,\n        creationDate,\n        modificationDate,\n        pageSize,\n        isLinearized,\n      ] = await Promise.all([\n        contentDispositionFilename || getPDFFileNameFromURL(this.url),\n        this._parseFileSize(contentLength),\n        this._parseDate(info.CreationDate),\n        this._parseDate(info.ModDate),\n        this.pdfDocument.getPage(currentPageNumber).then(pdfPage => {\n          return this._parsePageSize(getPageSizeInches(pdfPage), pagesRotation);\n        }),\n        this._parseLinearization(info.IsLinearized),\n      ]);\n\n      freezeFieldData({\n        fileName,\n        fileSize,\n        title: info.Title,\n        author: info.Author,\n        subject: info.Subject,\n        keywords: info.Keywords,\n        creationDate,\n        modificationDate,\n        creator: info.Creator,\n        producer: info.Producer,\n        version: info.PDFFormatVersion,\n        pageCount: this.pdfDocument.numPages,\n        pageSize,\n        linearized: isLinearized,\n        _currentPageNumber: currentPageNumber,\n        _pagesRotation: pagesRotation,\n      });\n      this._updateUI();\n\n      // Get the correct fileSize, since it may not have been available\n      // or could potentially be wrong.\n      const { length } = await this.pdfDocument.getDownloadInfo();\n      if (contentLength === length) {\n        return; // The fileSize has already been correctly set.\n      }\n      const data = Object.assign(Object.create(null), this.fieldData);\n      data.fileSize = await this._parseFileSize(length);\n\n      freezeFieldData(data);\n      this._updateUI();\n    }\n\n    /**\n     * Close the document properties overlay.\n     */\n    close() {\n      this.overlayManager.close(this.overlayName);\n    }\n\n    /**\n     * Set a reference to the PDF document and the URL in order\n     * to populate the overlay fields with the document properties.\n     * Note that the overlay will contain no information if this method\n     * is not called.\n     *\n     * @param {PDFDocumentProxy} pdfDocument - A reference to the PDF document.\n     * @param {string} url - The URL of the document.\n     */\n    setDocument(pdfDocument, url = null) {\n      if (this.pdfDocument) {\n        this._reset();\n        this._updateUI(true);\n      }\n      if (!pdfDocument) {\n        return;\n      }\n      this.pdfDocument = pdfDocument;\n      this.url = url;\n\n      this._dataAvailableCapability.resolve();\n    }\n\n    /**\n     * @private\n     */\n    _reset() {\n      this.pdfDocument = null;\n      this.url = null;\n\n      delete this.fieldData;\n      this._dataAvailableCapability = createPromiseCapability();\n      this._currentPageNumber = 1;\n      this._pagesRotation = 0;\n    }\n\n    /**\n     * Always updates all of the dialog fields, to prevent inconsistent UI state.\n     * NOTE: If the contents of a particular field is neither a non-empty string,\n     *       nor a number, it will fall back to `DEFAULT_FIELD_CONTENT`.\n     * @private\n     */\n    _updateUI(reset = false) {\n      if (reset || !this.fieldData) {\n        for (const id in this.fields) {\n          this.fields[id].textContent = DEFAULT_FIELD_CONTENT;\n        }\n        return;\n      }\n      if (this.overlayManager.active !== this.overlayName) {\n        // Don't bother updating the dialog if has already been closed,\n        // since it will be updated the next time `this.open` is called.\n        return;\n      }\n      for (const id in this.fields) {\n        const content = this.fieldData[id];\n        this.fields[id].textContent =\n          content || content === 0 ? content : DEFAULT_FIELD_CONTENT;\n      }\n    }\n\n    /**\n     * @private\n     */\n    async _parseFileSize(fileSize = 0) {\n      const kb = fileSize / 1024;\n      if (!kb) {\n        return undefined;\n      } else if (kb < 1024) {\n        return this.l10n.get(\n          \"document_properties_kb\",\n          {\n            size_kb: (+kb.toPrecision(3)).toLocaleString(),\n            size_b: fileSize.toLocaleString(),\n          },\n          \"{{size_kb}} KB ({{size_b}} bytes)\"\n        );\n      }\n      return this.l10n.get(\n        \"document_properties_mb\",\n        {\n          size_mb: (+(kb / 1024).toPrecision(3)).toLocaleString(),\n          size_b: fileSize.toLocaleString(),\n        },\n        \"{{size_mb}} MB ({{size_b}} bytes)\"\n      );\n    }\n\n    /**\n     * @private\n     */\n    async _parsePageSize(pageSizeInches, pagesRotation) {\n      if (!pageSizeInches) {\n        return undefined;\n      }\n      // Take the viewer rotation into account as well; compare with Adobe Reader.\n      if (pagesRotation % 180 !== 0) {\n        pageSizeInches = {\n          width: pageSizeInches.height,\n          height: pageSizeInches.width,\n        };\n      }\n      const isPortrait = isPortraitOrientation(pageSizeInches);\n\n      let sizeInches = {\n        width: Math.round(pageSizeInches.width * 100) / 100,\n        height: Math.round(pageSizeInches.height * 100) / 100,\n      };\n      // 1in == 25.4mm; no need to round to 2 decimals for millimeters.\n      let sizeMillimeters = {\n        width: Math.round(pageSizeInches.width * 25.4 * 10) / 10,\n        height: Math.round(pageSizeInches.height * 25.4 * 10) / 10,\n      };\n\n      let pageName = null;\n      let rawName =\n        getPageName(sizeInches, isPortrait, US_PAGE_NAMES) ||\n        getPageName(sizeMillimeters, isPortrait, METRIC_PAGE_NAMES);\n\n      if (\n        !rawName &&\n        !(\n          Number.isInteger(sizeMillimeters.width) &&\n          Number.isInteger(sizeMillimeters.height)\n        )\n      ) {\n        // Attempt to improve the page name detection by falling back to fuzzy\n        // matching of the metric dimensions, to account for e.g. rounding errors\n        // and/or PDF files that define the page sizes in an imprecise manner.\n        const exactMillimeters = {\n          width: pageSizeInches.width * 25.4,\n          height: pageSizeInches.height * 25.4,\n        };\n        const intMillimeters = {\n          width: Math.round(sizeMillimeters.width),\n          height: Math.round(sizeMillimeters.height),\n        };\n\n        // Try to avoid false positives, by only considering \"small\" differences.\n        if (\n          Math.abs(exactMillimeters.width - intMillimeters.width) < 0.1 &&\n          Math.abs(exactMillimeters.height - intMillimeters.height) < 0.1\n        ) {\n          rawName = getPageName(intMillimeters, isPortrait, METRIC_PAGE_NAMES);\n          if (rawName) {\n            // Update *both* sizes, computed above, to ensure that the displayed\n            // dimensions always correspond to the detected page name.\n            sizeInches = {\n              width: Math.round((intMillimeters.width / 25.4) * 100) / 100,\n              height: Math.round((intMillimeters.height / 25.4) * 100) / 100,\n            };\n            sizeMillimeters = intMillimeters;\n          }\n        }\n      }\n      if (rawName) {\n        pageName = this.l10n.get(\n          \"document_properties_page_size_name_\" + rawName.toLowerCase(),\n          null,\n          rawName\n        );\n      }\n\n      return Promise.all([\n        this._isNonMetricLocale ? sizeInches : sizeMillimeters,\n        this.l10n.get(\n          \"document_properties_page_size_unit_\" +\n            (this._isNonMetricLocale ? \"inches\" : \"millimeters\"),\n          null,\n          this._isNonMetricLocale ? \"in\" : \"mm\"\n        ),\n        pageName,\n        this.l10n.get(\n          \"document_properties_page_size_orientation_\" +\n            (isPortrait ? \"portrait\" : \"landscape\"),\n          null,\n          isPortrait ? \"portrait\" : \"landscape\"\n        ),\n      ]).then(([{ width, height }, unit, name, orientation]) => {\n        return this.l10n.get(\n          \"document_properties_page_size_dimension_\" +\n            (name ? \"name_\" : \"\") +\n            \"string\",\n          {\n            width: width.toLocaleString(),\n            height: height.toLocaleString(),\n            unit,\n            name,\n            orientation,\n          },\n          \"{{width}} × {{height}} {{unit}} (\" +\n            (name ? \"{{name}}, \" : \"\") +\n            \"{{orientation}})\"\n        );\n      });\n    }\n\n    /**\n     * @private\n     */\n    async _parseDate(inputDate) {\n      const dateObject = PDFDateString.toDateObject(inputDate);\n      if (!dateObject) {\n        return undefined;\n      }\n      return this.l10n.get(\n        \"document_properties_date_string\",\n        {\n          date: dateObject.toLocaleDateString(),\n          time: dateObject.toLocaleTimeString(),\n        },\n        \"{{date}}, {{time}}\"\n      );\n    }\n\n    /**\n     * @private\n     */\n    _parseLinearization(isLinearized) {\n      return this.l10n.get(\n        \"document_properties_linearized_\" + (isLinearized ? \"yes\" : \"no\"),\n        null,\n        isLinearized ? \"Yes\" : \"No\"\n      );\n    }\n  }\n\n  return { PDFDocumentProperties };\n});\ndefine('skylark-pdfjs-viewer/pdf_find_utils',[],function(){\n  /* Copyright 2018 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const CharacterType = {\n    SPACE: 0,\n    ALPHA_LETTER: 1,\n    PUNCT: 2,\n    HAN_LETTER: 3,\n    KATAKANA_LETTER: 4,\n    HIRAGANA_LETTER: 5,\n    HALFWIDTH_KATAKANA_LETTER: 6,\n    THAI_LETTER: 7,\n  };\n\n  function isAlphabeticalScript(charCode) {\n    return charCode < 0x2e80;\n  }\n\n  function isAscii(charCode) {\n    return (charCode & 0xff80) === 0;\n  }\n\n  function isAsciiAlpha(charCode) {\n    return (\n      (charCode >= /* a = */ 0x61 && charCode <= /* z = */ 0x7a) ||\n      (charCode >= /* A = */ 0x41 && charCode <= /* Z = */ 0x5a)\n    );\n  }\n\n  function isAsciiDigit(charCode) {\n    return charCode >= /* 0 = */ 0x30 && charCode <= /* 9 = */ 0x39;\n  }\n\n  function isAsciiSpace(charCode) {\n    return (\n      charCode === /* SPACE = */ 0x20 ||\n      charCode === /* TAB = */ 0x09 ||\n      charCode === /* CR = */ 0x0d ||\n      charCode === /* LF = */ 0x0a\n    );\n  }\n\n  function isHan(charCode) {\n    return (\n      (charCode >= 0x3400 && charCode <= 0x9fff) ||\n      (charCode >= 0xf900 && charCode <= 0xfaff)\n    );\n  }\n\n  function isKatakana(charCode) {\n    return charCode >= 0x30a0 && charCode <= 0x30ff;\n  }\n\n  function isHiragana(charCode) {\n    return charCode >= 0x3040 && charCode <= 0x309f;\n  }\n\n  function isHalfwidthKatakana(charCode) {\n    return charCode >= 0xff60 && charCode <= 0xff9f;\n  }\n\n  function isThai(charCode) {\n    return (charCode & 0xff80) === 0x0e00;\n  }\n\n  /**\n   * This function is based on the word-break detection implemented in:\n   * https://hg.mozilla.org/mozilla-central/file/tip/intl/lwbrk/WordBreaker.cpp\n   */\n  function getCharacterType(charCode) {\n    if (isAlphabeticalScript(charCode)) {\n      if (isAscii(charCode)) {\n        if (isAsciiSpace(charCode)) {\n          return CharacterType.SPACE;\n        } else if (\n          isAsciiAlpha(charCode) ||\n          isAsciiDigit(charCode) ||\n          charCode === /* UNDERSCORE = */ 0x5f\n        ) {\n          return CharacterType.ALPHA_LETTER;\n        }\n        return CharacterType.PUNCT;\n      } else if (isThai(charCode)) {\n        return CharacterType.THAI_LETTER;\n      } else if (charCode === /* NBSP = */ 0xa0) {\n        return CharacterType.SPACE;\n      }\n      return CharacterType.ALPHA_LETTER;\n    }\n\n    if (isHan(charCode)) {\n      return CharacterType.HAN_LETTER;\n    } else if (isKatakana(charCode)) {\n      return CharacterType.KATAKANA_LETTER;\n    } else if (isHiragana(charCode)) {\n      return CharacterType.HIRAGANA_LETTER;\n    } else if (isHalfwidthKatakana(charCode)) {\n      return CharacterType.HALFWIDTH_KATAKANA_LETTER;\n    }\n    return CharacterType.ALPHA_LETTER;\n  }\n\n  return { CharacterType, getCharacterType };\n});\ndefine('skylark-pdfjs-viewer/pdf_find_controller',[\n  \"skylark-pdfjs-display\",\n  \"./ui_utils\",\n  \"./pdf_find_utils\"\n],function(pdfjsLib,ui_utils,pdf_find_utils){\n  /* Copyright 2012 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { createPromiseCapability } = pdfjsLib;\n  const { getCharacterType } = pdf_find_utils;\n  const { scrollIntoView } = ui_utils;\n\n  const FindState = {\n    FOUND: 0,\n    NOT_FOUND: 1,\n    WRAPPED: 2,\n    PENDING: 3,\n  };\n\n  const FIND_TIMEOUT = 250; // ms\n  const MATCH_SCROLL_OFFSET_TOP = -50; // px\n  const MATCH_SCROLL_OFFSET_LEFT = -400; // px\n\n  const CHARACTERS_TO_NORMALIZE = {\n    \"\\u2018\": \"'\", // Left single quotation mark\n    \"\\u2019\": \"'\", // Right single quotation mark\n    \"\\u201A\": \"'\", // Single low-9 quotation mark\n    \"\\u201B\": \"'\", // Single high-reversed-9 quotation mark\n    \"\\u201C\": '\"', // Left double quotation mark\n    \"\\u201D\": '\"', // Right double quotation mark\n    \"\\u201E\": '\"', // Double low-9 quotation mark\n    \"\\u201F\": '\"', // Double high-reversed-9 quotation mark\n    \"\\u00BC\": \"1/4\", // Vulgar fraction one quarter\n    \"\\u00BD\": \"1/2\", // Vulgar fraction one half\n    \"\\u00BE\": \"3/4\", // Vulgar fraction three quarters\n  };\n\n  let normalizationRegex = null;\n  function normalize(text) {\n    if (!normalizationRegex) {\n      // Compile the regular expression for text normalization once.\n      const replace = Object.keys(CHARACTERS_TO_NORMALIZE).join(\"\");\n      normalizationRegex = new RegExp(`[${replace}]`, \"g\");\n    }\n    let diffs = null;\n    const normalizedText = text.replace(normalizationRegex, function (ch, index) {\n      const normalizedCh = CHARACTERS_TO_NORMALIZE[ch],\n        diff = normalizedCh.length - ch.length;\n      if (diff !== 0) {\n        ///(diffs ||= []).push([index, diff]); // lwf\n        (diffs || (diffs = [])).push([index, diff]);\n      }\n      return normalizedCh;\n    });\n\n    return [normalizedText, diffs];\n  }\n\n  // Determine the original, non-normalized, match index such that highlighting of\n  // search results is correct in the `textLayer` for strings containing e.g. \"½\"\n  // characters; essentially \"inverting\" the result of the `normalize` function.\n  function getOriginalIndex(matchIndex, diffs = null) {\n    if (!diffs) {\n      return matchIndex;\n    }\n    let totalDiff = 0;\n    for (const [index, diff] of diffs) {\n      const currentIndex = index + totalDiff;\n\n      if (currentIndex >= matchIndex) {\n        break;\n      }\n      if (currentIndex + diff > matchIndex) {\n        totalDiff += matchIndex - currentIndex;\n        break;\n      }\n      totalDiff += diff;\n    }\n    return matchIndex - totalDiff;\n  }\n\n  /**\n   * @typedef {Object} PDFFindControllerOptions\n   * @property {IPDFLinkService} linkService - The navigation/linking service.\n   * @property {EventBus} eventBus - The application event bus.\n   */\n\n  /**\n   * Provides search functionality to find a given string in a PDF document.\n   */\n  class PDFFindController {\n    /**\n     * @param {PDFFindControllerOptions} options\n     */\n    constructor({ linkService, eventBus }) {\n      this._linkService = linkService;\n      this._eventBus = eventBus;\n\n      this._reset();\n      eventBus._on(\"findbarclose\", this._onFindBarClose.bind(this));\n    }\n\n    get highlightMatches() {\n      return this._highlightMatches;\n    }\n\n    get pageMatches() {\n      return this._pageMatches;\n    }\n\n    get pageMatchesLength() {\n      return this._pageMatchesLength;\n    }\n\n    get selected() {\n      return this._selected;\n    }\n\n    get state() {\n      return this._state;\n    }\n\n    /**\n     * Set a reference to the PDF document in order to search it.\n     * Note that searching is not possible if this method is not called.\n     *\n     * @param {PDFDocumentProxy} pdfDocument - The PDF document to search.\n     */\n    setDocument(pdfDocument) {\n      if (this._pdfDocument) {\n        this._reset();\n      }\n      if (!pdfDocument) {\n        return;\n      }\n      this._pdfDocument = pdfDocument;\n      this._firstPageCapability.resolve();\n    }\n\n    executeCommand(cmd, state) {\n      if (!state) {\n        return;\n      }\n      const pdfDocument = this._pdfDocument;\n\n      if (this._state === null || this._shouldDirtyMatch(cmd, state)) {\n        this._dirtyMatch = true;\n      }\n      this._state = state;\n      if (cmd !== \"findhighlightallchange\") {\n        this._updateUIState(FindState.PENDING);\n      }\n\n      this._firstPageCapability.promise.then(() => {\n        // If the document was closed before searching began, or if the search\n        // operation was relevant for a previously opened document, do nothing.\n        if (\n          !this._pdfDocument ||\n          (pdfDocument && this._pdfDocument !== pdfDocument)\n        ) {\n          return;\n        }\n        this._extractText();\n\n        const findbarClosed = !this._highlightMatches;\n        const pendingTimeout = !!this._findTimeout;\n\n        if (this._findTimeout) {\n          clearTimeout(this._findTimeout);\n          this._findTimeout = null;\n        }\n        if (cmd === \"find\") {\n          // Trigger the find action with a small delay to avoid starting the\n          // search when the user is still typing (saving resources).\n          this._findTimeout = setTimeout(() => {\n            this._nextMatch();\n            this._findTimeout = null;\n          }, FIND_TIMEOUT);\n        } else if (this._dirtyMatch) {\n          // Immediately trigger searching for non-'find' operations, when the\n          // current state needs to be reset and matches re-calculated.\n          this._nextMatch();\n        } else if (cmd === \"findagain\") {\n          this._nextMatch();\n\n          // When the findbar was previously closed, and `highlightAll` is set,\n          // ensure that the matches on all active pages are highlighted again.\n          if (findbarClosed && this._state.highlightAll) {\n            this._updateAllPages();\n          }\n        } else if (cmd === \"findhighlightallchange\") {\n          // If there was a pending search operation, synchronously trigger a new\n          // search *first* to ensure that the correct matches are highlighted.\n          if (pendingTimeout) {\n            this._nextMatch();\n          } else {\n            this._highlightMatches = true;\n          }\n          this._updateAllPages(); // Update the highlighting on all active pages.\n        } else {\n          this._nextMatch();\n        }\n      });\n    }\n\n    scrollMatchIntoView({ element = null, pageIndex = -1, matchIndex = -1 }) {\n      if (!this._scrollMatches || !element) {\n        return;\n      } else if (matchIndex === -1 || matchIndex !== this._selected.matchIdx) {\n        return;\n      } else if (pageIndex === -1 || pageIndex !== this._selected.pageIdx) {\n        return;\n      }\n      this._scrollMatches = false; // Ensure that scrolling only happens once.\n\n      const spot = {\n        top: MATCH_SCROLL_OFFSET_TOP,\n        left: MATCH_SCROLL_OFFSET_LEFT,\n      };\n      scrollIntoView(element, spot, /* skipOverflowHiddenElements = */ true);\n    }\n\n    _reset() {\n      this._highlightMatches = false;\n      this._scrollMatches = false;\n      this._pdfDocument = null;\n      this._pageMatches = [];\n      this._pageMatchesLength = [];\n      this._state = null;\n      // Currently selected match.\n      this._selected = {\n        pageIdx: -1,\n        matchIdx: -1,\n      };\n      // Where the find algorithm currently is in the document.\n      this._offset = {\n        pageIdx: null,\n        matchIdx: null,\n        wrapped: false,\n      };\n      this._extractTextPromises = [];\n      this._pageContents = []; // Stores the normalized text for each page.\n      this._pageDiffs = [];\n      this._matchesCountTotal = 0;\n      this._pagesToSearch = null;\n      this._pendingFindMatches = Object.create(null);\n      this._resumePageIdx = null;\n      this._dirtyMatch = false;\n      clearTimeout(this._findTimeout);\n      this._findTimeout = null;\n\n      this._firstPageCapability = createPromiseCapability();\n    }\n\n    /**\n     * @type {string} The (current) normalized search query.\n     */\n    get _query() {\n      if (this._state.query !== this._rawQuery) {\n        this._rawQuery = this._state.query;\n        [this._normalizedQuery] = normalize(this._state.query);\n      }\n      return this._normalizedQuery;\n    }\n\n    _shouldDirtyMatch(cmd, state) {\n      // When the search query changes, regardless of the actual search command\n      // used, always re-calculate matches to avoid errors (fixes bug 1030622).\n      if (state.query !== this._state.query) {\n        return true;\n      }\n      switch (cmd) {\n        case \"findagain\":\n          const pageNumber = this._selected.pageIdx + 1;\n          const linkService = this._linkService;\n          // Only treat a 'findagain' event as a new search operation when it's\n          // *absolutely* certain that the currently selected match is no longer\n          // visible, e.g. as a result of the user scrolling in the document.\n          //\n          // NOTE: If only a simple `this._linkService.page` check was used here,\n          // there's a risk that consecutive 'findagain' operations could \"skip\"\n          // over matches at the top/bottom of pages thus making them completely\n          // inaccessible when there's multiple pages visible in the viewer.\n          if (\n            pageNumber >= 1 &&\n            pageNumber <= linkService.pagesCount &&\n            pageNumber !== linkService.page &&\n            !linkService.isPageVisible(pageNumber)\n          ) {\n            return true;\n          }\n          return false;\n        case \"findhighlightallchange\":\n          return false;\n      }\n      return true;\n    }\n\n    /**\n     * Helper for multi-term search that fills the `matchesWithLength` array\n     * and handles cases where one search term includes another search term (for\n     * example, \"tamed tame\" or \"this is\"). It looks for intersecting terms in\n     * the `matches` and keeps elements with a longer match length.\n     */\n    _prepareMatches(matchesWithLength, matches, matchesLength) {\n      function isSubTerm(currentIndex) {\n        const currentElem = matchesWithLength[currentIndex];\n        const nextElem = matchesWithLength[currentIndex + 1];\n\n        // Check for cases like \"TAMEd TAME\".\n        if (\n          currentIndex < matchesWithLength.length - 1 &&\n          currentElem.match === nextElem.match\n        ) {\n          currentElem.skipped = true;\n          return true;\n        }\n\n        // Check for cases like \"thIS IS\".\n        for (let i = currentIndex - 1; i >= 0; i--) {\n          const prevElem = matchesWithLength[i];\n          if (prevElem.skipped) {\n            continue;\n          }\n          if (prevElem.match + prevElem.matchLength < currentElem.match) {\n            break;\n          }\n          if (\n            prevElem.match + prevElem.matchLength >=\n            currentElem.match + currentElem.matchLength\n          ) {\n            currentElem.skipped = true;\n            return true;\n          }\n        }\n        return false;\n      }\n\n      // Sort the array of `{ match: <match>, matchLength: <matchLength> }`\n      // objects on increasing index first and on the length otherwise.\n      matchesWithLength.sort(function (a, b) {\n        return a.match === b.match\n          ? a.matchLength - b.matchLength\n          : a.match - b.match;\n      });\n      for (let i = 0, len = matchesWithLength.length; i < len; i++) {\n        if (isSubTerm(i)) {\n          continue;\n        }\n        matches.push(matchesWithLength[i].match);\n        matchesLength.push(matchesWithLength[i].matchLength);\n      }\n    }\n\n    /**\n     * Determine if the search query constitutes a \"whole word\", by comparing the\n     * first/last character type with the preceding/following character type.\n     */\n    _isEntireWord(content, startIdx, length) {\n      if (startIdx > 0) {\n        const first = content.charCodeAt(startIdx);\n        const limit = content.charCodeAt(startIdx - 1);\n        if (getCharacterType(first) === getCharacterType(limit)) {\n          return false;\n        }\n      }\n      const endIdx = startIdx + length - 1;\n      if (endIdx < content.length - 1) {\n        const last = content.charCodeAt(endIdx);\n        const limit = content.charCodeAt(endIdx + 1);\n        if (getCharacterType(last) === getCharacterType(limit)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    _calculatePhraseMatch(query, pageIndex, pageContent, pageDiffs, entireWord) {\n      const matches = [],\n        matchesLength = [];\n      const queryLen = query.length;\n\n      let matchIdx = -queryLen;\n      while (true) {\n        matchIdx = pageContent.indexOf(query, matchIdx + queryLen);\n        if (matchIdx === -1) {\n          break;\n        }\n        if (entireWord && !this._isEntireWord(pageContent, matchIdx, queryLen)) {\n          continue;\n        }\n        const originalMatchIdx = getOriginalIndex(matchIdx, pageDiffs),\n          matchEnd = matchIdx + queryLen - 1,\n          originalQueryLen =\n            getOriginalIndex(matchEnd, pageDiffs) - originalMatchIdx + 1;\n\n        matches.push(originalMatchIdx);\n        matchesLength.push(originalQueryLen);\n      }\n      this._pageMatches[pageIndex] = matches;\n      this._pageMatchesLength[pageIndex] = matchesLength;\n    }\n\n    _calculateWordMatch(query, pageIndex, pageContent, pageDiffs, entireWord) {\n      const matchesWithLength = [];\n\n      // Divide the query into pieces and search for text in each piece.\n      const queryArray = query.match(/\\S+/g);\n      for (let i = 0, len = queryArray.length; i < len; i++) {\n        const subquery = queryArray[i];\n        const subqueryLen = subquery.length;\n\n        let matchIdx = -subqueryLen;\n        while (true) {\n          matchIdx = pageContent.indexOf(subquery, matchIdx + subqueryLen);\n          if (matchIdx === -1) {\n            break;\n          }\n          if (\n            entireWord &&\n            !this._isEntireWord(pageContent, matchIdx, subqueryLen)\n          ) {\n            continue;\n          }\n          const originalMatchIdx = getOriginalIndex(matchIdx, pageDiffs),\n            matchEnd = matchIdx + subqueryLen - 1,\n            originalQueryLen =\n              getOriginalIndex(matchEnd, pageDiffs) - originalMatchIdx + 1;\n\n          // Other searches do not, so we store the length.\n          matchesWithLength.push({\n            match: originalMatchIdx,\n            matchLength: originalQueryLen,\n            skipped: false,\n          });\n        }\n      }\n\n      // Prepare arrays for storing the matches.\n      this._pageMatchesLength[pageIndex] = [];\n      this._pageMatches[pageIndex] = [];\n\n      // Sort `matchesWithLength`, remove intersecting terms and put the result\n      // into the two arrays.\n      this._prepareMatches(\n        matchesWithLength,\n        this._pageMatches[pageIndex],\n        this._pageMatchesLength[pageIndex]\n      );\n    }\n\n    _calculateMatch(pageIndex) {\n      let pageContent = this._pageContents[pageIndex];\n      const pageDiffs = this._pageDiffs[pageIndex];\n      let query = this._query;\n      const { caseSensitive, entireWord, phraseSearch } = this._state;\n\n      if (query.length === 0) {\n        // Do nothing: the matches should be wiped out already.\n        return;\n      }\n\n      if (!caseSensitive) {\n        pageContent = pageContent.toLowerCase();\n        query = query.toLowerCase();\n      }\n\n      if (phraseSearch) {\n        this._calculatePhraseMatch(\n          query,\n          pageIndex,\n          pageContent,\n          pageDiffs,\n          entireWord\n        );\n      } else {\n        this._calculateWordMatch(\n          query,\n          pageIndex,\n          pageContent,\n          pageDiffs,\n          entireWord\n        );\n      }\n\n      // When `highlightAll` is set, ensure that the matches on previously\n      // rendered (and still active) pages are correctly highlighted.\n      if (this._state.highlightAll) {\n        this._updatePage(pageIndex);\n      }\n      if (this._resumePageIdx === pageIndex) {\n        this._resumePageIdx = null;\n        this._nextPageMatch();\n      }\n\n      // Update the match count.\n      const pageMatchesCount = this._pageMatches[pageIndex].length;\n      if (pageMatchesCount > 0) {\n        this._matchesCountTotal += pageMatchesCount;\n        this._updateUIResultsCount();\n      }\n    }\n\n    _extractText() {\n      // Perform text extraction once if this method is called multiple times.\n      if (this._extractTextPromises.length > 0) {\n        return;\n      }\n\n      let promise = Promise.resolve();\n      for (let i = 0, ii = this._linkService.pagesCount; i < ii; i++) {\n        const extractTextCapability = createPromiseCapability();\n        this._extractTextPromises[i] = extractTextCapability.promise;\n\n        promise = promise.then(() => {\n          return this._pdfDocument\n            .getPage(i + 1)\n            .then(pdfPage => {\n              return pdfPage.getTextContent({\n                normalizeWhitespace: true,\n              });\n            })\n            .then(\n              textContent => {\n                const textItems = textContent.items;\n                const strBuf = [];\n\n                for (let j = 0, jj = textItems.length; j < jj; j++) {\n                  strBuf.push(textItems[j].str);\n                }\n\n                // Store the normalized page content (text items) as one string.\n                [this._pageContents[i], this._pageDiffs[i]] = normalize(\n                  strBuf.join(\"\")\n                );\n                extractTextCapability.resolve(i);\n              },\n              reason => {\n                console.error(\n                  `Unable to get text content for page ${i + 1}`,\n                  reason\n                );\n                // Page error -- assuming no text content.\n                this._pageContents[i] = \"\";\n                this._pageDiffs[i] = null;\n                extractTextCapability.resolve(i);\n              }\n            );\n        });\n      }\n    }\n\n    _updatePage(index) {\n      if (this._scrollMatches && this._selected.pageIdx === index) {\n        // If the page is selected, scroll the page into view, which triggers\n        // rendering the page, which adds the text layer. Once the text layer\n        // is built, it will attempt to scroll the selected match into view.\n        this._linkService.page = index + 1;\n      }\n\n      this._eventBus.dispatch(\"updatetextlayermatches\", {\n        source: this,\n        pageIndex: index,\n      });\n    }\n\n    _updateAllPages() {\n      this._eventBus.dispatch(\"updatetextlayermatches\", {\n        source: this,\n        pageIndex: -1,\n      });\n    }\n\n    _nextMatch() {\n      const previous = this._state.findPrevious;\n      const currentPageIndex = this._linkService.page - 1;\n      const numPages = this._linkService.pagesCount;\n\n      this._highlightMatches = true;\n\n      if (this._dirtyMatch) {\n        // Need to recalculate the matches, reset everything.\n        this._dirtyMatch = false;\n        this._selected.pageIdx = this._selected.matchIdx = -1;\n        this._offset.pageIdx = currentPageIndex;\n        this._offset.matchIdx = null;\n        this._offset.wrapped = false;\n        this._resumePageIdx = null;\n        this._pageMatches.length = 0;\n        this._pageMatchesLength.length = 0;\n        this._matchesCountTotal = 0;\n\n        this._updateAllPages(); // Wipe out any previously highlighted matches.\n\n        for (let i = 0; i < numPages; i++) {\n          // Start finding the matches as soon as the text is extracted.\n          if (this._pendingFindMatches[i] === true) {\n            continue;\n          }\n          this._pendingFindMatches[i] = true;\n          this._extractTextPromises[i].then(pageIdx => {\n            delete this._pendingFindMatches[pageIdx];\n            this._calculateMatch(pageIdx);\n          });\n        }\n      }\n\n      // If there's no query there's no point in searching.\n      if (this._query === \"\") {\n        this._updateUIState(FindState.FOUND);\n        return;\n      }\n      // If we're waiting on a page, we return since we can't do anything else.\n      if (this._resumePageIdx) {\n        return;\n      }\n\n      const offset = this._offset;\n      // Keep track of how many pages we should maximally iterate through.\n      this._pagesToSearch = numPages;\n      // If there's already a `matchIdx` that means we are iterating through a\n      // page's matches.\n      if (offset.matchIdx !== null) {\n        const numPageMatches = this._pageMatches[offset.pageIdx].length;\n        if (\n          (!previous && offset.matchIdx + 1 < numPageMatches) ||\n          (previous && offset.matchIdx > 0)\n        ) {\n          // The simple case; we just have advance the matchIdx to select\n          // the next match on the page.\n          offset.matchIdx = previous ? offset.matchIdx - 1 : offset.matchIdx + 1;\n          this._updateMatch(/* found = */ true);\n          return;\n        }\n        // We went beyond the current page's matches, so we advance to\n        // the next page.\n        this._advanceOffsetPage(previous);\n      }\n      // Start searching through the page.\n      this._nextPageMatch();\n    }\n\n    _matchesReady(matches) {\n      const offset = this._offset;\n      const numMatches = matches.length;\n      const previous = this._state.findPrevious;\n\n      if (numMatches) {\n        // There were matches for the page, so initialize `matchIdx`.\n        offset.matchIdx = previous ? numMatches - 1 : 0;\n        this._updateMatch(/* found = */ true);\n        return true;\n      }\n      // No matches, so attempt to search the next page.\n      this._advanceOffsetPage(previous);\n      if (offset.wrapped) {\n        offset.matchIdx = null;\n        if (this._pagesToSearch < 0) {\n          // No point in wrapping again, there were no matches.\n          this._updateMatch(/* found = */ false);\n          // While matches were not found, searching for a page\n          // with matches should nevertheless halt.\n          return true;\n        }\n      }\n      // Matches were not found (and searching is not done).\n      return false;\n    }\n\n    _nextPageMatch() {\n      if (this._resumePageIdx !== null) {\n        console.error(\"There can only be one pending page.\");\n      }\n\n      let matches = null;\n      do {\n        const pageIdx = this._offset.pageIdx;\n        matches = this._pageMatches[pageIdx];\n        if (!matches) {\n          // The matches don't exist yet for processing by `_matchesReady`,\n          // so set a resume point for when they do exist.\n          this._resumePageIdx = pageIdx;\n          break;\n        }\n      } while (!this._matchesReady(matches));\n    }\n\n    _advanceOffsetPage(previous) {\n      const offset = this._offset;\n      const numPages = this._linkService.pagesCount;\n      offset.pageIdx = previous ? offset.pageIdx - 1 : offset.pageIdx + 1;\n      offset.matchIdx = null;\n\n      this._pagesToSearch--;\n\n      if (offset.pageIdx >= numPages || offset.pageIdx < 0) {\n        offset.pageIdx = previous ? numPages - 1 : 0;\n        offset.wrapped = true;\n      }\n    }\n\n    _updateMatch(found = false) {\n      let state = FindState.NOT_FOUND;\n      const wrapped = this._offset.wrapped;\n      this._offset.wrapped = false;\n\n      if (found) {\n        const previousPage = this._selected.pageIdx;\n        this._selected.pageIdx = this._offset.pageIdx;\n        this._selected.matchIdx = this._offset.matchIdx;\n        state = wrapped ? FindState.WRAPPED : FindState.FOUND;\n\n        // Update the currently selected page to wipe out any selected matches.\n        if (previousPage !== -1 && previousPage !== this._selected.pageIdx) {\n          this._updatePage(previousPage);\n        }\n      }\n\n      this._updateUIState(state, this._state.findPrevious);\n      if (this._selected.pageIdx !== -1) {\n        // Ensure that the match will be scrolled into view.\n        this._scrollMatches = true;\n\n        this._updatePage(this._selected.pageIdx);\n      }\n    }\n\n    _onFindBarClose(evt) {\n      const pdfDocument = this._pdfDocument;\n      // Since searching is asynchronous, ensure that the removal of highlighted\n      // matches (from the UI) is async too such that the 'updatetextlayermatches'\n      // events will always be dispatched in the expected order.\n      this._firstPageCapability.promise.then(() => {\n        // Only update the UI if the document is open, and is the current one.\n        if (\n          !this._pdfDocument ||\n          (pdfDocument && this._pdfDocument !== pdfDocument)\n        ) {\n          return;\n        }\n        // Ensure that a pending, not yet started, search operation is aborted.\n        if (this._findTimeout) {\n          clearTimeout(this._findTimeout);\n          this._findTimeout = null;\n        }\n        // Abort any long running searches, to avoid a match being scrolled into\n        // view *after* the findbar has been closed. In this case `this._offset`\n        // will most likely differ from `this._selected`, hence we also ensure\n        // that any new search operation will always start with a clean slate.\n        if (this._resumePageIdx) {\n          this._resumePageIdx = null;\n          this._dirtyMatch = true;\n        }\n        // Avoid the UI being in a pending state when the findbar is re-opened.\n        this._updateUIState(FindState.FOUND);\n\n        this._highlightMatches = false;\n        this._updateAllPages(); // Wipe out any previously highlighted matches.\n      });\n    }\n\n    _requestMatchesCount() {\n      const { pageIdx, matchIdx } = this._selected;\n      let current = 0,\n        total = this._matchesCountTotal;\n      if (matchIdx !== -1) {\n        for (let i = 0; i < pageIdx; i++) {\n          current += (this._pageMatches[i] && this._pageMatches[i].length) || 0;\n        }\n        current += matchIdx + 1;\n      }\n      // When searching starts, this method may be called before the `pageMatches`\n      // have been counted (in `_calculateMatch`). Ensure that the UI won't show\n      // temporarily broken state when the active find result doesn't make sense.\n      if (current < 1 || current > total) {\n        current = total = 0;\n      }\n      return { current, total };\n    }\n\n    _updateUIResultsCount() {\n      this._eventBus.dispatch(\"updatefindmatchescount\", {\n        source: this,\n        matchesCount: this._requestMatchesCount(),\n      });\n    }\n\n    _updateUIState(state, previous) {\n      this._eventBus.dispatch(\"updatefindcontrolstate\", {\n        source: this,\n        state,\n        previous,\n        matchesCount: this._requestMatchesCount(),\n        rawQuery: this._state ? this._state.query : null,\n      });\n    }\n  }\n\n  return { FindState, PDFFindController };\n});\ndefine('skylark-pdfjs-viewer/pdf_find_bar',[\n  \"./pdfjs_dev\",\n  \"./ui_utils\",\n  \"./pdf_find_controller\"\n],function(\n  PDFJSDev,\n  ui_utils,\n  pdf_find_controller\n){\n  /* Copyright 2012 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { FindState } = pdf_find_controller;\n  const { NullL10n } = ui_utils;\n\n  const MATCHES_COUNT_LIMIT = 1000;\n\n  /**\n   * Creates a \"search bar\" given a set of DOM elements that act as controls\n   * for searching or for setting search preferences in the UI. This object\n   * also sets up the appropriate events for the controls. Actual searching\n   * is done by PDFFindController.\n   */\n  class PDFFindBar {\n    constructor(options, eventBus, l10n = NullL10n) {\n      this.opened = false;\n\n      this.bar = options.bar || null;\n      this.toggleButton = options.toggleButton || null;\n      this.findField = options.findField || null;\n      this.highlightAll = options.highlightAllCheckbox || null;\n      this.caseSensitive = options.caseSensitiveCheckbox || null;\n      this.entireWord = options.entireWordCheckbox || null;\n      this.findMsg = options.findMsg || null;\n      this.findResultsCount = options.findResultsCount || null;\n      this.findPreviousButton = options.findPreviousButton || null;\n      this.findNextButton = options.findNextButton || null;\n      this.eventBus = eventBus;\n      this.l10n = l10n;\n\n      // Add event listeners to the DOM elements.\n      this.toggleButton.addEventListener(\"click\", () => {\n        this.toggle();\n      });\n\n      this.findField.addEventListener(\"input\", () => {\n        this.dispatchEvent(\"\");\n      });\n\n      this.bar.addEventListener(\"keydown\", e => {\n        switch (e.keyCode) {\n          case 13: // Enter\n            if (e.target === this.findField) {\n              this.dispatchEvent(\"again\", e.shiftKey);\n            }\n            break;\n          case 27: // Escape\n            this.close();\n            break;\n        }\n      });\n\n      this.findPreviousButton.addEventListener(\"click\", () => {\n        this.dispatchEvent(\"again\", true);\n      });\n\n      this.findNextButton.addEventListener(\"click\", () => {\n        this.dispatchEvent(\"again\", false);\n      });\n\n      this.highlightAll.addEventListener(\"click\", () => {\n        this.dispatchEvent(\"highlightallchange\");\n      });\n\n      this.caseSensitive.addEventListener(\"click\", () => {\n        this.dispatchEvent(\"casesensitivitychange\");\n      });\n\n      this.entireWord.addEventListener(\"click\", () => {\n        this.dispatchEvent(\"entirewordchange\");\n      });\n\n      this.eventBus._on(\"resize\", this._adjustWidth.bind(this));\n    }\n\n    reset() {\n      this.updateUIState();\n    }\n\n    dispatchEvent(type, findPrev) {\n      this.eventBus.dispatch(\"find\", {\n        source: this,\n        type,\n        query: this.findField.value,\n        phraseSearch: true,\n        caseSensitive: this.caseSensitive.checked,\n        entireWord: this.entireWord.checked,\n        highlightAll: this.highlightAll.checked,\n        findPrevious: findPrev,\n      });\n    }\n\n    updateUIState(state, previous, matchesCount) {\n      let findMsg = \"\";\n      let status = \"\";\n\n      switch (state) {\n        case FindState.FOUND:\n          break;\n\n        case FindState.PENDING:\n          status = \"pending\";\n          break;\n\n        case FindState.NOT_FOUND:\n          findMsg = this.l10n.get(\"find_not_found\", null, \"Phrase not found\");\n          status = \"notFound\";\n          break;\n\n        case FindState.WRAPPED:\n          if (previous) {\n            findMsg = this.l10n.get(\n              \"find_reached_top\",\n              null,\n              \"Reached top of document, continued from bottom\"\n            );\n          } else {\n            findMsg = this.l10n.get(\n              \"find_reached_bottom\",\n              null,\n              \"Reached end of document, continued from top\"\n            );\n          }\n          break;\n      }\n      this.findField.setAttribute(\"data-status\", status);\n\n      Promise.resolve(findMsg).then(msg => {\n        this.findMsg.textContent = msg;\n        this._adjustWidth();\n      });\n\n      this.updateResultsCount(matchesCount);\n    }\n\n    updateResultsCount({ current = 0, total = 0 } = {}) {\n      if (!this.findResultsCount) {\n        return; // No UI control is provided.\n      }\n      const limit = MATCHES_COUNT_LIMIT;\n      let matchesCountMsg = \"\";\n\n      if (total > 0) {\n        if (total > limit) {\n          if (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"MOZCENTRAL\")) {\n            // TODO: Remove this hard-coded `[other]` form once plural support has\n            // been implemented in the mozilla-central specific `l10n.js` file.\n            matchesCountMsg = this.l10n.get(\n              \"find_match_count_limit[other]\",\n              {\n                limit,\n              },\n              \"More than {{limit}} matches\"\n            );\n          } else {\n            matchesCountMsg = this.l10n.get(\n              \"find_match_count_limit\",\n              {\n                limit,\n              },\n              \"More than {{limit}} match\" + (limit !== 1 ? \"es\" : \"\")\n            );\n          }\n        } else {\n          if (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"MOZCENTRAL\")) {\n            // TODO: Remove this hard-coded `[other]` form once plural support has\n            // been implemented in the mozilla-central specific `l10n.js` file.\n            matchesCountMsg = this.l10n.get(\n              \"find_match_count[other]\",\n              {\n                current,\n                total,\n              },\n              \"{{current}} of {{total}} matches\"\n            );\n          } else {\n            matchesCountMsg = this.l10n.get(\n              \"find_match_count\",\n              {\n                current,\n                total,\n              },\n              \"{{current}} of {{total}} match\" + (total !== 1 ? \"es\" : \"\")\n            );\n          }\n        }\n      }\n      Promise.resolve(matchesCountMsg).then(msg => {\n        this.findResultsCount.textContent = msg;\n        this.findResultsCount.classList.toggle(\"hidden\", !total);\n        // Since `updateResultsCount` may be called from `PDFFindController`,\n        // ensure that the width of the findbar is always updated correctly.\n        this._adjustWidth();\n      });\n    }\n\n    open() {\n      if (!this.opened) {\n        this.opened = true;\n        this.toggleButton.classList.add(\"toggled\");\n        this.bar.classList.remove(\"hidden\");\n      }\n      this.findField.select();\n      this.findField.focus();\n\n      this._adjustWidth();\n    }\n\n    close() {\n      if (!this.opened) {\n        return;\n      }\n      this.opened = false;\n      this.toggleButton.classList.remove(\"toggled\");\n      this.bar.classList.add(\"hidden\");\n\n      this.eventBus.dispatch(\"findbarclose\", { source: this });\n    }\n\n    toggle() {\n      if (this.opened) {\n        this.close();\n      } else {\n        this.open();\n      }\n    }\n\n    /**\n     * @private\n     */\n    _adjustWidth() {\n      if (!this.opened) {\n        return;\n      }\n\n      // The find bar has an absolute position and thus the browser extends\n      // its width to the maximum possible width once the find bar does not fit\n      // entirely within the window anymore (and its elements are automatically\n      // wrapped). Here we detect and fix that.\n      this.bar.classList.remove(\"wrapContainers\");\n\n      const findbarHeight = this.bar.clientHeight;\n      const inputContainerHeight = this.bar.firstElementChild.clientHeight;\n\n      if (findbarHeight > inputContainerHeight) {\n        // The findbar is taller than the input container, which means that\n        // the browser wrapped some of the elements. For a consistent look,\n        // wrap all of them to adjust the width of the find bar.\n        this.bar.classList.add(\"wrapContainers\");\n      }\n    }\n  }\n\n  return { PDFFindBar };\n});\ndefine('skylark-pdfjs-viewer/pdf_history',[\n  \"./pdfjs_dev\",\n  \"./ui_utils\",\n],function(\n  PDFJSDev,\n  ui_utils\n){\n  /* Copyright 2017 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const {\n    isValidRotation,\n    parseQueryString,\n    PresentationModeState,\n    waitOnEventOrTimeout,\n  } = ui_utils;\n\n  // Heuristic value used when force-resetting `this._blockHashChange`.\n  const HASH_CHANGE_TIMEOUT = 1000; // milliseconds\n  // Heuristic value used when adding the current position to the browser history.\n  const POSITION_UPDATED_THRESHOLD = 50;\n  // Heuristic value used when adding a temporary position to the browser history.\n  const UPDATE_VIEWAREA_TIMEOUT = 1000; // milliseconds\n\n  /**\n   * @typedef {Object} PDFHistoryOptions\n   * @property {IPDFLinkService} linkService - The navigation/linking service.\n   * @property {EventBus} eventBus - The application event bus.\n   */\n\n  /**\n   * @typedef {Object} InitializeParameters\n   * @property {string} fingerprint - The PDF document's unique fingerprint.\n   * @property {boolean} [resetHistory] - Reset the browsing history.\n   * @property {boolean} [updateUrl] - Attempt to update the document URL, with\n   *   the current hash, when pushing/replacing browser history entries.\n   */\n\n  /**\n   * @typedef {Object} PushParameters\n   * @property {string} [namedDest] - The named destination. If absent, a\n   *   stringified version of `explicitDest` is used.\n   * @property {Array} explicitDest - The explicit destination array.\n   * @property {number} pageNumber - The page to which the destination points.\n   */\n\n  function getCurrentHash() {\n    return document.location.hash;\n  }\n\n  class PDFHistory {\n    /**\n     * @param {PDFHistoryOptions} options\n     */\n    constructor({ linkService, eventBus }) {\n      this.linkService = linkService;\n      this.eventBus = eventBus;\n\n      this._initialized = false;\n      this._fingerprint = \"\";\n      this.reset();\n\n      this._boundEvents = null;\n      this._isViewerInPresentationMode = false;\n      // Ensure that we don't miss either a 'presentationmodechanged' or a\n      // 'pagesinit' event, by registering the listeners immediately.\n      this.eventBus._on(\"presentationmodechanged\", evt => {\n        this._isViewerInPresentationMode =\n          evt.state !== PresentationModeState.NORMAL;\n      });\n      this.eventBus._on(\"pagesinit\", () => {\n        this._isPagesLoaded = false;\n\n        this.eventBus._on(\n          \"pagesloaded\",\n          evt => {\n            this._isPagesLoaded = !!evt.pagesCount;\n          },\n          { once: true }\n        );\n      });\n    }\n\n    /**\n     * Initialize the history for the PDF document, using either the current\n     * browser history entry or the document hash, whichever is present.\n     * @param {InitializeParameters} params\n     */\n    initialize({ fingerprint, resetHistory = false, updateUrl = false }) {\n      if (!fingerprint || typeof fingerprint !== \"string\") {\n        console.error(\n          'PDFHistory.initialize: The \"fingerprint\" must be a non-empty string.'\n        );\n        return;\n      }\n      // Ensure that any old state is always reset upon initialization.\n      if (this._initialized) {\n        this.reset();\n      }\n      const reInitialized =\n        this._fingerprint !== \"\" && this._fingerprint !== fingerprint;\n      this._fingerprint = fingerprint;\n      this._updateUrl = updateUrl === true;\n\n      this._initialized = true;\n      this._bindEvents();\n      const state = window.history.state;\n\n      this._popStateInProgress = false;\n      this._blockHashChange = 0;\n      this._currentHash = getCurrentHash();\n      this._numPositionUpdates = 0;\n\n      this._uid = this._maxUid = 0;\n      this._destination = null;\n      this._position = null;\n\n      if (!this._isValidState(state, /* checkReload = */ true) || resetHistory) {\n        const { hash, page, rotation } = this._parseCurrentHash(\n          /* checkNameddest = */ true\n        );\n\n        if (!hash || reInitialized || resetHistory) {\n          // Ensure that the browser history is reset on PDF document load.\n          this._pushOrReplaceState(null, /* forceReplace = */ true);\n          return;\n        }\n        // Ensure that the browser history is initialized correctly when\n        // the document hash is present on PDF document load.\n        this._pushOrReplaceState(\n          { hash, page, rotation },\n          /* forceReplace = */ true\n        );\n        return;\n      }\n\n      // The browser history contains a valid entry, ensure that the history is\n      // initialized correctly on PDF document load.\n      const destination = state.destination;\n      this._updateInternalState(\n        destination,\n        state.uid,\n        /* removeTemporary = */ true\n      );\n\n      if (destination.rotation !== undefined) {\n        this._initialRotation = destination.rotation;\n      }\n      if (destination.dest) {\n        this._initialBookmark = JSON.stringify(destination.dest);\n\n        // If the history is updated, e.g. through the user changing the hash,\n        // before the initial destination has become visible, then we do *not*\n        // want to potentially add `this._position` to the browser history.\n        this._destination.page = null;\n      } else if (destination.hash) {\n        this._initialBookmark = destination.hash;\n      } else if (destination.page) {\n        // Fallback case; shouldn't be necessary, but better safe than sorry.\n        this._initialBookmark = `page=${destination.page}`;\n      }\n    }\n\n    /**\n     * Reset the current `PDFHistory` instance, and consequently prevent any\n     * further updates and/or navigation of the browser history.\n     */\n    reset() {\n      if (this._initialized) {\n        this._pageHide(); // Simulate a 'pagehide' event when resetting.\n\n        this._initialized = false;\n        this._unbindEvents();\n      }\n      if (this._updateViewareaTimeout) {\n        clearTimeout(this._updateViewareaTimeout);\n        this._updateViewareaTimeout = null;\n      }\n      this._initialBookmark = null;\n      this._initialRotation = null;\n    }\n\n    /**\n     * Push an internal destination to the browser history.\n     * @param {PushParameters}\n     */\n    push({ namedDest = null, explicitDest, pageNumber }) {\n      if (!this._initialized) {\n        return;\n      }\n      if (namedDest && typeof namedDest !== \"string\") {\n        console.error(\n          \"PDFHistory.push: \" +\n            `\"${namedDest}\" is not a valid namedDest parameter.`\n        );\n        return;\n      } else if (!Array.isArray(explicitDest)) {\n        console.error(\n          \"PDFHistory.push: \" +\n            `\"${explicitDest}\" is not a valid explicitDest parameter.`\n        );\n        return;\n      } else if (\n        !(\n          Number.isInteger(pageNumber) &&\n          pageNumber > 0 &&\n          pageNumber <= this.linkService.pagesCount\n        )\n      ) {\n        // Allow an unset `pageNumber` if and only if the history is still empty;\n        // please refer to the `this._destination.page = null;` comment above.\n        if (pageNumber !== null || this._destination) {\n          console.error(\n            \"PDFHistory.push: \" +\n              `\"${pageNumber}\" is not a valid pageNumber parameter.`\n          );\n          return;\n        }\n      }\n\n      const hash = namedDest || JSON.stringify(explicitDest);\n      if (!hash) {\n        // The hash *should* never be undefined, but if that were to occur,\n        // avoid any possible issues by not updating the browser history.\n        return;\n      }\n\n      let forceReplace = false;\n      if (\n        this._destination &&\n        (isDestHashesEqual(this._destination.hash, hash) ||\n          isDestArraysEqual(this._destination.dest, explicitDest))\n      ) {\n        // When the new destination is identical to `this._destination`, and\n        // its `page` is undefined, replace the current browser history entry.\n        // NOTE: This can only occur if `this._destination` was set either:\n        //  - through the document hash being specified on load.\n        //  - through the user changing the hash of the document.\n        if (this._destination.page) {\n          return;\n        }\n        forceReplace = true;\n      }\n      if (this._popStateInProgress && !forceReplace) {\n        return;\n      }\n\n      this._pushOrReplaceState(\n        {\n          dest: explicitDest,\n          hash,\n          page: pageNumber,\n          rotation: this.linkService.rotation,\n        },\n        forceReplace\n      );\n\n      if (!this._popStateInProgress) {\n        // Prevent the browser history from updating while the new destination is\n        // being scrolled into view, to avoid potentially inconsistent state.\n        this._popStateInProgress = true;\n        // We defer the resetting of `this._popStateInProgress`, to account for\n        // e.g. zooming occuring when the new destination is being navigated to.\n        Promise.resolve().then(() => {\n          this._popStateInProgress = false;\n        });\n      }\n    }\n\n    /**\n     * Push a page to the browser history; generally the `push` method should be\n     * used instead.\n     * @param {number} pageNumber\n     */\n    pushPage(pageNumber) {\n      if (!this._initialized) {\n        return;\n      }\n      if (\n        !(\n          Number.isInteger(pageNumber) &&\n          pageNumber > 0 &&\n          pageNumber <= this.linkService.pagesCount\n        )\n      ) {\n        console.error(\n          `PDFHistory.pushPage: \"${pageNumber}\" is not a valid page number.`\n        );\n        return;\n      }\n\n      ///if (this._destination?.page === pageNumber) { // lwf\n      if (this._destination && this._destination.page === pageNumber) {\n        // When the new page is identical to the one in `this._destination`, we\n        // don't want to add a potential duplicate entry in the browser history.\n        return;\n      }\n      if (this._popStateInProgress) {\n        return;\n      }\n\n      this._pushOrReplaceState({\n        hash: `page=${pageNumber}`,\n        page: pageNumber,\n        rotation: this.linkService.rotation,\n      });\n\n      if (!this._popStateInProgress) {\n        // Prevent the browser history from updating while the new page is\n        // being scrolled into view, to avoid potentially inconsistent state.\n        this._popStateInProgress = true;\n        // We defer the resetting of `this._popStateInProgress`, to account for\n        // e.g. zooming occuring when the new page is being navigated to.\n        Promise.resolve().then(() => {\n          this._popStateInProgress = false;\n        });\n      }\n    }\n\n    /**\n     * Push the current position to the browser history.\n     */\n    pushCurrentPosition() {\n      if (!this._initialized || this._popStateInProgress) {\n        return;\n      }\n      this._tryPushCurrentPosition();\n    }\n\n    /**\n     * Go back one step in the browser history.\n     * NOTE: Avoids navigating away from the document, useful for \"named actions\".\n     */\n    back() {\n      if (!this._initialized || this._popStateInProgress) {\n        return;\n      }\n      const state = window.history.state;\n      if (this._isValidState(state) && state.uid > 0) {\n        window.history.back();\n      }\n    }\n\n    /**\n     * Go forward one step in the browser history.\n     * NOTE: Avoids navigating away from the document, useful for \"named actions\".\n     */\n    forward() {\n      if (!this._initialized || this._popStateInProgress) {\n        return;\n      }\n      const state = window.history.state;\n      if (this._isValidState(state) && state.uid < this._maxUid) {\n        window.history.forward();\n      }\n    }\n\n    /**\n     * @type {boolean} Indicating if the user is currently moving through the\n     *   browser history, useful e.g. for skipping the next 'hashchange' event.\n     */\n    get popStateInProgress() {\n      return (\n        this._initialized &&\n        (this._popStateInProgress || this._blockHashChange > 0)\n      );\n    }\n\n    get initialBookmark() {\n      return this._initialized ? this._initialBookmark : null;\n    }\n\n    get initialRotation() {\n      return this._initialized ? this._initialRotation : null;\n    }\n\n    /**\n     * @private\n     */\n    _pushOrReplaceState(destination, forceReplace = false) {\n      const shouldReplace = forceReplace || !this._destination;\n      const newState = {\n        fingerprint: this._fingerprint,\n        uid: shouldReplace ? this._uid : this._uid + 1,\n        destination,\n      };\n\n      if (\n        typeof PDFJSDev !== \"undefined\" &&\n        PDFJSDev.test(\"CHROME\") &&\n        ///window.history.state?.chromecomState // lwf\n        (window.history.state && window.history.state.chromecomState)\n      ) {\n        // history.state.chromecomState is managed by chromecom.js.\n        newState.chromecomState = window.history.state.chromecomState;\n      }\n      this._updateInternalState(destination, newState.uid);\n\n      let newUrl;\n      ///if (this._updateUrl && destination?.hash) { // lwf\n      if (this._updateUrl && destination && destination.hash) {\n        const baseUrl = document.location.href.split(\"#\")[0];\n        // Prevent errors in Firefox.\n        if (!baseUrl.startsWith(\"file://\")) {\n          newUrl = `${baseUrl}#${destination.hash}`;\n        }\n      }\n      if (shouldReplace) {\n        window.history.replaceState(newState, \"\", newUrl);\n      } else {\n        window.history.pushState(newState, \"\", newUrl);\n      }\n\n      if (\n        typeof PDFJSDev !== \"undefined\" &&\n        PDFJSDev.test(\"CHROME\") &&\n        top === window\n      ) {\n        // eslint-disable-next-line no-undef\n        chrome.runtime.sendMessage(\"showPageAction\");\n      }\n    }\n\n    /**\n     * @private\n     */\n    _tryPushCurrentPosition(temporary = false) {\n      if (!this._position) {\n        return;\n      }\n      let position = this._position;\n      if (temporary) {\n        position = Object.assign(Object.create(null), this._position);\n        position.temporary = true;\n      }\n\n      if (!this._destination) {\n        this._pushOrReplaceState(position);\n        return;\n      }\n      if (this._destination.temporary) {\n        // Always replace a previous *temporary* position.\n        this._pushOrReplaceState(position, /* forceReplace = */ true);\n        return;\n      }\n      if (this._destination.hash === position.hash) {\n        return; // The current document position has not changed.\n      }\n      if (\n        !this._destination.page &&\n        (POSITION_UPDATED_THRESHOLD <= 0 ||\n          this._numPositionUpdates <= POSITION_UPDATED_THRESHOLD)\n      ) {\n        // `this._destination` was set through the user changing the hash of\n        // the document. Do not add `this._position` to the browser history,\n        // to avoid \"flooding\" it with lots of (nearly) identical entries,\n        // since we cannot ensure that the document position has changed.\n        return;\n      }\n\n      let forceReplace = false;\n      if (\n        this._destination.page >= position.first &&\n        this._destination.page <= position.page\n      ) {\n        // When the `page` of `this._destination` is still visible, do not\n        // update the browsing history when `this._destination` either:\n        //  - contains an internal destination, since in this case we\n        //    cannot ensure that the document position has actually changed.\n        //  - was set through the user changing the hash of the document.\n        if (this._destination.dest || !this._destination.first) {\n          return;\n        }\n        // To avoid \"flooding\" the browser history, replace the current entry.\n        forceReplace = true;\n      }\n      this._pushOrReplaceState(position, forceReplace);\n    }\n\n    /**\n     * @private\n     */\n    _isValidState(state, checkReload = false) {\n      if (!state) {\n        return false;\n      }\n      if (state.fingerprint !== this._fingerprint) {\n        if (checkReload) {\n          // Potentially accept the history entry, even if the fingerprints don't\n          // match, when the viewer was reloaded (see issue 6847).\n          if (\n            typeof state.fingerprint !== \"string\" ||\n            state.fingerprint.length !== this._fingerprint.length\n          ) {\n            return false;\n          }\n          const [perfEntry] = performance.getEntriesByType(\"navigation\");\n          ///if (perfEntry?.type !== \"reload\") { // lwf\n          if (perfEntry && perfEntry.type !== \"reload\") {\n            return false;\n          }\n        } else {\n          // This should only occur in viewers with support for opening more than\n          // one PDF document, e.g. the GENERIC viewer.\n          return false;\n        }\n      }\n      if (!Number.isInteger(state.uid) || state.uid < 0) {\n        return false;\n      }\n      if (state.destination === null || typeof state.destination !== \"object\") {\n        return false;\n      }\n      return true;\n    }\n\n    /**\n     * @private\n     */\n    _updateInternalState(destination, uid, removeTemporary = false) {\n      if (this._updateViewareaTimeout) {\n        // When updating `this._destination`, make sure that we always wait for\n        // the next 'updateviewarea' event before (potentially) attempting to\n        // push the current position to the browser history.\n        clearTimeout(this._updateViewareaTimeout);\n        this._updateViewareaTimeout = null;\n      }\n      ///if (removeTemporary && destination?.temporary) { // lwf\n      if (removeTemporary && destination && destination.temporary) {\n        // When the `destination` comes from the browser history,\n        // we no longer treat it as a *temporary* position.\n        delete destination.temporary;\n      }\n      this._destination = destination;\n      this._uid = uid;\n      this._maxUid = Math.max(this._maxUid, uid);\n      // This should always be reset when `this._destination` is updated.\n      this._numPositionUpdates = 0;\n    }\n\n    /**\n     * @private\n     */\n    _parseCurrentHash(checkNameddest = false) {\n      const hash = unescape(getCurrentHash()).substring(1);\n      const params = parseQueryString(hash);\n\n      const nameddest = params.nameddest || \"\";\n      let page = params.page | 0;\n\n      if (\n        !(\n          Number.isInteger(page) &&\n          page > 0 &&\n          page <= this.linkService.pagesCount\n        ) ||\n        (checkNameddest && nameddest.length > 0)\n      ) {\n        page = null;\n      }\n      return { hash, page, rotation: this.linkService.rotation };\n    }\n\n    /**\n     * @private\n     */\n    _updateViewarea({ location }) {\n      if (this._updateViewareaTimeout) {\n        clearTimeout(this._updateViewareaTimeout);\n        this._updateViewareaTimeout = null;\n      }\n\n      this._position = {\n        hash: this._isViewerInPresentationMode\n          ? `page=${location.pageNumber}`\n          : location.pdfOpenParams.substring(1),\n        page: this.linkService.page,\n        first: location.pageNumber,\n        rotation: location.rotation,\n      };\n\n      if (this._popStateInProgress) {\n        return;\n      }\n\n      if (\n        POSITION_UPDATED_THRESHOLD > 0 &&\n        this._isPagesLoaded &&\n        this._destination &&\n        !this._destination.page\n      ) {\n        // If the current destination was set through the user changing the hash\n        // of the document, we will usually not try to push the current position\n        // to the browser history; see `this._tryPushCurrentPosition()`.\n        //\n        // To prevent `this._tryPushCurrentPosition()` from effectively being\n        // reduced to a no-op in this case, we will assume that the position\n        // *did* in fact change if the 'updateviewarea' event was dispatched\n        // more than `POSITION_UPDATED_THRESHOLD` times.\n        this._numPositionUpdates++;\n      }\n\n      if (UPDATE_VIEWAREA_TIMEOUT > 0) {\n        // When closing the browser, a 'pagehide' event will be dispatched which\n        // *should* allow us to push the current position to the browser history.\n        // In practice, it seems that the event is arriving too late in order for\n        // the session history to be successfully updated.\n        // (For additional details, please refer to the discussion in\n        //  https://bugzilla.mozilla.org/show_bug.cgi?id=1153393.)\n        //\n        // To workaround this we attempt to *temporarily* add the current position\n        // to the browser history only when the viewer is *idle*,\n        // i.e. when scrolling and/or zooming does not occur.\n        //\n        // PLEASE NOTE: It's absolutely imperative that the browser history is\n        // *not* updated too often, since that would render the viewer more or\n        // less unusable. Hence the use of a timeout to delay the update until\n        // the viewer has been idle for `UPDATE_VIEWAREA_TIMEOUT` milliseconds.\n        this._updateViewareaTimeout = setTimeout(() => {\n          if (!this._popStateInProgress) {\n            this._tryPushCurrentPosition(/* temporary = */ true);\n          }\n          this._updateViewareaTimeout = null;\n        }, UPDATE_VIEWAREA_TIMEOUT);\n      }\n    }\n\n    /**\n     * @private\n     */\n    _popState({ state }) {\n      const newHash = getCurrentHash(),\n        hashChanged = this._currentHash !== newHash;\n      this._currentHash = newHash;\n\n      if (\n        (typeof PDFJSDev !== \"undefined\" &&\n          PDFJSDev.test(\"CHROME\") &&\n          ///state?.chromecomState && // lwf\n          state && state.chromecomState &&\n          !this._isValidState(state)) ||\n        !state\n      ) {\n        // This case corresponds to the user changing the hash of the document.\n        this._uid++;\n\n        const { hash, page, rotation } = this._parseCurrentHash();\n        this._pushOrReplaceState(\n          { hash, page, rotation },\n          /* forceReplace = */ true\n        );\n        return;\n      }\n      if (!this._isValidState(state)) {\n        // This should only occur in viewers with support for opening more than\n        // one PDF document, e.g. the GENERIC viewer.\n        return;\n      }\n\n      // Prevent the browser history from updating until the new destination,\n      // as stored in the browser history, has been scrolled into view.\n      this._popStateInProgress = true;\n\n      if (hashChanged) {\n        // When the hash changed, implying that the 'popstate' event will be\n        // followed by a 'hashchange' event, then we do *not* want to update the\n        // browser history when handling the 'hashchange' event (in web/app.js)\n        // since that would *overwrite* the new destination navigated to below.\n        //\n        // To avoid accidentally disabling all future user-initiated hash changes,\n        // if there's e.g. another 'hashchange' listener that stops the event\n        // propagation, we make sure to always force-reset `this._blockHashChange`\n        // after `HASH_CHANGE_TIMEOUT` milliseconds have passed.\n        this._blockHashChange++;\n        waitOnEventOrTimeout({\n          target: window,\n          name: \"hashchange\",\n          delay: HASH_CHANGE_TIMEOUT,\n        }).then(() => {\n          this._blockHashChange--;\n        });\n      }\n\n      // Navigate to the new destination.\n      const destination = state.destination;\n      this._updateInternalState(\n        destination,\n        state.uid,\n        /* removeTemporary = */ true\n      );\n\n      if (isValidRotation(destination.rotation)) {\n        this.linkService.rotation = destination.rotation;\n      }\n      if (destination.dest) {\n        this.linkService.goToDestination(destination.dest);\n      } else if (destination.hash) {\n        this.linkService.setHash(destination.hash);\n      } else if (destination.page) {\n        // Fallback case; shouldn't be necessary, but better safe than sorry.\n        this.linkService.page = destination.page;\n      }\n\n      // Since `PDFLinkService.goToDestination` is asynchronous, we thus defer the\n      // resetting of `this._popStateInProgress` slightly.\n      Promise.resolve().then(() => {\n        this._popStateInProgress = false;\n      });\n    }\n\n    /**\n     * @private\n     */\n    _pageHide() {\n      // Attempt to push the `this._position` into the browser history when\n      // navigating away from the document. This is *only* done if the history\n      // is empty/temporary, since otherwise an existing browser history entry\n      // will end up being overwritten (given that new entries cannot be pushed\n      // into the browser history when the 'unload' event has already fired).\n      if (!this._destination || this._destination.temporary) {\n        this._tryPushCurrentPosition();\n      }\n    }\n\n    /**\n     * @private\n     */\n    _bindEvents() {\n      if (this._boundEvents) {\n        return; // The event listeners were already added.\n      }\n      this._boundEvents = {\n        updateViewarea: this._updateViewarea.bind(this),\n        popState: this._popState.bind(this),\n        pageHide: this._pageHide.bind(this),\n      };\n\n      this.eventBus._on(\"updateviewarea\", this._boundEvents.updateViewarea);\n      window.addEventListener(\"popstate\", this._boundEvents.popState);\n      window.addEventListener(\"pagehide\", this._boundEvents.pageHide);\n    }\n\n    /**\n     * @private\n     */\n    _unbindEvents() {\n      if (!this._boundEvents) {\n        return; // The event listeners were already removed.\n      }\n      this.eventBus._off(\"updateviewarea\", this._boundEvents.updateViewarea);\n      window.removeEventListener(\"popstate\", this._boundEvents.popState);\n      window.removeEventListener(\"pagehide\", this._boundEvents.pageHide);\n\n      this._boundEvents = null;\n    }\n  }\n\n  function isDestHashesEqual(destHash, pushHash) {\n    if (typeof destHash !== \"string\" || typeof pushHash !== \"string\") {\n      return false;\n    }\n    if (destHash === pushHash) {\n      return true;\n    }\n    const { nameddest } = parseQueryString(destHash);\n    if (nameddest === pushHash) {\n      return true;\n    }\n    return false;\n  }\n\n  function isDestArraysEqual(firstDest, secondDest) {\n    function isEntryEqual(first, second) {\n      if (typeof first !== typeof second) {\n        return false;\n      }\n      if (Array.isArray(first) || Array.isArray(second)) {\n        return false;\n      }\n      if (first !== null && typeof first === \"object\" && second !== null) {\n        if (Object.keys(first).length !== Object.keys(second).length) {\n          return false;\n        }\n        for (const key in first) {\n          if (!isEntryEqual(first[key], second[key])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return first === second || (Number.isNaN(first) && Number.isNaN(second));\n    }\n\n    if (!(Array.isArray(firstDest) && Array.isArray(secondDest))) {\n      return false;\n    }\n    if (firstDest.length !== secondDest.length) {\n      return false;\n    }\n    for (let i = 0, ii = firstDest.length; i < ii; i++) {\n      if (!isEntryEqual(firstDest[i], secondDest[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  return { isDestArraysEqual, isDestHashesEqual, PDFHistory };\n});\ndefine('skylark-pdfjs-viewer/pdf_layer_viewer',[\n  \"./base_tree_viewer\"\n],function(base_tree_viewer){\n  /* Copyright 2020 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { BaseTreeViewer } = base_tree_viewer;\n\n  /**\n   * @typedef {Object} PDFLayerViewerOptions\n   * @property {HTMLDivElement} container - The viewer element.\n   * @property {EventBus} eventBus - The application event bus.\n   * @property {IL10n} l10n - Localization service.\n   */\n\n  /**\n   * @typedef {Object} PDFLayerViewerRenderParameters\n   * @property {OptionalContentConfig|null} optionalContentConfig - An\n   *   {OptionalContentConfig} instance.\n   * @property {PDFDocument} pdfDocument - A {PDFDocument} instance.\n   */\n\n  class PDFLayerViewer extends BaseTreeViewer {\n    constructor(options) {\n      super(options);\n      this.l10n = options.l10n;\n\n      this.eventBus._on(\"resetlayers\", this._resetLayers.bind(this));\n      this.eventBus._on(\"togglelayerstree\", this._toggleAllTreeItems.bind(this));\n    }\n\n    reset() {\n      super.reset();\n      this._optionalContentConfig = null;\n    }\n\n    /**\n     * @private\n     */\n    _dispatchEvent(layersCount) {\n      this.eventBus.dispatch(\"layersloaded\", {\n        source: this,\n        layersCount,\n      });\n    }\n\n    /**\n     * @private\n     */\n    _bindLink(element, { groupId, input }) {\n      const setVisibility = () => {\n        this._optionalContentConfig.setVisibility(groupId, input.checked);\n\n        this.eventBus.dispatch(\"optionalcontentconfig\", {\n          source: this,\n          promise: Promise.resolve(this._optionalContentConfig),\n        });\n      };\n\n      element.onclick = evt => {\n        if (evt.target === input) {\n          setVisibility();\n          return true;\n        } else if (evt.target !== element) {\n          return true; // The target is the \"label\", which is handled above.\n        }\n        input.checked = !input.checked;\n        setVisibility();\n        return false;\n      };\n    }\n\n    /**\n     * @private\n     */\n    async _setNestedName(element, { name = null }) {\n      if (typeof name === \"string\") {\n        element.textContent = this._normalizeTextContent(name);\n        return;\n      }\n      element.textContent = await this.l10n.get(\n        \"additional_layers\",\n        null,\n        \"Additional Layers\"\n      );\n      element.style.fontStyle = \"italic\";\n    }\n\n    /**\n     * @private\n     */\n    _addToggleButton(div, { name = null }) {\n      super._addToggleButton(div, /* hidden = */ name === null);\n    }\n\n    /**\n     * @private\n     */\n    _toggleAllTreeItems() {\n      if (!this._optionalContentConfig) {\n        return;\n      }\n      super._toggleAllTreeItems();\n    }\n\n    /**\n     * @param {PDFLayerViewerRenderParameters} params\n     */\n    render({ optionalContentConfig, pdfDocument }) {\n      if (this._optionalContentConfig) {\n        this.reset();\n      }\n      this._optionalContentConfig = optionalContentConfig || null;\n      this._pdfDocument = pdfDocument || null;\n\n      const groups = optionalContentConfig && optionalContentConfig.getOrder();\n      if (!groups) {\n        this._dispatchEvent(/* layersCount = */ 0);\n        return;\n      }\n\n      const fragment = document.createDocumentFragment(),\n        queue = [{ parent: fragment, groups }];\n      let layersCount = 0,\n        hasAnyNesting = false;\n      while (queue.length > 0) {\n        const levelData = queue.shift();\n        for (const groupId of levelData.groups) {\n          const div = document.createElement(\"div\");\n          div.className = \"treeItem\";\n\n          const element = document.createElement(\"a\");\n          div.appendChild(element);\n\n          if (typeof groupId === \"object\") {\n            hasAnyNesting = true;\n            this._addToggleButton(div, groupId);\n            this._setNestedName(element, groupId);\n\n            const itemsDiv = document.createElement(\"div\");\n            itemsDiv.className = \"treeItems\";\n            div.appendChild(itemsDiv);\n\n            queue.push({ parent: itemsDiv, groups: groupId.order });\n          } else {\n            const group = optionalContentConfig.getGroup(groupId);\n\n            const input = document.createElement(\"input\");\n            this._bindLink(element, { groupId, input });\n            input.type = \"checkbox\";\n            input.id = groupId;\n            input.checked = group.visible;\n\n            const label = document.createElement(\"label\");\n            label.setAttribute(\"for\", groupId);\n            label.textContent = this._normalizeTextContent(group.name);\n\n            element.appendChild(input);\n            element.appendChild(label);\n\n            layersCount++;\n          }\n\n          levelData.parent.appendChild(div);\n        }\n      }\n\n      this._finishRendering(fragment, layersCount, hasAnyNesting);\n    }\n\n    /**\n     * @private\n     */\n    async _resetLayers() {\n      if (!this._optionalContentConfig) {\n        return;\n      }\n      // Fetch the default optional content configuration...\n      const optionalContentConfig = await this._pdfDocument.getOptionalContentConfig();\n\n      this.eventBus.dispatch(\"optionalcontentconfig\", {\n        source: this,\n        promise: Promise.resolve(optionalContentConfig),\n      });\n\n      // ... and reset the sidebarView to the default state.\n      this.render({\n        optionalContentConfig,\n        pdfDocument: this._pdfDocument,\n      });\n    }\n  }\n\n  return { PDFLayerViewer };\n\n});\ndefine('skylark-pdfjs-viewer/pdf_link_service',[\n  \"./ui_utils\",\n],function(ui_utils){\n  /* Copyright 2015 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { parseQueryString } = ui_utils;\n\n  /**\n   * @typedef {Object} PDFLinkServiceOptions\n   * @property {EventBus} eventBus - The application event bus.\n   * @property {number} [externalLinkTarget] - Specifies the `target` attribute\n   *   for external links. Must use one of the values from {LinkTarget}.\n   *   Defaults to using no target.\n   * @property {string} [externalLinkRel] - Specifies the `rel` attribute for\n   *   external links. Defaults to stripping the referrer.\n   * @property {boolean} [ignoreDestinationZoom] - Ignores the zoom argument,\n   *   thus preserving the current zoom level in the viewer, when navigating\n   *   to internal destinations. The default value is `false`.\n   */\n\n  /**\n   * Performs navigation functions inside PDF, such as opening specified page,\n   * or destination.\n   * @implements {IPDFLinkService}\n   */\n  class PDFLinkService {\n    /**\n     * @param {PDFLinkServiceOptions} options\n     */\n    constructor({\n      eventBus,\n      externalLinkTarget = null,\n      externalLinkRel = null,\n      externalLinkEnabled = true,\n      ignoreDestinationZoom = false,\n    } = {}) {\n      this.eventBus = eventBus;\n      this.externalLinkTarget = externalLinkTarget;\n      this.externalLinkRel = externalLinkRel;\n      this.externalLinkEnabled = externalLinkEnabled;\n      this._ignoreDestinationZoom = ignoreDestinationZoom;\n\n      this.baseUrl = null;\n      this.pdfDocument = null;\n      this.pdfViewer = null;\n      this.pdfHistory = null;\n\n      this._pagesRefCache = null;\n    }\n\n    setDocument(pdfDocument, baseUrl = null) {\n      this.baseUrl = baseUrl;\n      this.pdfDocument = pdfDocument;\n      this._pagesRefCache = Object.create(null);\n    }\n\n    setViewer(pdfViewer) {\n      this.pdfViewer = pdfViewer;\n    }\n\n    setHistory(pdfHistory) {\n      this.pdfHistory = pdfHistory;\n    }\n\n    /**\n     * @type {number}\n     */\n    get pagesCount() {\n      return this.pdfDocument ? this.pdfDocument.numPages : 0;\n    }\n\n    /**\n     * @type {number}\n     */\n    get page() {\n      return this.pdfViewer.currentPageNumber;\n    }\n\n    /**\n     * @param {number} value\n     */\n    set page(value) {\n      this.pdfViewer.currentPageNumber = value;\n    }\n\n    /**\n     * @type {number}\n     */\n    get rotation() {\n      return this.pdfViewer.pagesRotation;\n    }\n\n    /**\n     * @param {number} value\n     */\n    set rotation(value) {\n      this.pdfViewer.pagesRotation = value;\n    }\n\n    /**\n     * @deprecated\n     */\n    navigateTo(dest) {\n      console.error(\n        \"Deprecated method: `navigateTo`, use `goToDestination` instead.\"\n      );\n      this.goToDestination(dest);\n    }\n\n    /**\n     * @private\n     */\n    _goToDestinationHelper(rawDest, namedDest = null, explicitDest) {\n      // Dest array looks like that: <page-ref> </XYZ|/FitXXX> <args..>\n      const destRef = explicitDest[0];\n      let pageNumber;\n\n      if (destRef instanceof Object) {\n        pageNumber = this._cachedPageNumber(destRef);\n\n        if (pageNumber === null) {\n          // Fetch the page reference if it's not yet available. This could\n          // only occur during loading, before all pages have been resolved.\n          this.pdfDocument\n            .getPageIndex(destRef)\n            .then(pageIndex => {\n              this.cachePageRef(pageIndex + 1, destRef);\n              this._goToDestinationHelper(rawDest, namedDest, explicitDest);\n            })\n            .catch(() => {\n              console.error(\n                `PDFLinkService._goToDestinationHelper: \"${destRef}\" is not ` +\n                  `a valid page reference, for dest=\"${rawDest}\".`\n              );\n            });\n          return;\n        }\n      } else if (Number.isInteger(destRef)) {\n        pageNumber = destRef + 1;\n      } else {\n        console.error(\n          `PDFLinkService._goToDestinationHelper: \"${destRef}\" is not ` +\n            `a valid destination reference, for dest=\"${rawDest}\".`\n        );\n        return;\n      }\n      if (!pageNumber || pageNumber < 1 || pageNumber > this.pagesCount) {\n        console.error(\n          `PDFLinkService._goToDestinationHelper: \"${pageNumber}\" is not ` +\n            `a valid page number, for dest=\"${rawDest}\".`\n        );\n        return;\n      }\n\n      if (this.pdfHistory) {\n        // Update the browser history before scrolling the new destination into\n        // view, to be able to accurately capture the current document position.\n        this.pdfHistory.pushCurrentPosition();\n        this.pdfHistory.push({ namedDest, explicitDest, pageNumber });\n      }\n\n      this.pdfViewer.scrollPageIntoView({\n        pageNumber,\n        destArray: explicitDest,\n        ignoreDestinationZoom: this._ignoreDestinationZoom,\n      });\n    }\n\n    /**\n     * This method will, when available, also update the browser history.\n     *\n     * @param {string|Array} dest - The named, or explicit, PDF destination.\n     */\n    async goToDestination(dest) {\n      if (!this.pdfDocument) {\n        return;\n      }\n      let namedDest, explicitDest;\n      if (typeof dest === \"string\") {\n        namedDest = dest;\n        explicitDest = await this.pdfDocument.getDestination(dest);\n      } else {\n        namedDest = null;\n        explicitDest = await dest;\n      }\n      if (!Array.isArray(explicitDest)) {\n        console.error(\n          `PDFLinkService.goToDestination: \"${explicitDest}\" is not ` +\n            `a valid destination array, for dest=\"${dest}\".`\n        );\n        return;\n      }\n      this._goToDestinationHelper(dest, namedDest, explicitDest);\n    }\n\n    /**\n     * This method will, when available, also update the browser history.\n     *\n     * @param {number|string} val - The page number, or page label.\n     */\n    goToPage(val) {\n      if (!this.pdfDocument) {\n        return;\n      }\n      const pageNumber =\n        (typeof val === \"string\" && this.pdfViewer.pageLabelToPageNumber(val)) ||\n        val | 0;\n      if (\n        !(\n          Number.isInteger(pageNumber) &&\n          pageNumber > 0 &&\n          pageNumber <= this.pagesCount\n        )\n      ) {\n        console.error(`PDFLinkService.goToPage: \"${val}\" is not a valid page.`);\n        return;\n      }\n\n      if (this.pdfHistory) {\n        // Update the browser history before scrolling the new page into view,\n        // to be able to accurately capture the current document position.\n        this.pdfHistory.pushCurrentPosition();\n        this.pdfHistory.pushPage(pageNumber);\n      }\n\n      this.pdfViewer.scrollPageIntoView({ pageNumber });\n    }\n\n    /**\n     * @param {string|Array} dest - The PDF destination object.\n     * @returns {string} The hyperlink to the PDF object.\n     */\n    getDestinationHash(dest) {\n      if (typeof dest === \"string\") {\n        if (dest.length > 0) {\n          return this.getAnchorUrl(\"#\" + escape(dest));\n        }\n      } else if (Array.isArray(dest)) {\n        const str = JSON.stringify(dest);\n        if (str.length > 0) {\n          return this.getAnchorUrl(\"#\" + escape(str));\n        }\n      }\n      return this.getAnchorUrl(\"\");\n    }\n\n    /**\n     * Prefix the full url on anchor links to make sure that links are resolved\n     * relative to the current URL instead of the one defined in <base href>.\n     * @param {string} anchor - The anchor hash, including the #.\n     * @returns {string} The hyperlink to the PDF object.\n     */\n    getAnchorUrl(anchor) {\n      return (this.baseUrl || \"\") + anchor;\n    }\n\n    /**\n     * @param {string} hash\n     */\n    setHash(hash) {\n      if (!this.pdfDocument) {\n        return;\n      }\n      let pageNumber, dest;\n      if (hash.includes(\"=\")) {\n        const params = parseQueryString(hash);\n        if (\"search\" in params) {\n          this.eventBus.dispatch(\"findfromurlhash\", {\n            source: this,\n            query: params.search.replace(/\"/g, \"\"),\n            phraseSearch: params.phrase === \"true\",\n          });\n        }\n        // borrowing syntax from \"Parameters for Opening PDF Files\"\n        if (\"page\" in params) {\n          pageNumber = params.page | 0 || 1;\n        }\n        if (\"zoom\" in params) {\n          // Build the destination array.\n          const zoomArgs = params.zoom.split(\",\"); // scale,left,top\n          const zoomArg = zoomArgs[0];\n          const zoomArgNumber = parseFloat(zoomArg);\n\n          if (!zoomArg.includes(\"Fit\")) {\n            // If the zoomArg is a number, it has to get divided by 100. If it's\n            // a string, it should stay as it is.\n            dest = [\n              null,\n              { name: \"XYZ\" },\n              zoomArgs.length > 1 ? zoomArgs[1] | 0 : null,\n              zoomArgs.length > 2 ? zoomArgs[2] | 0 : null,\n              zoomArgNumber ? zoomArgNumber / 100 : zoomArg,\n            ];\n          } else {\n            if (zoomArg === \"Fit\" || zoomArg === \"FitB\") {\n              dest = [null, { name: zoomArg }];\n            } else if (\n              zoomArg === \"FitH\" ||\n              zoomArg === \"FitBH\" ||\n              zoomArg === \"FitV\" ||\n              zoomArg === \"FitBV\"\n            ) {\n              dest = [\n                null,\n                { name: zoomArg },\n                zoomArgs.length > 1 ? zoomArgs[1] | 0 : null,\n              ];\n            } else if (zoomArg === \"FitR\") {\n              if (zoomArgs.length !== 5) {\n                console.error(\n                  'PDFLinkService.setHash: Not enough parameters for \"FitR\".'\n                );\n              } else {\n                dest = [\n                  null,\n                  { name: zoomArg },\n                  zoomArgs[1] | 0,\n                  zoomArgs[2] | 0,\n                  zoomArgs[3] | 0,\n                  zoomArgs[4] | 0,\n                ];\n              }\n            } else {\n              console.error(\n                `PDFLinkService.setHash: \"${zoomArg}\" is not ` +\n                  \"a valid zoom value.\"\n              );\n            }\n          }\n        }\n        if (dest) {\n          this.pdfViewer.scrollPageIntoView({\n            pageNumber: pageNumber || this.page,\n            destArray: dest,\n            allowNegativeOffset: true,\n          });\n        } else if (pageNumber) {\n          this.page = pageNumber; // simple page\n        }\n        if (\"pagemode\" in params) {\n          this.eventBus.dispatch(\"pagemode\", {\n            source: this,\n            mode: params.pagemode,\n          });\n        }\n        // Ensure that this parameter is *always* handled last, in order to\n        // guarantee that it won't be overridden (e.g. by the \"page\" parameter).\n        if (\"nameddest\" in params) {\n          this.goToDestination(params.nameddest);\n        }\n      } else {\n        // Named (or explicit) destination.\n        dest = unescape(hash);\n        try {\n          dest = JSON.parse(dest);\n\n          if (!Array.isArray(dest)) {\n            // Avoid incorrectly rejecting a valid named destination, such as\n            // e.g. \"4.3\" or \"true\", because `JSON.parse` converted its type.\n            dest = dest.toString();\n          }\n        } catch (ex) {}\n\n        if (typeof dest === \"string\" || isValidExplicitDestination(dest)) {\n          this.goToDestination(dest);\n          return;\n        }\n        console.error(\n          `PDFLinkService.setHash: \"${unescape(hash)}\" is not ` +\n            \"a valid destination.\"\n        );\n      }\n    }\n\n    /**\n     * @param {string} action\n     */\n    executeNamedAction(action) {\n      // See PDF reference, table 8.45 - Named action\n      switch (action) {\n        case \"GoBack\":\n          if (this.pdfHistory) {\n            this.pdfHistory.back();\n          }\n          break;\n\n        case \"GoForward\":\n          if (this.pdfHistory) {\n            this.pdfHistory.forward();\n          }\n          break;\n\n        case \"NextPage\":\n          this.pdfViewer.nextPage();\n          break;\n\n        case \"PrevPage\":\n          this.pdfViewer.previousPage();\n          break;\n\n        case \"LastPage\":\n          this.page = this.pagesCount;\n          break;\n\n        case \"FirstPage\":\n          this.page = 1;\n          break;\n\n        default:\n          break; // No action according to spec\n      }\n\n      this.eventBus.dispatch(\"namedaction\", {\n        source: this,\n        action,\n      });\n    }\n\n    /**\n     * @param {number} pageNum - page number.\n     * @param {Object} pageRef - reference to the page.\n     */\n    cachePageRef(pageNum, pageRef) {\n      if (!pageRef) {\n        return;\n      }\n      const refStr =\n        pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`;\n      this._pagesRefCache[refStr] = pageNum;\n    }\n\n    /**\n     * @private\n     */\n    _cachedPageNumber(pageRef) {\n      const refStr =\n        pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`;\n      return (this._pagesRefCache && this._pagesRefCache[refStr]) || null;\n    }\n\n    /**\n     * @param {number} pageNumber\n     */\n    isPageVisible(pageNumber) {\n      return this.pdfViewer.isPageVisible(pageNumber);\n    }\n\n    /**\n     * @param {number} pageNumber\n     */\n    isPageCached(pageNumber) {\n      return this.pdfViewer.isPageCached(pageNumber);\n    }\n  }\n\n  function isValidExplicitDestination(dest) {\n    if (!Array.isArray(dest)) {\n      return false;\n    }\n    const destLength = dest.length;\n    if (destLength < 2) {\n      return false;\n    }\n    const page = dest[0];\n    if (\n      !(\n        typeof page === \"object\" &&\n        Number.isInteger(page.num) &&\n        Number.isInteger(page.gen)\n      ) &&\n      !(Number.isInteger(page) && page >= 0)\n    ) {\n      return false;\n    }\n    const zoom = dest[1];\n    if (!(typeof zoom === \"object\" && typeof zoom.name === \"string\")) {\n      return false;\n    }\n    let allowNull = true;\n    switch (zoom.name) {\n      case \"XYZ\":\n        if (destLength !== 5) {\n          return false;\n        }\n        break;\n      case \"Fit\":\n      case \"FitB\":\n        return destLength === 2;\n      case \"FitH\":\n      case \"FitBH\":\n      case \"FitV\":\n      case \"FitBV\":\n        if (destLength !== 3) {\n          return false;\n        }\n        break;\n      case \"FitR\":\n        if (destLength !== 6) {\n          return false;\n        }\n        allowNull = false;\n        break;\n      default:\n        return false;\n    }\n    for (let i = 2; i < destLength; i++) {\n      const param = dest[i];\n      if (!(typeof param === \"number\" || (allowNull && param === null))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @implements {IPDFLinkService}\n   */\n  class SimpleLinkService {\n    constructor() {\n      this.externalLinkTarget = null;\n      this.externalLinkRel = null;\n      this.externalLinkEnabled = true;\n      this._ignoreDestinationZoom = false;\n    }\n\n    /**\n     * @type {number}\n     */\n    get pagesCount() {\n      return 0;\n    }\n\n    /**\n     * @type {number}\n     */\n    get page() {\n      return 0;\n    }\n\n    /**\n     * @param {number} value\n     */\n    set page(value) {}\n\n    /**\n     * @type {number}\n     */\n    get rotation() {\n      return 0;\n    }\n\n    /**\n     * @param {number} value\n     */\n    set rotation(value) {}\n\n    /**\n     * @param {string|Array} dest - The named, or explicit, PDF destination.\n     */\n    async goToDestination(dest) {}\n\n    /**\n     * @param {number|string} val - The page number, or page label.\n     */\n    goToPage(val) {}\n\n    /**\n     * @param dest - The PDF destination object.\n     * @returns {string} The hyperlink to the PDF object.\n     */\n    getDestinationHash(dest) {\n      return \"#\";\n    }\n\n    /**\n     * @param hash - The PDF parameters/hash.\n     * @returns {string} The hyperlink to the PDF object.\n     */\n    getAnchorUrl(hash) {\n      return \"#\";\n    }\n\n    /**\n     * @param {string} hash\n     */\n    setHash(hash) {}\n\n    /**\n     * @param {string} action\n     */\n    executeNamedAction(action) {}\n\n    /**\n     * @param {number} pageNum - page number.\n     * @param {Object} pageRef - reference to the page.\n     */\n    cachePageRef(pageNum, pageRef) {}\n\n    /**\n     * @param {number} pageNumber\n     */\n    isPageVisible(pageNumber) {\n      return true;\n    }\n\n    /**\n     * @param {number} pageNumber\n     */\n    isPageCached(pageNumber) {\n      return true;\n    }\n  }\n\n  return { PDFLinkService, SimpleLinkService };\n});\ndefine('skylark-pdfjs-viewer/pdf_outline_viewer',[\n  \"skylark-pdfjs-display\",\n  \"./ui_utils\",\n  \"./base_tree_viewer\"\n],function(pdfjsLib,ui_utils,base_tree_viewer){\n  /* Copyright 2012 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const {\n    addLinkAttributes,\n    createPromiseCapability,\n    LinkTarget,\n  } = pdfjsLib;\n\n  const { BaseTreeViewer } = base_tree_viewer;\n  const { SidebarView } = ui_utils;\n\n  /**\n   * @typedef {Object} PDFOutlineViewerOptions\n   * @property {HTMLDivElement} container - The viewer element.\n   * @property {IPDFLinkService} linkService - The navigation/linking service.\n   * @property {EventBus} eventBus - The application event bus.\n   */\n\n  /**\n   * @typedef {Object} PDFOutlineViewerRenderParameters\n   * @property {Array|null} outline - An array of outline objects.\n   * @property {PDFDocument} pdfDocument - A {PDFDocument} instance.\n   */\n\n  class PDFOutlineViewer extends BaseTreeViewer {\n    /**\n     * @param {PDFOutlineViewerOptions} options\n     */\n    constructor(options) {\n      super(options);\n      this.linkService = options.linkService;\n\n      this.eventBus._on(\"toggleoutlinetree\", this._toggleAllTreeItems.bind(this));\n      this.eventBus._on(\n        \"currentoutlineitem\",\n        this._currentOutlineItem.bind(this)\n      );\n\n      this.eventBus._on(\"pagechanging\", evt => {\n        this._currentPageNumber = evt.pageNumber;\n      });\n      this.eventBus._on(\"pagesloaded\", evt => {\n        this._isPagesLoaded = !!evt.pagesCount;\n      });\n      this.eventBus._on(\"sidebarviewchanged\", evt => {\n        this._sidebarView = evt.view;\n      });\n    }\n\n    reset() {\n      super.reset();\n      this._outline = null;\n\n      this._pageNumberToDestHashCapability = null;\n      this._currentPageNumber = 1;\n      this._isPagesLoaded = false;\n    }\n\n    /**\n     * @private\n     */\n    _dispatchEvent(outlineCount) {\n      this.eventBus.dispatch(\"outlineloaded\", {\n        source: this,\n        outlineCount,\n        enableCurrentOutlineItemButton:\n          ///outlineCount > 0 && !this._pdfDocument?.loadingParams.disableAutoFetch, // lwf\n          outlineCount > 0 && !(this._pdfDocument && this._pdfDocument.loadingParams.disableAutoFetch),\n      });\n    }\n\n    /**\n     * @private\n     */\n    _bindLink(element, { url, newWindow, dest }) {\n      const { linkService } = this;\n\n      if (url) {\n        addLinkAttributes(element, {\n          url,\n          target: newWindow ? LinkTarget.BLANK : linkService.externalLinkTarget,\n          rel: linkService.externalLinkRel,\n          enabled: linkService.externalLinkEnabled,\n        });\n        return;\n      }\n\n      element.href = linkService.getDestinationHash(dest);\n      element.onclick = evt => {\n        this._updateCurrentTreeItem(evt.target.parentNode);\n\n        if (dest) {\n          linkService.goToDestination(dest);\n        }\n        return false;\n      };\n    }\n\n    /**\n     * @private\n     */\n    _setStyles(element, { bold, italic }) {\n      if (bold) {\n        element.style.fontWeight = \"bold\";\n      }\n      if (italic) {\n        element.style.fontStyle = \"italic\";\n      }\n    }\n\n    /**\n     * @private\n     */\n    _addToggleButton(div, { count, items }) {\n      let hidden = false;\n      if (count < 0) {\n        let totalCount = items.length;\n        if (totalCount > 0) {\n          const queue = [...items];\n          while (queue.length > 0) {\n            const { count: nestedCount, items: nestedItems } = queue.shift();\n            if (nestedCount > 0 && nestedItems.length > 0) {\n              totalCount += nestedItems.length;\n              queue.push(...nestedItems);\n            }\n          }\n        }\n        if (Math.abs(count) === totalCount) {\n          hidden = true;\n        }\n      }\n      super._addToggleButton(div, hidden);\n    }\n\n    /**\n     * @private\n     */\n    _toggleAllTreeItems() {\n      if (!this._outline) {\n        return;\n      }\n      super._toggleAllTreeItems();\n    }\n\n    /**\n     * @param {PDFOutlineViewerRenderParameters} params\n     */\n    render({ outline, pdfDocument }) {\n      if (this._outline) {\n        this.reset();\n      }\n      this._outline = outline || null;\n      this._pdfDocument = pdfDocument || null;\n\n      if (!outline) {\n        this._dispatchEvent(/* outlineCount = */ 0);\n        return;\n      }\n\n      const fragment = document.createDocumentFragment();\n      const queue = [{ parent: fragment, items: outline }];\n      let outlineCount = 0,\n        hasAnyNesting = false;\n      while (queue.length > 0) {\n        const levelData = queue.shift();\n        for (const item of levelData.items) {\n          const div = document.createElement(\"div\");\n          div.className = \"treeItem\";\n\n          const element = document.createElement(\"a\");\n          this._bindLink(element, item);\n          this._setStyles(element, item);\n          element.textContent = this._normalizeTextContent(item.title);\n\n          div.appendChild(element);\n\n          if (item.items.length > 0) {\n            hasAnyNesting = true;\n            this._addToggleButton(div, item);\n\n            const itemsDiv = document.createElement(\"div\");\n            itemsDiv.className = \"treeItems\";\n            div.appendChild(itemsDiv);\n\n            queue.push({ parent: itemsDiv, items: item.items });\n          }\n\n          levelData.parent.appendChild(div);\n          outlineCount++;\n        }\n      }\n\n      this._finishRendering(fragment, outlineCount, hasAnyNesting);\n    }\n\n    /**\n     * Find/highlight the current outline item, corresponding to the active page.\n     * @private\n     */\n    async _currentOutlineItem() {\n      if (!this._isPagesLoaded) {\n        throw new Error(\"_currentOutlineItem: All pages have not been loaded.\");\n      }\n      if (!this._outline || !this._pdfDocument) {\n        return;\n      }\n\n      const pageNumberToDestHash = await this._getPageNumberToDestHash(\n        this._pdfDocument\n      );\n      if (!pageNumberToDestHash) {\n        return;\n      }\n      this._updateCurrentTreeItem(/* treeItem = */ null);\n\n      if (this._sidebarView !== SidebarView.OUTLINE) {\n        return; // The outline view is no longer visible, hence do nothing.\n      }\n      // When there is no destination on the current page, always check the\n      // previous ones in (reverse) order.\n      for (let i = this._currentPageNumber; i > 0; i--) {\n        const destHash = pageNumberToDestHash.get(i);\n        if (!destHash) {\n          continue;\n        }\n        const linkElement = this.container.querySelector(`a[href=\"${destHash}\"]`);\n        if (!linkElement) {\n          continue;\n        }\n        this._scrollToCurrentTreeItem(linkElement.parentNode);\n        break;\n      }\n    }\n\n    /**\n     * To (significantly) simplify the overall implementation, we will only\n     * consider *one* destination per page when finding/highlighting the current\n     * outline item (similar to e.g. Adobe Reader); more specifically, we choose\n     * the *first* outline item at the *lowest* level of the outline tree.\n     * @private\n     */\n    async _getPageNumberToDestHash(pdfDocument) {\n      if (this._pageNumberToDestHashCapability) {\n        return this._pageNumberToDestHashCapability.promise;\n      }\n      this._pageNumberToDestHashCapability = createPromiseCapability();\n\n      const pageNumberToDestHash = new Map(),\n        pageNumberNesting = new Map();\n      const queue = [{ nesting: 0, items: this._outline }];\n      while (queue.length > 0) {\n        const levelData = queue.shift(),\n          currentNesting = levelData.nesting;\n        for (const { dest, items } of levelData.items) {\n          let explicitDest, pageNumber;\n          if (typeof dest === \"string\") {\n            explicitDest = await pdfDocument.getDestination(dest);\n\n            if (pdfDocument !== this._pdfDocument) {\n              return null; // The document was closed while the data resolved.\n            }\n          } else {\n            explicitDest = dest;\n          }\n          if (Array.isArray(explicitDest)) {\n            const [destRef] = explicitDest;\n\n            if (typeof destRef === \"object\") {\n              pageNumber = this.linkService._cachedPageNumber(destRef);\n\n              if (!pageNumber) {\n                try {\n                  pageNumber = (await pdfDocument.getPageIndex(destRef)) + 1;\n\n                  if (pdfDocument !== this._pdfDocument) {\n                    return null; // The document was closed while the data resolved.\n                  }\n                  this.linkService.cachePageRef(pageNumber, destRef);\n                } catch (ex) {\n                  // Invalid page reference, ignore it and continue parsing.\n                }\n              }\n            } else if (Number.isInteger(destRef)) {\n              pageNumber = destRef + 1;\n            }\n\n            if (\n              Number.isInteger(pageNumber) &&\n              (!pageNumberToDestHash.has(pageNumber) ||\n                currentNesting > pageNumberNesting.get(pageNumber))\n            ) {\n              const destHash = this.linkService.getDestinationHash(dest);\n              pageNumberToDestHash.set(pageNumber, destHash);\n              pageNumberNesting.set(pageNumber, currentNesting);\n            }\n          }\n\n          if (items.length > 0) {\n            queue.push({ nesting: currentNesting + 1, items });\n          }\n        }\n      }\n\n      this._pageNumberToDestHashCapability.resolve(\n        pageNumberToDestHash.size > 0 ? pageNumberToDestHash : null\n      );\n      return this._pageNumberToDestHashCapability.promise;\n    }\n  }\n\n  return { PDFOutlineViewer };\n});\ndefine('skylark-pdfjs-viewer/pdf_presentation_mode',[\n  \"./pdfjs_dev\",\n  \"./ui_utils\",\n],function(\n  PDFJSDev,\n  ui_utils\n){\n  /* Copyright 2012 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { normalizeWheelEventDelta, PresentationModeState } = ui_utils;\n\n  const DELAY_BEFORE_RESETTING_SWITCH_IN_PROGRESS = 1500; // in ms\n  const DELAY_BEFORE_HIDING_CONTROLS = 3000; // in ms\n  const ACTIVE_SELECTOR = \"pdfPresentationMode\";\n  const CONTROLS_SELECTOR = \"pdfPresentationModeControls\";\n  const MOUSE_SCROLL_COOLDOWN_TIME = 50; // in ms\n  const PAGE_SWITCH_THRESHOLD = 0.1;\n\n  // Number of CSS pixels for a movement to count as a swipe.\n  const SWIPE_MIN_DISTANCE_THRESHOLD = 50;\n\n  // Swipe angle deviation from the x or y axis before it is not\n  // considered a swipe in that direction any more.\n  const SWIPE_ANGLE_THRESHOLD = Math.PI / 6;\n\n  /**\n   * @typedef {Object} PDFPresentationModeOptions\n   * @property {HTMLDivElement} container - The container for the viewer element.\n   * @property {PDFViewer} pdfViewer - The document viewer.\n   * @property {EventBus} eventBus - The application event bus.\n   * @property {Array} [contextMenuItems] - The menu items that are added to the\n   *   context menu in Presentation Mode.\n   */\n\n  class PDFPresentationMode {\n    /**\n     * @param {PDFPresentationModeOptions} options\n     */\n    constructor({ container, pdfViewer, eventBus, contextMenuItems = null }) {\n      this.container = container;\n      this.pdfViewer = pdfViewer;\n      this.eventBus = eventBus;\n\n      this.active = false;\n      this.args = null;\n      this.contextMenuOpen = false;\n      this.mouseScrollTimeStamp = 0;\n      this.mouseScrollDelta = 0;\n      this.touchSwipeState = null;\n\n      if (contextMenuItems) {\n        contextMenuItems.contextFirstPage.addEventListener(\"click\", () => {\n          this.contextMenuOpen = false;\n          this.eventBus.dispatch(\"firstpage\", { source: this });\n        });\n        contextMenuItems.contextLastPage.addEventListener(\"click\", () => {\n          this.contextMenuOpen = false;\n          this.eventBus.dispatch(\"lastpage\", { source: this });\n        });\n        contextMenuItems.contextPageRotateCw.addEventListener(\"click\", () => {\n          this.contextMenuOpen = false;\n          this.eventBus.dispatch(\"rotatecw\", { source: this });\n        });\n        contextMenuItems.contextPageRotateCcw.addEventListener(\"click\", () => {\n          this.contextMenuOpen = false;\n          this.eventBus.dispatch(\"rotateccw\", { source: this });\n        });\n      }\n    }\n\n    /**\n     * Request the browser to enter fullscreen mode.\n     * @returns {boolean} Indicating if the request was successful.\n     */\n    request() {\n      if (this.switchInProgress || this.active || !this.pdfViewer.pagesCount) {\n        return false;\n      }\n      this._addFullscreenChangeListeners();\n      this._setSwitchInProgress();\n      this._notifyStateChange();\n\n      if (this.container.requestFullscreen) {\n        this.container.requestFullscreen();\n      } else if (this.container.mozRequestFullScreen) {\n        this.container.mozRequestFullScreen();\n      } else if (this.container.webkitRequestFullscreen) {\n        this.container.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);\n      } else {\n        return false;\n      }\n\n      this.args = {\n        page: this.pdfViewer.currentPageNumber,\n        previousScale: this.pdfViewer.currentScaleValue,\n      };\n\n      return true;\n    }\n\n    /**\n     * @private\n     */\n    _mouseWheel(evt) {\n      if (!this.active) {\n        return;\n      }\n\n      evt.preventDefault();\n\n      const delta = normalizeWheelEventDelta(evt);\n      const currentTime = new Date().getTime();\n      const storedTime = this.mouseScrollTimeStamp;\n\n      // If we've already switched page, avoid accidentally switching again.\n      if (\n        currentTime > storedTime &&\n        currentTime - storedTime < MOUSE_SCROLL_COOLDOWN_TIME\n      ) {\n        return;\n      }\n      // If the scroll direction changed, reset the accumulated scroll delta.\n      if (\n        (this.mouseScrollDelta > 0 && delta < 0) ||\n        (this.mouseScrollDelta < 0 && delta > 0)\n      ) {\n        this._resetMouseScrollState();\n      }\n      this.mouseScrollDelta += delta;\n\n      if (Math.abs(this.mouseScrollDelta) >= PAGE_SWITCH_THRESHOLD) {\n        const totalDelta = this.mouseScrollDelta;\n        this._resetMouseScrollState();\n        const success =\n          totalDelta > 0\n            ? this.pdfViewer.previousPage()\n            : this.pdfViewer.nextPage();\n        if (success) {\n          this.mouseScrollTimeStamp = currentTime;\n        }\n      }\n    }\n\n    get isFullscreen() {\n      return !!(\n        document.fullscreenElement ||\n        document.mozFullScreen ||\n        document.webkitIsFullScreen\n      );\n    }\n\n    /**\n     * @private\n     */\n    _notifyStateChange() {\n      let state = PresentationModeState.NORMAL;\n      if (this.switchInProgress) {\n        state = PresentationModeState.CHANGING;\n      } else if (this.active) {\n        state = PresentationModeState.FULLSCREEN;\n      }\n\n      if (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"MOZCENTRAL\")) {\n        this.eventBus.dispatch(\"presentationmodechanged\", {\n          source: this,\n          state,\n        });\n      } else {\n        this.eventBus.dispatch(\"presentationmodechanged\", {\n          source: this,\n          state,\n          get active() {\n            throw new Error(\n              \"Deprecated parameter: `active`, please use `state` instead.\"\n            );\n          },\n          get switchInProgress() {\n            throw new Error(\n              \"Deprecated parameter: `switchInProgress`, please use `state` instead.\"\n            );\n          },\n        });\n      }\n    }\n\n    /**\n     * Used to initialize a timeout when requesting Presentation Mode,\n     * i.e. when the browser is requested to enter fullscreen mode.\n     * This timeout is used to prevent the current page from being scrolled\n     * partially, or completely, out of view when entering Presentation Mode.\n     * NOTE: This issue seems limited to certain zoom levels (e.g. page-width).\n     *\n     * @private\n     */\n    _setSwitchInProgress() {\n      if (this.switchInProgress) {\n        clearTimeout(this.switchInProgress);\n      }\n      this.switchInProgress = setTimeout(() => {\n        this._removeFullscreenChangeListeners();\n        delete this.switchInProgress;\n        this._notifyStateChange();\n      }, DELAY_BEFORE_RESETTING_SWITCH_IN_PROGRESS);\n    }\n\n    /**\n     * @private\n     */\n    _resetSwitchInProgress() {\n      if (this.switchInProgress) {\n        clearTimeout(this.switchInProgress);\n        delete this.switchInProgress;\n      }\n    }\n\n    /**\n     * @private\n     */\n    _enter() {\n      this.active = true;\n      this._resetSwitchInProgress();\n      this._notifyStateChange();\n      this.container.classList.add(ACTIVE_SELECTOR);\n\n      // Ensure that the correct page is scrolled into view when entering\n      // Presentation Mode, by waiting until fullscreen mode in enabled.\n      setTimeout(() => {\n        this.pdfViewer.currentPageNumber = this.args.page;\n        this.pdfViewer.currentScaleValue = \"page-fit\";\n      }, 0);\n\n      this._addWindowListeners();\n      this._showControls();\n      this.contextMenuOpen = false;\n      this.container.setAttribute(\"contextmenu\", \"viewerContextMenu\");\n\n      // Text selection is disabled in Presentation Mode, thus it's not possible\n      // for the user to deselect text that is selected (e.g. with \"Select all\")\n      // when entering Presentation Mode, hence we remove any active selection.\n      window.getSelection().removeAllRanges();\n    }\n\n    /**\n     * @private\n     */\n    _exit() {\n      const page = this.pdfViewer.currentPageNumber;\n      this.container.classList.remove(ACTIVE_SELECTOR);\n\n      // Ensure that the correct page is scrolled into view when exiting\n      // Presentation Mode, by waiting until fullscreen mode is disabled.\n      setTimeout(() => {\n        this.active = false;\n        this._removeFullscreenChangeListeners();\n        this._notifyStateChange();\n\n        this.pdfViewer.currentScaleValue = this.args.previousScale;\n        this.pdfViewer.currentPageNumber = page;\n        this.args = null;\n      }, 0);\n\n      this._removeWindowListeners();\n      this._hideControls();\n      this._resetMouseScrollState();\n      this.container.removeAttribute(\"contextmenu\");\n      this.contextMenuOpen = false;\n    }\n\n    /**\n     * @private\n     */\n    _mouseDown(evt) {\n      if (this.contextMenuOpen) {\n        this.contextMenuOpen = false;\n        evt.preventDefault();\n        return;\n      }\n      if (evt.button === 0) {\n        // Enable clicking of links in presentation mode. Note: only links\n        // pointing to destinations in the current PDF document work.\n        const isInternalLink =\n          evt.target.href && evt.target.classList.contains(\"internalLink\");\n        if (!isInternalLink) {\n          // Unless an internal link was clicked, advance one page.\n          evt.preventDefault();\n\n          if (evt.shiftKey) {\n            this.pdfViewer.previousPage();\n          } else {\n            this.pdfViewer.nextPage();\n          }\n        }\n      }\n    }\n\n    /**\n     * @private\n     */\n    _contextMenu() {\n      this.contextMenuOpen = true;\n    }\n\n    /**\n     * @private\n     */\n    _showControls() {\n      if (this.controlsTimeout) {\n        clearTimeout(this.controlsTimeout);\n      } else {\n        this.container.classList.add(CONTROLS_SELECTOR);\n      }\n      this.controlsTimeout = setTimeout(() => {\n        this.container.classList.remove(CONTROLS_SELECTOR);\n        delete this.controlsTimeout;\n      }, DELAY_BEFORE_HIDING_CONTROLS);\n    }\n\n    /**\n     * @private\n     */\n    _hideControls() {\n      if (!this.controlsTimeout) {\n        return;\n      }\n      clearTimeout(this.controlsTimeout);\n      this.container.classList.remove(CONTROLS_SELECTOR);\n      delete this.controlsTimeout;\n    }\n\n    /**\n     * Resets the properties used for tracking mouse scrolling events.\n     *\n     * @private\n     */\n    _resetMouseScrollState() {\n      this.mouseScrollTimeStamp = 0;\n      this.mouseScrollDelta = 0;\n    }\n\n    /**\n     * @private\n     */\n    _touchSwipe(evt) {\n      if (!this.active) {\n        return;\n      }\n      if (evt.touches.length > 1) {\n        // Multiple touch points detected; cancel the swipe.\n        this.touchSwipeState = null;\n        return;\n      }\n\n      switch (evt.type) {\n        case \"touchstart\":\n          this.touchSwipeState = {\n            startX: evt.touches[0].pageX,\n            startY: evt.touches[0].pageY,\n            endX: evt.touches[0].pageX,\n            endY: evt.touches[0].pageY,\n          };\n          break;\n        case \"touchmove\":\n          if (this.touchSwipeState === null) {\n            return;\n          }\n          this.touchSwipeState.endX = evt.touches[0].pageX;\n          this.touchSwipeState.endY = evt.touches[0].pageY;\n          // Avoid the swipe from triggering browser gestures (Chrome in\n          // particular has some sort of swipe gesture in fullscreen mode).\n          evt.preventDefault();\n          break;\n        case \"touchend\":\n          if (this.touchSwipeState === null) {\n            return;\n          }\n          let delta = 0;\n          const dx = this.touchSwipeState.endX - this.touchSwipeState.startX;\n          const dy = this.touchSwipeState.endY - this.touchSwipeState.startY;\n          const absAngle = Math.abs(Math.atan2(dy, dx));\n          if (\n            Math.abs(dx) > SWIPE_MIN_DISTANCE_THRESHOLD &&\n            (absAngle <= SWIPE_ANGLE_THRESHOLD ||\n              absAngle >= Math.PI - SWIPE_ANGLE_THRESHOLD)\n          ) {\n            // Horizontal swipe.\n            delta = dx;\n          } else if (\n            Math.abs(dy) > SWIPE_MIN_DISTANCE_THRESHOLD &&\n            Math.abs(absAngle - Math.PI / 2) <= SWIPE_ANGLE_THRESHOLD\n          ) {\n            // Vertical swipe.\n            delta = dy;\n          }\n          if (delta > 0) {\n            this.pdfViewer.previousPage();\n          } else if (delta < 0) {\n            this.pdfViewer.nextPage();\n          }\n          break;\n      }\n    }\n\n    /**\n     * @private\n     */\n    _addWindowListeners() {\n      this.showControlsBind = this._showControls.bind(this);\n      this.mouseDownBind = this._mouseDown.bind(this);\n      this.mouseWheelBind = this._mouseWheel.bind(this);\n      this.resetMouseScrollStateBind = this._resetMouseScrollState.bind(this);\n      this.contextMenuBind = this._contextMenu.bind(this);\n      this.touchSwipeBind = this._touchSwipe.bind(this);\n\n      window.addEventListener(\"mousemove\", this.showControlsBind);\n      window.addEventListener(\"mousedown\", this.mouseDownBind);\n      window.addEventListener(\"wheel\", this.mouseWheelBind, { passive: false });\n      window.addEventListener(\"keydown\", this.resetMouseScrollStateBind);\n      window.addEventListener(\"contextmenu\", this.contextMenuBind);\n      window.addEventListener(\"touchstart\", this.touchSwipeBind);\n      window.addEventListener(\"touchmove\", this.touchSwipeBind);\n      window.addEventListener(\"touchend\", this.touchSwipeBind);\n    }\n\n    /**\n     * @private\n     */\n    _removeWindowListeners() {\n      window.removeEventListener(\"mousemove\", this.showControlsBind);\n      window.removeEventListener(\"mousedown\", this.mouseDownBind);\n      window.removeEventListener(\"wheel\", this.mouseWheelBind, {\n        passive: false,\n      });\n      window.removeEventListener(\"keydown\", this.resetMouseScrollStateBind);\n      window.removeEventListener(\"contextmenu\", this.contextMenuBind);\n      window.removeEventListener(\"touchstart\", this.touchSwipeBind);\n      window.removeEventListener(\"touchmove\", this.touchSwipeBind);\n      window.removeEventListener(\"touchend\", this.touchSwipeBind);\n\n      delete this.showControlsBind;\n      delete this.mouseDownBind;\n      delete this.mouseWheelBind;\n      delete this.resetMouseScrollStateBind;\n      delete this.contextMenuBind;\n      delete this.touchSwipeBind;\n    }\n\n    /**\n     * @private\n     */\n    _fullscreenChange() {\n      if (this.isFullscreen) {\n        this._enter();\n      } else {\n        this._exit();\n      }\n    }\n\n    /**\n     * @private\n     */\n    _addFullscreenChangeListeners() {\n      this.fullscreenChangeBind = this._fullscreenChange.bind(this);\n\n      window.addEventListener(\"fullscreenchange\", this.fullscreenChangeBind);\n      window.addEventListener(\"mozfullscreenchange\", this.fullscreenChangeBind);\n      if (typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"MOZCENTRAL\")) {\n        window.addEventListener(\n          \"webkitfullscreenchange\",\n          this.fullscreenChangeBind\n        );\n      }\n    }\n\n    /**\n     * @private\n     */\n    _removeFullscreenChangeListeners() {\n      window.removeEventListener(\"fullscreenchange\", this.fullscreenChangeBind);\n      window.removeEventListener(\n        \"mozfullscreenchange\",\n        this.fullscreenChangeBind\n      );\n      if (typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"MOZCENTRAL\")) {\n        window.removeEventListener(\n          \"webkitfullscreenchange\",\n          this.fullscreenChangeBind\n        );\n      }\n\n      delete this.fullscreenChangeBind;\n    }\n  }\n\n  return { PDFPresentationMode };\n});\ndefine('skylark-pdfjs-viewer/pdf_sidebar',[\n  \"./ui_utils\",\n  \"./pdf_rendering_queue\"\n],function(ui_utils,pdf_rendering_queue){\n  /* Copyright 2016 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { NullL10n, PresentationModeState, SidebarView } = ui_utils;\n  const { RenderingStates } = pdf_rendering_queue;\n\n  const UI_NOTIFICATION_CLASS = \"pdfSidebarNotification\";\n\n  /**\n   * @typedef {Object} PDFSidebarOptions\n   * @property {PDFSidebarElements} elements - The DOM elements.\n   * @property {PDFViewer} pdfViewer - The document viewer.\n   * @property {PDFThumbnailViewer} pdfThumbnailViewer - The thumbnail viewer.\n   * @property {EventBus} eventBus - The application event bus.\n   * @property {IL10n} l10n - The localization service.\n   */\n\n  /**\n   * @typedef {Object} PDFSidebarElements\n   * @property {HTMLDivElement} outerContainer - The outer container\n   *   (encasing both the viewer and sidebar elements).\n   * @property {HTMLDivElement} viewerContainer - The viewer container\n   *   (in which the viewer element is placed).\n   * @property {HTMLButtonElement} toggleButton - The button used for\n   *   opening/closing the sidebar.\n   * @property {HTMLButtonElement} thumbnailButton - The button used to show\n   *   the thumbnail view.\n   * @property {HTMLButtonElement} outlineButton - The button used to show\n   *   the outline view.\n   * @property {HTMLButtonElement} attachmentsButton - The button used to show\n   *   the attachments view.\n   * @property {HTMLButtonElement} layersButton - The button used to show\n   *   the layers view.\n   * @property {HTMLDivElement} thumbnailView - The container in which\n   *   the thumbnails are placed.\n   * @property {HTMLDivElement} outlineView - The container in which\n   *   the outline is placed.\n   * @property {HTMLDivElement} attachmentsView - The container in which\n   *   the attachments are placed.\n   * @property {HTMLDivElement} layersView - The container in which\n   *   the layers are placed.\n   * @property {HTMLDivElement} outlineOptionsContainer - The container in which\n   *   the outline view-specific option button(s) are placed.\n   * @property {HTMLButtonElement} currentOutlineItemButton - The button used to\n   *   find the current outline item.\n   */\n\n  class PDFSidebar {\n    /**\n     * @param {PDFSidebarOptions} options\n     */\n    constructor({\n      elements,\n      pdfViewer,\n      pdfThumbnailViewer,\n      eventBus,\n      l10n = NullL10n,\n    }) {\n      this.isOpen = false;\n      this.active = SidebarView.THUMBS;\n      this.isInitialViewSet = false;\n\n      /**\n       * Callback used when the sidebar has been opened/closed, to ensure that\n       * the viewers (PDFViewer/PDFThumbnailViewer) are updated correctly.\n       */\n      this.onToggled = null;\n\n      this.pdfViewer = pdfViewer;\n      this.pdfThumbnailViewer = pdfThumbnailViewer;\n\n      this.outerContainer = elements.outerContainer;\n      this.viewerContainer = elements.viewerContainer;\n      this.toggleButton = elements.toggleButton;\n\n      this.thumbnailButton = elements.thumbnailButton;\n      this.outlineButton = elements.outlineButton;\n      this.attachmentsButton = elements.attachmentsButton;\n      this.layersButton = elements.layersButton;\n\n      this.thumbnailView = elements.thumbnailView;\n      this.outlineView = elements.outlineView;\n      this.attachmentsView = elements.attachmentsView;\n      this.layersView = elements.layersView;\n\n      this._outlineOptionsContainer = elements.outlineOptionsContainer;\n      this._currentOutlineItemButton = elements.currentOutlineItemButton;\n\n      this.eventBus = eventBus;\n      this.l10n = l10n;\n\n      this._addEventListeners();\n    }\n\n    reset() {\n      this.isInitialViewSet = false;\n\n      this._hideUINotification(/* reset = */ true);\n      this.switchView(SidebarView.THUMBS);\n\n      this.outlineButton.disabled = false;\n      this.attachmentsButton.disabled = false;\n      this.layersButton.disabled = false;\n      this._currentOutlineItemButton.disabled = true;\n    }\n\n    /**\n     * @type {number} One of the values in {SidebarView}.\n     */\n    get visibleView() {\n      return this.isOpen ? this.active : SidebarView.NONE;\n    }\n\n    get isThumbnailViewVisible() {\n      return this.isOpen && this.active === SidebarView.THUMBS;\n    }\n\n    get isOutlineViewVisible() {\n      return this.isOpen && this.active === SidebarView.OUTLINE;\n    }\n\n    get isAttachmentsViewVisible() {\n      return this.isOpen && this.active === SidebarView.ATTACHMENTS;\n    }\n\n    get isLayersViewVisible() {\n      return this.isOpen && this.active === SidebarView.LAYERS;\n    }\n\n    /**\n     * @param {number} view - The sidebar view that should become visible,\n     *                        must be one of the values in {SidebarView}.\n     */\n    setInitialView(view = SidebarView.NONE) {\n      if (this.isInitialViewSet) {\n        return;\n      }\n      this.isInitialViewSet = true;\n\n      // If the user has already manually opened the sidebar, immediately closing\n      // it would be bad UX; also ignore the \"unknown\" sidebar view value.\n      if (view === SidebarView.NONE || view === SidebarView.UNKNOWN) {\n        this._dispatchEvent();\n        return;\n      }\n      // Prevent dispatching two back-to-back `sidebarviewchanged` events,\n      // since `this._switchView` dispatched the event if the view changed.\n      if (!this._switchView(view, /* forceOpen */ true)) {\n        this._dispatchEvent();\n      }\n    }\n\n    /**\n     * @param {number} view - The sidebar view that should be switched to,\n     *                        must be one of the values in {SidebarView}.\n     * @param {boolean} [forceOpen] - Ensure that the sidebar is open.\n     *                                The default value is `false`.\n     */\n    switchView(view, forceOpen = false) {\n      this._switchView(view, forceOpen);\n    }\n\n    /**\n     * @returns {boolean} Indicating if `this._dispatchEvent` was called.\n     * @private\n     */\n    _switchView(view, forceOpen = false) {\n      const isViewChanged = view !== this.active;\n      let shouldForceRendering = false;\n\n      switch (view) {\n        case SidebarView.NONE:\n          if (this.isOpen) {\n            this.close();\n            return true; // Closing will trigger rendering and dispatch the event.\n          }\n          return false;\n        case SidebarView.THUMBS:\n          if (this.isOpen && isViewChanged) {\n            shouldForceRendering = true;\n          }\n          break;\n        case SidebarView.OUTLINE:\n          if (this.outlineButton.disabled) {\n            return false;\n          }\n          break;\n        case SidebarView.ATTACHMENTS:\n          if (this.attachmentsButton.disabled) {\n            return false;\n          }\n          break;\n        case SidebarView.LAYERS:\n          if (this.layersButton.disabled) {\n            return false;\n          }\n          break;\n        default:\n          console.error(`PDFSidebar._switchView: \"${view}\" is not a valid view.`);\n          return false;\n      }\n      // Update the active view *after* it has been validated above,\n      // in order to prevent setting it to an invalid state.\n      this.active = view;\n\n      // Update the CSS classes, for all buttons...\n      this.thumbnailButton.classList.toggle(\n        \"toggled\",\n        view === SidebarView.THUMBS\n      );\n      this.outlineButton.classList.toggle(\n        \"toggled\",\n        view === SidebarView.OUTLINE\n      );\n      this.attachmentsButton.classList.toggle(\n        \"toggled\",\n        view === SidebarView.ATTACHMENTS\n      );\n      this.layersButton.classList.toggle(\"toggled\", view === SidebarView.LAYERS);\n      // ... and for all views.\n      this.thumbnailView.classList.toggle(\"hidden\", view !== SidebarView.THUMBS);\n      this.outlineView.classList.toggle(\"hidden\", view !== SidebarView.OUTLINE);\n      this.attachmentsView.classList.toggle(\n        \"hidden\",\n        view !== SidebarView.ATTACHMENTS\n      );\n      this.layersView.classList.toggle(\"hidden\", view !== SidebarView.LAYERS);\n\n      // Finally, update view-specific CSS classes.\n      this._outlineOptionsContainer.classList.toggle(\n        \"hidden\",\n        view !== SidebarView.OUTLINE\n      );\n\n      if (forceOpen && !this.isOpen) {\n        this.open();\n        return true; // Opening will trigger rendering and dispatch the event.\n      }\n      if (shouldForceRendering) {\n        this._updateThumbnailViewer();\n        this._forceRendering();\n      }\n      if (isViewChanged) {\n        this._dispatchEvent();\n      }\n      return isViewChanged;\n    }\n\n    open() {\n      if (this.isOpen) {\n        return;\n      }\n      this.isOpen = true;\n      this.toggleButton.classList.add(\"toggled\");\n\n      this.outerContainer.classList.add(\"sidebarMoving\", \"sidebarOpen\");\n\n      if (this.active === SidebarView.THUMBS) {\n        this._updateThumbnailViewer();\n      }\n      this._forceRendering();\n      this._dispatchEvent();\n\n      this._hideUINotification();\n    }\n\n    close() {\n      if (!this.isOpen) {\n        return;\n      }\n      this.isOpen = false;\n      this.toggleButton.classList.remove(\"toggled\");\n\n      this.outerContainer.classList.add(\"sidebarMoving\");\n      this.outerContainer.classList.remove(\"sidebarOpen\");\n\n      this._forceRendering();\n      this._dispatchEvent();\n    }\n\n    toggle() {\n      if (this.isOpen) {\n        this.close();\n      } else {\n        this.open();\n      }\n    }\n\n    /**\n     * @private\n     */\n    _dispatchEvent() {\n      this.eventBus.dispatch(\"sidebarviewchanged\", {\n        source: this,\n        view: this.visibleView,\n      });\n    }\n\n    /**\n     * @private\n     */\n    _forceRendering() {\n      if (this.onToggled) {\n        this.onToggled();\n      } else {\n        // Fallback\n        this.pdfViewer.forceRendering();\n        this.pdfThumbnailViewer.forceRendering();\n      }\n    }\n\n    /**\n     * @private\n     */\n    _updateThumbnailViewer() {\n      const { pdfViewer, pdfThumbnailViewer } = this;\n\n      // Use the rendered pages to set the corresponding thumbnail images.\n      const pagesCount = pdfViewer.pagesCount;\n      for (let pageIndex = 0; pageIndex < pagesCount; pageIndex++) {\n        const pageView = pdfViewer.getPageView(pageIndex);\n        if (pageView && pageView.renderingState === RenderingStates.FINISHED) {\n          const thumbnailView = pdfThumbnailViewer.getThumbnail(pageIndex);\n          thumbnailView.setImage(pageView);\n        }\n      }\n      pdfThumbnailViewer.scrollThumbnailIntoView(pdfViewer.currentPageNumber);\n    }\n\n    /**\n     * @private\n     */\n    _showUINotification() {\n      this.l10n\n        .get(\n          \"toggle_sidebar_notification2.title\",\n          null,\n          \"Toggle Sidebar (document contains outline/attachments/layers)\"\n        )\n        .then(msg => {\n          this.toggleButton.title = msg;\n        });\n\n      if (!this.isOpen) {\n        // Only show the notification on the `toggleButton` if the sidebar is\n        // currently closed, to avoid unnecessarily bothering the user.\n        this.toggleButton.classList.add(UI_NOTIFICATION_CLASS);\n      }\n    }\n\n    /**\n     * @private\n     */\n    _hideUINotification(reset = false) {\n      if (this.isOpen || reset) {\n        // Only hide the notification on the `toggleButton` if the sidebar is\n        // currently open, or when the current PDF document is being closed.\n        this.toggleButton.classList.remove(UI_NOTIFICATION_CLASS);\n      }\n\n      if (reset) {\n        this.l10n\n          .get(\"toggle_sidebar.title\", null, \"Toggle Sidebar\")\n          .then(msg => {\n            this.toggleButton.title = msg;\n          });\n      }\n    }\n\n    /**\n     * @private\n     */\n    _addEventListeners() {\n      this.viewerContainer.addEventListener(\"transitionend\", evt => {\n        if (evt.target === this.viewerContainer) {\n          this.outerContainer.classList.remove(\"sidebarMoving\");\n        }\n      });\n\n      this.toggleButton.addEventListener(\"click\", () => {\n        this.toggle();\n      });\n\n      // Buttons for switching views.\n      this.thumbnailButton.addEventListener(\"click\", () => {\n        this.switchView(SidebarView.THUMBS);\n      });\n\n      this.outlineButton.addEventListener(\"click\", () => {\n        this.switchView(SidebarView.OUTLINE);\n      });\n      this.outlineButton.addEventListener(\"dblclick\", () => {\n        this.eventBus.dispatch(\"toggleoutlinetree\", { source: this });\n      });\n\n      this.attachmentsButton.addEventListener(\"click\", () => {\n        this.switchView(SidebarView.ATTACHMENTS);\n      });\n\n      this.layersButton.addEventListener(\"click\", () => {\n        this.switchView(SidebarView.LAYERS);\n      });\n      this.layersButton.addEventListener(\"dblclick\", () => {\n        this.eventBus.dispatch(\"resetlayers\", { source: this });\n      });\n\n      // Buttons for view-specific options.\n      this._currentOutlineItemButton.addEventListener(\"click\", () => {\n        this.eventBus.dispatch(\"currentoutlineitem\", { source: this });\n      });\n\n      // Disable/enable views.\n      const onTreeLoaded = (count, button, view) => {\n        button.disabled = !count;\n\n        if (count) {\n          this._showUINotification();\n        } else if (this.active === view) {\n          // If the `view` was opened by the user during document load,\n          // switch away from it if it turns out to be empty.\n          this.switchView(SidebarView.THUMBS);\n        }\n      };\n\n      this.eventBus._on(\"outlineloaded\", evt => {\n        onTreeLoaded(evt.outlineCount, this.outlineButton, SidebarView.OUTLINE);\n\n        if (evt.enableCurrentOutlineItemButton) {\n          this.pdfViewer.pagesPromise.then(() => {\n            this._currentOutlineItemButton.disabled = !this.isInitialViewSet;\n          });\n        }\n      });\n\n      this.eventBus._on(\"attachmentsloaded\", evt => {\n        onTreeLoaded(\n          evt.attachmentsCount,\n          this.attachmentsButton,\n          SidebarView.ATTACHMENTS\n        );\n      });\n\n      this.eventBus._on(\"layersloaded\", evt => {\n        onTreeLoaded(evt.layersCount, this.layersButton, SidebarView.LAYERS);\n      });\n\n      // Update the thumbnailViewer, if visible, when exiting presentation mode.\n      this.eventBus._on(\"presentationmodechanged\", evt => {\n        if (\n          evt.state === PresentationModeState.NORMAL &&\n          this.isThumbnailViewVisible\n        ) {\n          this._updateThumbnailViewer();\n        }\n      });\n    }\n  }\n\n  return { PDFSidebar };\n});\ndefine('skylark-pdfjs-viewer/pdf_sidebar_resizer',[\n  \"./ui_utils\",\n],function(ui_utils){\n  /* Copyright 2017 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { NullL10n } = ui_utils;\n\n  const SIDEBAR_WIDTH_VAR = \"--sidebar-width\";\n  const SIDEBAR_MIN_WIDTH = 200; // pixels\n  const SIDEBAR_RESIZING_CLASS = \"sidebarResizing\";\n\n  /**\n   * @typedef {Object} PDFSidebarResizerOptions\n   * @property {HTMLDivElement} outerContainer - The outer container\n   *   (encasing both the viewer and sidebar elements).\n   * @property {HTMLDivElement} resizer - The DOM element that can be dragged in\n   *   order to adjust the width of the sidebar.\n   */\n\n  class PDFSidebarResizer {\n    /**\n     * @param {PDFSidebarResizerOptions} options\n     * @param {EventBus} eventBus - The application event bus.\n     * @param {IL10n} l10n - Localization service.\n     */\n    constructor(options, eventBus, l10n = NullL10n) {\n      this.isRTL = false;\n      this.sidebarOpen = false;\n      this.doc = document.documentElement;\n      this._width = null;\n      this._outerContainerWidth = null;\n      this._boundEvents = Object.create(null);\n\n      this.outerContainer = options.outerContainer;\n      this.resizer = options.resizer;\n      this.eventBus = eventBus;\n\n      l10n.getDirection().then(dir => {\n        this.isRTL = dir === \"rtl\";\n      });\n      this._addEventListeners();\n    }\n\n    /**\n     * @type {number}\n     */\n    get outerContainerWidth() {\n      if (!this._outerContainerWidth) {\n        this._outerContainerWidth = this.outerContainer.clientWidth;\n      }\n      return this._outerContainerWidth;\n    }\n\n    /**\n     * @private\n     * returns {boolean} Indicating if the sidebar width was updated.\n     */\n    _updateWidth(width = 0) {\n      // Prevent the sidebar from becoming too narrow, or from occupying more\n      // than half of the available viewer width.\n      const maxWidth = Math.floor(this.outerContainerWidth / 2);\n      if (width > maxWidth) {\n        width = maxWidth;\n      }\n      if (width < SIDEBAR_MIN_WIDTH) {\n        width = SIDEBAR_MIN_WIDTH;\n      }\n      // Only update the UI when the sidebar width did in fact change.\n      if (width === this._width) {\n        return false;\n      }\n      this._width = width;\n      this.doc.style.setProperty(SIDEBAR_WIDTH_VAR, `${width}px`);\n      return true;\n    }\n\n    /**\n     * @private\n     */\n    _mouseMove(evt) {\n      let width = evt.clientX;\n      // For sidebar resizing to work correctly in RTL mode, invert the width.\n      if (this.isRTL) {\n        width = this.outerContainerWidth - width;\n      }\n      this._updateWidth(width);\n    }\n\n    /**\n     * @private\n     */\n    _mouseUp(evt) {\n      // Re-enable the `transition-duration` rules when sidebar resizing ends...\n      this.outerContainer.classList.remove(SIDEBAR_RESIZING_CLASS);\n      // ... and ensure that rendering will always be triggered.\n      this.eventBus.dispatch(\"resize\", { source: this });\n\n      const _boundEvents = this._boundEvents;\n      window.removeEventListener(\"mousemove\", _boundEvents.mouseMove);\n      window.removeEventListener(\"mouseup\", _boundEvents.mouseUp);\n    }\n\n    /**\n     * @private\n     */\n    _addEventListeners() {\n      const _boundEvents = this._boundEvents;\n      _boundEvents.mouseMove = this._mouseMove.bind(this);\n      _boundEvents.mouseUp = this._mouseUp.bind(this);\n\n      this.resizer.addEventListener(\"mousedown\", evt => {\n        if (evt.button !== 0) {\n          return;\n        }\n        // Disable the `transition-duration` rules when sidebar resizing begins,\n        // in order to improve responsiveness and to avoid visual glitches.\n        this.outerContainer.classList.add(SIDEBAR_RESIZING_CLASS);\n\n        window.addEventListener(\"mousemove\", _boundEvents.mouseMove);\n        window.addEventListener(\"mouseup\", _boundEvents.mouseUp);\n      });\n\n      this.eventBus._on(\"sidebarviewchanged\", evt => {\n        this.sidebarOpen = !!(evt && evt.view);\n      });\n\n      this.eventBus._on(\"resize\", evt => {\n        // When the *entire* viewer is resized, such that it becomes narrower,\n        // ensure that the sidebar doesn't end up being too wide.\n        if (!evt || evt.source !== window) {\n          return;\n        }\n        // Always reset the cached width when the viewer is resized.\n        this._outerContainerWidth = null;\n\n        if (!this._width) {\n          // The sidebar hasn't been resized, hence no need to adjust its width.\n          return;\n        }\n        // NOTE: If the sidebar is closed, we don't need to worry about\n        //       visual glitches nor ensure that rendering is triggered.\n        if (!this.sidebarOpen) {\n          this._updateWidth(this._width);\n          return;\n        }\n        this.outerContainer.classList.add(SIDEBAR_RESIZING_CLASS);\n        const updated = this._updateWidth(this._width);\n\n        Promise.resolve().then(() => {\n          this.outerContainer.classList.remove(SIDEBAR_RESIZING_CLASS);\n          // Trigger rendering if the sidebar width changed, to avoid\n          // depending on the order in which 'resize' events are handled.\n          if (updated) {\n            this.eventBus.dispatch(\"resize\", { source: this });\n          }\n        });\n      });\n    }\n  }\n\n  return { PDFSidebarResizer };\n});\ndefine('skylark-pdfjs-viewer/pdf_thumbnail_view',[\n  \"skylark-pdfjs-display\",\n  \"./pdfjs_dev\",\n  \"./ui_utils\",\n  \"./pdf_rendering_queue\"\n],function(\n  pdfjsLib,\n  PDFJSDev,\n  ui_utils,\n  pdf_rendering_queue\n){\n  /* Copyright 2012 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { getOutputScale, NullL10n } = ui_utils;\n  const { RenderingCancelledException } = pdfjsLib;\n  const { RenderingStates } = pdf_rendering_queue;\n\n  const MAX_NUM_SCALING_STEPS = 3;\n  const THUMBNAIL_CANVAS_BORDER_WIDTH = 1; // px\n  const THUMBNAIL_WIDTH = 98; // px\n\n  /**\n   * @typedef {Object} PDFThumbnailViewOptions\n   * @property {HTMLDivElement} container - The viewer element.\n   * @property {number} id - The thumbnail's unique ID (normally its number).\n   * @property {PageViewport} defaultViewport - The page viewport.\n   * @property {Promise<OptionalContentConfig>} [optionalContentConfigPromise] -\n   *   A promise that is resolved with an {@link OptionalContentConfig} instance.\n   *   The default value is `null`.\n   * @property {IPDFLinkService} linkService - The navigation/linking service.\n   * @property {PDFRenderingQueue} renderingQueue - The rendering queue object.\n   * @property {function} checkSetImageDisabled\n   * @property {boolean} [disableCanvasToImageConversion] - Don't convert the\n   *   canvas thumbnails to images. This prevents `toDataURL` calls, but\n   *   increases the overall memory usage. The default value is `false`.\n   * @property {IL10n} l10n - Localization service.\n   */\n\n  const TempImageFactory = (function TempImageFactoryClosure() {\n    let tempCanvasCache = null;\n\n    return {\n      getCanvas(width, height) {\n        let tempCanvas = tempCanvasCache;\n        if (!tempCanvas) {\n          tempCanvas = document.createElement(\"canvas\");\n          tempCanvasCache = tempCanvas;\n        }\n        tempCanvas.width = width;\n        tempCanvas.height = height;\n\n        // Since this is a temporary canvas, we need to fill it with a white\n        // background ourselves. `_getPageDrawContext` uses CSS rules for this.\n        if (\n          typeof PDFJSDev === \"undefined\" ||\n          PDFJSDev.test(\"MOZCENTRAL || GENERIC\")\n        ) {\n          tempCanvas.mozOpaque = true;\n        }\n\n        const ctx = tempCanvas.getContext(\"2d\", { alpha: false });\n        ctx.save();\n        ctx.fillStyle = \"rgb(255, 255, 255)\";\n        ctx.fillRect(0, 0, width, height);\n        ctx.restore();\n        return tempCanvas;\n      },\n\n      destroyCanvas() {\n        const tempCanvas = tempCanvasCache;\n        if (tempCanvas) {\n          // Zeroing the width and height causes Firefox to release graphics\n          // resources immediately, which can greatly reduce memory consumption.\n          tempCanvas.width = 0;\n          tempCanvas.height = 0;\n        }\n        tempCanvasCache = null;\n      },\n    };\n  })();\n\n  /**\n   * @implements {IRenderableView}\n   */\n  class PDFThumbnailView {\n    /**\n     * @param {PDFThumbnailViewOptions} options\n     */\n    constructor({\n      container,\n      id,\n      defaultViewport,\n      optionalContentConfigPromise,\n      linkService,\n      renderingQueue,\n      checkSetImageDisabled,\n      disableCanvasToImageConversion = false,\n      l10n = NullL10n,\n    }) {\n      this.id = id;\n      this.renderingId = \"thumbnail\" + id;\n      this.pageLabel = null;\n\n      this.pdfPage = null;\n      this.rotation = 0;\n      this.viewport = defaultViewport;\n      this.pdfPageRotate = defaultViewport.rotation;\n      this._optionalContentConfigPromise = optionalContentConfigPromise || null;\n\n      this.linkService = linkService;\n      this.renderingQueue = renderingQueue;\n\n      this.renderTask = null;\n      this.renderingState = RenderingStates.INITIAL;\n      this.resume = null;\n      this._checkSetImageDisabled =\n        checkSetImageDisabled ||\n        function () {\n          return false;\n        };\n      this.disableCanvasToImageConversion = disableCanvasToImageConversion;\n\n      this.pageWidth = this.viewport.width;\n      this.pageHeight = this.viewport.height;\n      this.pageRatio = this.pageWidth / this.pageHeight;\n\n      this.canvasWidth = THUMBNAIL_WIDTH;\n      this.canvasHeight = (this.canvasWidth / this.pageRatio) | 0;\n      this.scale = this.canvasWidth / this.pageWidth;\n\n      this.l10n = l10n;\n\n      const anchor = document.createElement(\"a\");\n      anchor.href = linkService.getAnchorUrl(\"#page=\" + id);\n      this._thumbPageTitle.then(msg => {\n        anchor.title = msg;\n      });\n      anchor.onclick = function () {\n        linkService.goToPage(id);\n        return false;\n      };\n      this.anchor = anchor;\n\n      const div = document.createElement(\"div\");\n      div.className = \"thumbnail\";\n      div.setAttribute(\"data-page-number\", this.id);\n      this.div = div;\n\n      const ring = document.createElement(\"div\");\n      ring.className = \"thumbnailSelectionRing\";\n      const borderAdjustment = 2 * THUMBNAIL_CANVAS_BORDER_WIDTH;\n      ring.style.width = this.canvasWidth + borderAdjustment + \"px\";\n      ring.style.height = this.canvasHeight + borderAdjustment + \"px\";\n      this.ring = ring;\n\n      div.appendChild(ring);\n      anchor.appendChild(div);\n      container.appendChild(anchor);\n    }\n\n    setPdfPage(pdfPage) {\n      this.pdfPage = pdfPage;\n      this.pdfPageRotate = pdfPage.rotate;\n      const totalRotation = (this.rotation + this.pdfPageRotate) % 360;\n      this.viewport = pdfPage.getViewport({ scale: 1, rotation: totalRotation });\n      this.reset();\n    }\n\n    reset() {\n      this.cancelRendering();\n      this.renderingState = RenderingStates.INITIAL;\n\n      this.pageWidth = this.viewport.width;\n      this.pageHeight = this.viewport.height;\n      this.pageRatio = this.pageWidth / this.pageHeight;\n\n      this.canvasHeight = (this.canvasWidth / this.pageRatio) | 0;\n      this.scale = this.canvasWidth / this.pageWidth;\n\n      this.div.removeAttribute(\"data-loaded\");\n      const ring = this.ring;\n      const childNodes = ring.childNodes;\n      for (let i = childNodes.length - 1; i >= 0; i--) {\n        ring.removeChild(childNodes[i]);\n      }\n      const borderAdjustment = 2 * THUMBNAIL_CANVAS_BORDER_WIDTH;\n      ring.style.width = this.canvasWidth + borderAdjustment + \"px\";\n      ring.style.height = this.canvasHeight + borderAdjustment + \"px\";\n\n      if (this.canvas) {\n        // Zeroing the width and height causes Firefox to release graphics\n        // resources immediately, which can greatly reduce memory consumption.\n        this.canvas.width = 0;\n        this.canvas.height = 0;\n        delete this.canvas;\n      }\n      if (this.image) {\n        this.image.removeAttribute(\"src\");\n        delete this.image;\n      }\n    }\n\n    update(rotation) {\n      if (typeof rotation !== \"undefined\") {\n        this.rotation = rotation;\n      }\n      const totalRotation = (this.rotation + this.pdfPageRotate) % 360;\n      this.viewport = this.viewport.clone({\n        scale: 1,\n        rotation: totalRotation,\n      });\n      this.reset();\n    }\n\n    /**\n     * PLEASE NOTE: Most likely you want to use the `this.reset()` method,\n     *              rather than calling this one directly.\n     */\n    cancelRendering() {\n      if (this.renderTask) {\n        this.renderTask.cancel();\n        this.renderTask = null;\n      }\n      this.resume = null;\n    }\n\n    /**\n     * @private\n     */\n    _getPageDrawContext() {\n      const canvas = document.createElement(\"canvas\");\n      // Keep the no-thumbnail outline visible, i.e. `data-loaded === false`,\n      // until rendering/image conversion is complete, to avoid display issues.\n      this.canvas = canvas;\n\n      if (\n        typeof PDFJSDev === \"undefined\" ||\n        PDFJSDev.test(\"MOZCENTRAL || GENERIC\")\n      ) {\n        canvas.mozOpaque = true;\n      }\n      const ctx = canvas.getContext(\"2d\", { alpha: false });\n      const outputScale = getOutputScale(ctx);\n\n      canvas.width = (this.canvasWidth * outputScale.sx) | 0;\n      canvas.height = (this.canvasHeight * outputScale.sy) | 0;\n      canvas.style.width = this.canvasWidth + \"px\";\n      canvas.style.height = this.canvasHeight + \"px\";\n\n      const transform = outputScale.scaled\n        ? [outputScale.sx, 0, 0, outputScale.sy, 0, 0]\n        : null;\n\n      return [ctx, transform];\n    }\n\n    /**\n     * @private\n     */\n    _convertCanvasToImage() {\n      if (!this.canvas) {\n        return;\n      }\n      if (this.renderingState !== RenderingStates.FINISHED) {\n        return;\n      }\n      const className = \"thumbnailImage\";\n\n      if (this.disableCanvasToImageConversion) {\n        this.canvas.className = className;\n        this._thumbPageCanvas.then(msg => {\n          this.canvas.setAttribute(\"aria-label\", msg);\n        });\n\n        this.div.setAttribute(\"data-loaded\", true);\n        this.ring.appendChild(this.canvas);\n        return;\n      }\n      const image = document.createElement(\"img\");\n      image.className = className;\n      this._thumbPageCanvas.then(msg => {\n        image.setAttribute(\"aria-label\", msg);\n      });\n\n      image.style.width = this.canvasWidth + \"px\";\n      image.style.height = this.canvasHeight + \"px\";\n\n      image.src = this.canvas.toDataURL();\n      this.image = image;\n\n      this.div.setAttribute(\"data-loaded\", true);\n      this.ring.appendChild(image);\n\n      // Zeroing the width and height causes Firefox to release graphics\n      // resources immediately, which can greatly reduce memory consumption.\n      this.canvas.width = 0;\n      this.canvas.height = 0;\n      delete this.canvas;\n    }\n\n    draw() {\n      if (this.renderingState !== RenderingStates.INITIAL) {\n        console.error(\"Must be in new state before drawing\");\n        return Promise.resolve(undefined);\n      }\n      const { pdfPage } = this;\n\n      if (!pdfPage) {\n        this.renderingState = RenderingStates.FINISHED;\n        return Promise.reject(new Error(\"pdfPage is not loaded\"));\n      }\n\n      this.renderingState = RenderingStates.RUNNING;\n\n      const finishRenderTask = async (error = null) => {\n        // The renderTask may have been replaced by a new one, so only remove\n        // the reference to the renderTask if it matches the one that is\n        // triggering this callback.\n        if (renderTask === this.renderTask) {\n          this.renderTask = null;\n        }\n\n        if (error instanceof RenderingCancelledException) {\n          return;\n        }\n\n        this.renderingState = RenderingStates.FINISHED;\n        this._convertCanvasToImage();\n\n        if (error) {\n          throw error;\n        }\n      };\n\n      const [ctx, transform] = this._getPageDrawContext();\n      const drawViewport = this.viewport.clone({ scale: this.scale });\n      const renderContinueCallback = cont => {\n        if (!this.renderingQueue.isHighestPriority(this)) {\n          this.renderingState = RenderingStates.PAUSED;\n          this.resume = () => {\n            this.renderingState = RenderingStates.RUNNING;\n            cont();\n          };\n          return;\n        }\n        cont();\n      };\n\n      const renderContext = {\n        canvasContext: ctx,\n        transform,\n        viewport: drawViewport,\n        optionalContentConfigPromise: this._optionalContentConfigPromise,\n      };\n      const renderTask = (this.renderTask = pdfPage.render(renderContext));\n      renderTask.onContinue = renderContinueCallback;\n\n      const resultPromise = renderTask.promise.then(\n        function () {\n          finishRenderTask(null);\n        },\n        function (error) {\n          finishRenderTask(error);\n        }\n      );\n      // Only trigger cleanup, once rendering has finished, when the current\n      // pageView is *not* cached on the `BaseViewer`-instance.\n      resultPromise.finally(() => {\n        const pageCached = this.linkService.isPageCached(this.id);\n        if (pageCached) {\n          return;\n        }\n        ///this.pdfPage?.cleanup(); lwf\n        this.pdfPage && this.pdfPage.cleanup();\n      });\n\n      return resultPromise;\n    }\n\n    setImage(pageView) {\n      if (this._checkSetImageDisabled()) {\n        return;\n      }\n      if (this.renderingState !== RenderingStates.INITIAL) {\n        return;\n      }\n      const img = pageView.canvas;\n      if (!img) {\n        return;\n      }\n      if (!this.pdfPage) {\n        this.setPdfPage(pageView.pdfPage);\n      }\n\n      this.renderingState = RenderingStates.FINISHED;\n\n      const [ctx] = this._getPageDrawContext();\n      const canvas = ctx.canvas;\n      if (img.width <= 2 * canvas.width) {\n        ctx.drawImage(\n          img,\n          0,\n          0,\n          img.width,\n          img.height,\n          0,\n          0,\n          canvas.width,\n          canvas.height\n        );\n        this._convertCanvasToImage();\n        return;\n      }\n\n      // drawImage does an awful job of rescaling the image, doing it gradually.\n      let reducedWidth = canvas.width << MAX_NUM_SCALING_STEPS;\n      let reducedHeight = canvas.height << MAX_NUM_SCALING_STEPS;\n      const reducedImage = TempImageFactory.getCanvas(\n        reducedWidth,\n        reducedHeight\n      );\n      const reducedImageCtx = reducedImage.getContext(\"2d\");\n\n      while (reducedWidth > img.width || reducedHeight > img.height) {\n        reducedWidth >>= 1;\n        reducedHeight >>= 1;\n      }\n      reducedImageCtx.drawImage(\n        img,\n        0,\n        0,\n        img.width,\n        img.height,\n        0,\n        0,\n        reducedWidth,\n        reducedHeight\n      );\n      while (reducedWidth > 2 * canvas.width) {\n        reducedImageCtx.drawImage(\n          reducedImage,\n          0,\n          0,\n          reducedWidth,\n          reducedHeight,\n          0,\n          0,\n          reducedWidth >> 1,\n          reducedHeight >> 1\n        );\n        reducedWidth >>= 1;\n        reducedHeight >>= 1;\n      }\n      ctx.drawImage(\n        reducedImage,\n        0,\n        0,\n        reducedWidth,\n        reducedHeight,\n        0,\n        0,\n        canvas.width,\n        canvas.height\n      );\n      this._convertCanvasToImage();\n    }\n\n    get _thumbPageTitle() {\n      return this.l10n.get(\n        \"thumb_page_title\",\n        ///{ page: this.pageLabel ?? this.id }, // lwf\n        { page: this.pageLabel && this.id },\n        \"Page {{page}}\"\n      );\n    }\n\n    get _thumbPageCanvas() {\n      return this.l10n.get(\n        \"thumb_page_canvas\",\n        ///{ page: this.pageLabel ?? this.id }, // lwf\n        { page: this.pageLabel && this.id },\n        \"Thumbnail of Page {{page}}\"\n      );\n    }\n\n    /**\n     * @param {string|null} label\n     */\n    setPageLabel(label) {\n      this.pageLabel = typeof label === \"string\" ? label : null;\n\n      this._thumbPageTitle.then(msg => {\n        this.anchor.title = msg;\n      });\n\n      if (this.renderingState !== RenderingStates.FINISHED) {\n        return;\n      }\n\n      this._thumbPageCanvas.then(msg => {\n        if (this.image) {\n          this.image.setAttribute(\"aria-label\", msg);\n        } else if (this.disableCanvasToImageConversion && this.canvas) {\n          this.canvas.setAttribute(\"aria-label\", msg);\n        }\n      });\n    }\n  }\n\n  return { PDFThumbnailView, TempImageFactory };\n});\ndefine('skylark-pdfjs-viewer/pdf_thumbnail_viewer',[\n  \"./ui_utils\",\n  \"./pdf_thumbnail_view\",\n  \"./pdf_rendering_queue\"\n],function(ui_utils,pdf_thumbnail_view,pdf_rendering_queue){\n  /* Copyright 2012 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const {\n    getVisibleElements,\n    isValidRotation,\n    NullL10n,\n    scrollIntoView,\n    watchScroll,\n  } = ui_utils;\n  const { PDFThumbnailView, TempImageFactory } = pdf_thumbnail_view;\n  const { RenderingStates } = pdf_rendering_queue;\n\n  const THUMBNAIL_SCROLL_MARGIN = -19;\n  const THUMBNAIL_SELECTED_CLASS = \"selected\";\n\n  /**\n   * @typedef {Object} PDFThumbnailViewerOptions\n   * @property {HTMLDivElement} container - The container for the thumbnail\n   *   elements.\n   * @property {EventBus} eventBus - The application event bus.\n   * @property {IPDFLinkService} linkService - The navigation/linking service.\n   * @property {PDFRenderingQueue} renderingQueue - The rendering queue object.\n   * @property {IL10n} l10n - Localization service.\n   */\n\n  /**\n   * Viewer control to display thumbnails for pages in a PDF document.\n   *\n   * @implements {IRenderableView}\n   */\n  class PDFThumbnailViewer {\n    /**\n     * @param {PDFThumbnailViewerOptions} options\n     */\n    constructor({\n      container,\n      eventBus,\n      linkService,\n      renderingQueue,\n      l10n = NullL10n,\n    }) {\n      this.container = container;\n      this.linkService = linkService;\n      this.renderingQueue = renderingQueue;\n      this.l10n = l10n;\n\n      this.scroll = watchScroll(this.container, this._scrollUpdated.bind(this));\n      this._resetView();\n\n      eventBus._on(\"optionalcontentconfigchanged\", () => {\n        // Ensure that the thumbnails always render with the *default* optional\n        // content configuration.\n        this._setImageDisabled = true;\n      });\n    }\n\n    /**\n     * @private\n     */\n    _scrollUpdated() {\n      this.renderingQueue.renderHighestPriority();\n    }\n\n    getThumbnail(index) {\n      return this._thumbnails[index];\n    }\n\n    /**\n     * @private\n     */\n    _getVisibleThumbs() {\n      return getVisibleElements({\n        scrollEl: this.container,\n        views: this._thumbnails,\n      });\n    }\n\n    scrollThumbnailIntoView(pageNumber) {\n      if (!this.pdfDocument) {\n        return;\n      }\n      const thumbnailView = this._thumbnails[pageNumber - 1];\n\n      if (!thumbnailView) {\n        console.error('scrollThumbnailIntoView: Invalid \"pageNumber\" parameter.');\n        return;\n      }\n\n      if (pageNumber !== this._currentPageNumber) {\n        const prevThumbnailView = this._thumbnails[this._currentPageNumber - 1];\n        // Remove the highlight from the previous thumbnail...\n        prevThumbnailView.div.classList.remove(THUMBNAIL_SELECTED_CLASS);\n        // ... and add the highlight to the new thumbnail.\n        thumbnailView.div.classList.add(THUMBNAIL_SELECTED_CLASS);\n      }\n      const visibleThumbs = this._getVisibleThumbs();\n      const numVisibleThumbs = visibleThumbs.views.length;\n\n      // If the thumbnail isn't currently visible, scroll it into view.\n      if (numVisibleThumbs > 0) {\n        const first = visibleThumbs.first.id;\n        // Account for only one thumbnail being visible.\n        const last = numVisibleThumbs > 1 ? visibleThumbs.last.id : first;\n\n        let shouldScroll = false;\n        if (pageNumber <= first || pageNumber >= last) {\n          shouldScroll = true;\n        } else {\n          visibleThumbs.views.some(function (view) {\n            if (view.id !== pageNumber) {\n              return false;\n            }\n            shouldScroll = view.percent < 100;\n            return true;\n          });\n        }\n        if (shouldScroll) {\n          scrollIntoView(thumbnailView.div, { top: THUMBNAIL_SCROLL_MARGIN });\n        }\n      }\n\n      this._currentPageNumber = pageNumber;\n    }\n\n    get pagesRotation() {\n      return this._pagesRotation;\n    }\n\n    set pagesRotation(rotation) {\n      if (!isValidRotation(rotation)) {\n        throw new Error(\"Invalid thumbnails rotation angle.\");\n      }\n      if (!this.pdfDocument) {\n        return;\n      }\n      if (this._pagesRotation === rotation) {\n        return; // The rotation didn't change.\n      }\n      this._pagesRotation = rotation;\n\n      for (let i = 0, ii = this._thumbnails.length; i < ii; i++) {\n        this._thumbnails[i].update(rotation);\n      }\n    }\n\n    cleanup() {\n      for (let i = 0, ii = this._thumbnails.length; i < ii; i++) {\n        if (\n          this._thumbnails[i] &&\n          this._thumbnails[i].renderingState !== RenderingStates.FINISHED\n        ) {\n          this._thumbnails[i].reset();\n        }\n      }\n      TempImageFactory.destroyCanvas();\n    }\n\n    /**\n     * @private\n     */\n    _resetView() {\n      this._thumbnails = [];\n      this._currentPageNumber = 1;\n      this._pageLabels = null;\n      this._pagesRotation = 0;\n      this._optionalContentConfigPromise = null;\n      this._pagesRequests = new WeakMap();\n      this._setImageDisabled = false;\n\n      // Remove the thumbnails from the DOM.\n      this.container.textContent = \"\";\n    }\n\n    setDocument(pdfDocument) {\n      if (this.pdfDocument) {\n        this._cancelRendering();\n        this._resetView();\n      }\n\n      this.pdfDocument = pdfDocument;\n      if (!pdfDocument) {\n        return;\n      }\n      const firstPagePromise = pdfDocument.getPage(1);\n      const optionalContentConfigPromise = pdfDocument.getOptionalContentConfig();\n\n      firstPagePromise\n        .then(firstPdfPage => {\n          this._optionalContentConfigPromise = optionalContentConfigPromise;\n\n          const pagesCount = pdfDocument.numPages;\n          const viewport = firstPdfPage.getViewport({ scale: 1 });\n          const checkSetImageDisabled = () => {\n            return this._setImageDisabled;\n          };\n\n          for (let pageNum = 1; pageNum <= pagesCount; ++pageNum) {\n            const thumbnail = new PDFThumbnailView({\n              container: this.container,\n              id: pageNum,\n              defaultViewport: viewport.clone(),\n              optionalContentConfigPromise,\n              linkService: this.linkService,\n              renderingQueue: this.renderingQueue,\n              checkSetImageDisabled,\n              disableCanvasToImageConversion: false,\n              l10n: this.l10n,\n            });\n            this._thumbnails.push(thumbnail);\n          }\n          // Set the first `pdfPage` immediately, since it's already loaded,\n          // rather than having to repeat the `PDFDocumentProxy.getPage` call in\n          // the `this._ensurePdfPageLoaded` method before rendering can start.\n          const firstThumbnailView = this._thumbnails[0];\n          if (firstThumbnailView) {\n            firstThumbnailView.setPdfPage(firstPdfPage);\n          }\n\n          // Ensure that the current thumbnail is always highlighted on load.\n          const thumbnailView = this._thumbnails[this._currentPageNumber - 1];\n          thumbnailView.div.classList.add(THUMBNAIL_SELECTED_CLASS);\n        })\n        .catch(reason => {\n          console.error(\"Unable to initialize thumbnail viewer\", reason);\n        });\n    }\n\n    /**\n     * @private\n     */\n    _cancelRendering() {\n      for (let i = 0, ii = this._thumbnails.length; i < ii; i++) {\n        if (this._thumbnails[i]) {\n          this._thumbnails[i].cancelRendering();\n        }\n      }\n    }\n\n    /**\n     * @param {Array|null} labels\n     */\n    setPageLabels(labels) {\n      if (!this.pdfDocument) {\n        return;\n      }\n      if (!labels) {\n        this._pageLabels = null;\n      } else if (\n        !(Array.isArray(labels) && this.pdfDocument.numPages === labels.length)\n      ) {\n        this._pageLabels = null;\n        console.error(\"PDFThumbnailViewer_setPageLabels: Invalid page labels.\");\n      } else {\n        this._pageLabels = labels;\n      }\n      // Update all the `PDFThumbnailView` instances.\n      for (let i = 0, ii = this._thumbnails.length; i < ii; i++) {\n        const label = this._pageLabels && this._pageLabels[i];\n        this._thumbnails[i].setPageLabel(label);\n      }\n    }\n\n    /**\n     * @param {PDFThumbnailView} thumbView\n     * @returns {PDFPage}\n     * @private\n     */\n    _ensurePdfPageLoaded(thumbView) {\n      if (thumbView.pdfPage) {\n        return Promise.resolve(thumbView.pdfPage);\n      }\n      if (this._pagesRequests.has(thumbView)) {\n        return this._pagesRequests.get(thumbView);\n      }\n      const promise = this.pdfDocument\n        .getPage(thumbView.id)\n        .then(pdfPage => {\n          if (!thumbView.pdfPage) {\n            thumbView.setPdfPage(pdfPage);\n          }\n          this._pagesRequests.delete(thumbView);\n          return pdfPage;\n        })\n        .catch(reason => {\n          console.error(\"Unable to get page for thumb view\", reason);\n          // Page error -- there is nothing that can be done.\n          this._pagesRequests.delete(thumbView);\n        });\n      this._pagesRequests.set(thumbView, promise);\n      return promise;\n    }\n\n    forceRendering() {\n      const visibleThumbs = this._getVisibleThumbs();\n      const thumbView = this.renderingQueue.getHighestPriority(\n        visibleThumbs,\n        this._thumbnails,\n        this.scroll.down\n      );\n      if (thumbView) {\n        this._ensurePdfPageLoaded(thumbView).then(() => {\n          this.renderingQueue.renderView(thumbView);\n        });\n        return true;\n      }\n      return false;\n    }\n  }\n\n  return { PDFThumbnailViewer };\n});\ndefine('skylark-pdfjs-viewer/annotation_layer_builder',[\n  \"skylark-pdfjs-display\",\n  \"./ui_utils\",\n  \"./pdf_link_service\"\n],function(pdfjsLib,ui_utils,pdf_link_service){\n  /* Copyright 2014 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { AnnotationLayer } = pdfjsLib;\n  const { NullL10n } =  ui_utils;\n  const { SimpleLinkService } = pdf_link_service;\n\n  /**\n   * @typedef {Object} AnnotationLayerBuilderOptions\n   * @property {HTMLDivElement} pageDiv\n   * @property {PDFPage} pdfPage\n   * @property {AnnotationStorage} [annotationStorage]\n   * @property {string} [imageResourcesPath] - Path for image resources, mainly\n   *   for annotation icons. Include trailing slash.\n   * @property {boolean} renderInteractiveForms\n   * @property {IPDFLinkService} linkService\n   * @property {DownloadManager} downloadManager\n   * @property {IL10n} l10n - Localization service.\n   * @property {boolean} [enableScripting]\n   * @property {Promise<boolean>} [hasJSActionsPromise]\n   * @property {Object} [mouseState]\n   */\n\n  class AnnotationLayerBuilder {\n    /**\n     * @param {AnnotationLayerBuilderOptions} options\n     */\n    constructor({\n      pageDiv,\n      pdfPage,\n      linkService,\n      downloadManager,\n      annotationStorage = null,\n      imageResourcesPath = \"\",\n      renderInteractiveForms = true,\n      l10n = NullL10n,\n      enableScripting = false,\n      hasJSActionsPromise = null,\n      mouseState = null,\n    }) {\n      this.pageDiv = pageDiv;\n      this.pdfPage = pdfPage;\n      this.linkService = linkService;\n      this.downloadManager = downloadManager;\n      this.imageResourcesPath = imageResourcesPath;\n      this.renderInteractiveForms = renderInteractiveForms;\n      this.l10n = l10n;\n      this.annotationStorage = annotationStorage;\n      this.enableScripting = enableScripting;\n      this._hasJSActionsPromise = hasJSActionsPromise;\n      this._mouseState = mouseState;\n\n      this.div = null;\n      this._cancelled = false;\n    }\n\n    /**\n     * @param {PageViewport} viewport\n     * @param {string} intent (default value is 'display')\n     * @returns {Promise<void>} A promise that is resolved when rendering of the\n     *   annotations is complete.\n     */\n    render(viewport, intent = \"display\") {\n      return Promise.all([\n        this.pdfPage.getAnnotations({ intent }),\n        this._hasJSActionsPromise,\n      ]).then(([annotations, hasJSActions = false]) => {\n        if (this._cancelled) {\n          return;\n        }\n        if (annotations.length === 0) {\n          return;\n        }\n\n        const parameters = {\n          viewport: viewport.clone({ dontFlip: true }),\n          div: this.div,\n          annotations,\n          page: this.pdfPage,\n          imageResourcesPath: this.imageResourcesPath,\n          renderInteractiveForms: this.renderInteractiveForms,\n          linkService: this.linkService,\n          downloadManager: this.downloadManager,\n          annotationStorage: this.annotationStorage,\n          enableScripting: this.enableScripting,\n          hasJSActions,\n          mouseState: this._mouseState,\n        };\n\n        if (this.div) {\n          // If an annotationLayer already exists, refresh its children's\n          // transformation matrices.\n          AnnotationLayer.update(parameters);\n        } else {\n          // Create an annotation layer div and render the annotations\n          // if there is at least one annotation.\n          this.div = document.createElement(\"div\");\n          this.div.className = \"annotationLayer\";\n          this.pageDiv.appendChild(this.div);\n          parameters.div = this.div;\n\n          AnnotationLayer.render(parameters);\n          this.l10n.translate(this.div);\n        }\n      });\n    }\n\n    cancel() {\n      this._cancelled = true;\n    }\n\n    hide() {\n      if (!this.div) {\n        return;\n      }\n      this.div.setAttribute(\"hidden\", \"true\");\n    }\n  }\n\n  /**\n   * @implements IPDFAnnotationLayerFactory\n   */\n  class DefaultAnnotationLayerFactory {\n    /**\n     * @param {HTMLDivElement} pageDiv\n     * @param {PDFPage} pdfPage\n     * @param {AnnotationStorage} [annotationStorage]\n     * @param {string} [imageResourcesPath] - Path for image resources, mainly\n     *   for annotation icons. Include trailing slash.\n     * @param {boolean} renderInteractiveForms\n     * @param {IL10n} l10n\n     * @param {boolean} [enableScripting]\n     * @param {Promise<boolean>} [hasJSActionsPromise]\n     * @param {Object} [mouseState]\n     * @returns {AnnotationLayerBuilder}\n     */\n    createAnnotationLayerBuilder(\n      pageDiv,\n      pdfPage,\n      annotationStorage = null,\n      imageResourcesPath = \"\",\n      renderInteractiveForms = true,\n      l10n = NullL10n,\n      enableScripting = false,\n      hasJSActionsPromise = null,\n      mouseState = null\n    ) {\n      return new AnnotationLayerBuilder({\n        pageDiv,\n        pdfPage,\n        imageResourcesPath,\n        renderInteractiveForms,\n        linkService: new SimpleLinkService(),\n        l10n,\n        annotationStorage,\n        enableScripting,\n        hasJSActionsPromise,\n        mouseState,\n      });\n    }\n  }\n\n  return { \n    AnnotationLayerBuilder, \n    DefaultAnnotationLayerFactory \n  };\n});\ndefine('skylark-pdfjs-viewer/pdf_page_view',[\n  \"skylark-pdfjs-display\",\n  \"./pdfjs_dev\",\n  \"./ui_utils\",\n  \"./pdf_rendering_queue\",\n  \"./viewer_compatibility\"\n],function(\n  pdfjsLib,\n  PDFJSDev,\n  ui_utils,\n  pdf_rendering_queue,\n  viewer_compatibility\n){\n  /* Copyright 2012 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const {\n    approximateFraction,\n    CSS_UNITS,\n    DEFAULT_SCALE,\n    getOutputScale,\n    NullL10n,\n    RendererType,\n    roundToDivide,\n    TextLayerMode,\n  } = ui_utils;\n  const {\n    createPromiseCapability,\n    RenderingCancelledException,\n    SVGGraphics,\n  } = pdfjsLib;\n  const { RenderingStates } = pdf_rendering_queue;\n  const { viewerCompatibilityParams } = viewer_compatibility;\n\n  /**\n   * @typedef {Object} PDFPageViewOptions\n   * @property {HTMLDivElement} container - The viewer element.\n   * @property {EventBus} eventBus - The application event bus.\n   * @property {number} id - The page unique ID (normally its number).\n   * @property {number} scale - The page scale display.\n   * @property {PageViewport} defaultViewport - The page viewport.\n   * @property {Promise<OptionalContentConfig>} [optionalContentConfigPromise] -\n   *   A promise that is resolved with an {@link OptionalContentConfig} instance.\n   *   The default value is `null`.\n   * @property {PDFRenderingQueue} renderingQueue - The rendering queue object.\n   * @property {IPDFTextLayerFactory} textLayerFactory\n   * @property {number} [textLayerMode] - Controls if the text layer used for\n   *   selection and searching is created, and if the improved text selection\n   *   behaviour is enabled. The constants from {TextLayerMode} should be used.\n   *   The default value is `TextLayerMode.ENABLE`.\n   * @property {IPDFAnnotationLayerFactory} annotationLayerFactory\n   * @property {string} [imageResourcesPath] - Path for image resources, mainly\n   *   for annotation icons. Include trailing slash.\n   * @property {boolean} renderInteractiveForms - Turns on rendering of\n   *   interactive form elements. The default value is `true`.\n   * @property {string} renderer - 'canvas' or 'svg'. The default is 'canvas'.\n   * @property {boolean} [enableWebGL] - Enables WebGL accelerated rendering for\n   *   some operations. The default value is `false`.\n   * @property {boolean} [useOnlyCssZoom] - Enables CSS only zooming. The default\n   *   value is `false`.\n   * @property {number} [maxCanvasPixels] - The maximum supported canvas size in\n   *   total pixels, i.e. width * height. Use -1 for no limit. The default value\n   *   is 4096 * 4096 (16 mega-pixels).\n   * @property {IL10n} l10n - Localization service.\n   * @property {boolean} [enableScripting] - Enable embedded script execution.\n   *   The default value is `false`.\n   */\n\n  const MAX_CANVAS_PIXELS = viewerCompatibilityParams.maxCanvasPixels || 16777216;\n\n  /**\n   * @implements {IRenderableView}\n   */\n  class PDFPageView {\n    /**\n     * @param {PDFPageViewOptions} options\n     */\n    constructor(options) {\n      const container = options.container;\n      const defaultViewport = options.defaultViewport;\n\n      this.id = options.id;\n      this.renderingId = \"page\" + this.id;\n\n      this.pdfPage = null;\n      this.pageLabel = null;\n      this.rotation = 0;\n      this.scale = options.scale || DEFAULT_SCALE;\n      this.viewport = defaultViewport;\n      this.pdfPageRotate = defaultViewport.rotation;\n      this._optionalContentConfigPromise =\n        options.optionalContentConfigPromise || null;\n      this.hasRestrictedScaling = false;\n      this.textLayerMode = Number.isInteger(options.textLayerMode)\n        ? options.textLayerMode\n        : TextLayerMode.ENABLE;\n      this.imageResourcesPath = options.imageResourcesPath || \"\";\n      this.renderInteractiveForms =\n        typeof options.renderInteractiveForms === \"boolean\"\n          ? options.renderInteractiveForms\n          : true;\n      this.useOnlyCssZoom = options.useOnlyCssZoom || false;\n      this.maxCanvasPixels = options.maxCanvasPixels || MAX_CANVAS_PIXELS;\n\n      this.eventBus = options.eventBus;\n      this.renderingQueue = options.renderingQueue;\n      this.textLayerFactory = options.textLayerFactory;\n      this.annotationLayerFactory = options.annotationLayerFactory;\n      this.renderer = options.renderer || RendererType.CANVAS;\n      this.enableWebGL = options.enableWebGL || false;\n      this.l10n = options.l10n || NullL10n;\n      this.enableScripting = options.enableScripting || false;\n\n      this.paintTask = null;\n      this.paintedViewportMap = new WeakMap();\n      this.renderingState = RenderingStates.INITIAL;\n      this.resume = null;\n      this._renderError = null;\n\n      this.annotationLayer = null;\n      this.textLayer = null;\n      this.zoomLayer = null;\n\n      const div = document.createElement(\"div\");\n      div.className = \"page\";\n      div.style.width = Math.floor(this.viewport.width) + \"px\";\n      div.style.height = Math.floor(this.viewport.height) + \"px\";\n      div.setAttribute(\"data-page-number\", this.id);\n      this.div = div;\n\n      container.appendChild(div);\n    }\n\n    setPdfPage(pdfPage) {\n      this.pdfPage = pdfPage;\n      this.pdfPageRotate = pdfPage.rotate;\n\n      const totalRotation = (this.rotation + this.pdfPageRotate) % 360;\n      this.viewport = pdfPage.getViewport({\n        scale: this.scale * CSS_UNITS,\n        rotation: totalRotation,\n      });\n      this.reset();\n    }\n\n    destroy() {\n      this.reset();\n      if (this.pdfPage) {\n        this.pdfPage.cleanup();\n      }\n    }\n\n    /**\n     * @private\n     */\n    async _renderAnnotationLayer() {\n      let error = null;\n      try {\n        await this.annotationLayer.render(this.viewport, \"display\");\n      } catch (ex) {\n        error = ex;\n      } finally {\n        this.eventBus.dispatch(\"annotationlayerrendered\", {\n          source: this,\n          pageNumber: this.id,\n          error,\n        });\n      }\n    }\n\n    /**\n     * @private\n     */\n    _resetZoomLayer(removeFromDOM = false) {\n      if (!this.zoomLayer) {\n        return;\n      }\n      const zoomLayerCanvas = this.zoomLayer.firstChild;\n      this.paintedViewportMap.delete(zoomLayerCanvas);\n      // Zeroing the width and height causes Firefox to release graphics\n      // resources immediately, which can greatly reduce memory consumption.\n      zoomLayerCanvas.width = 0;\n      zoomLayerCanvas.height = 0;\n\n      if (removeFromDOM) {\n        // Note: `ChildNode.remove` doesn't throw if the parent node is undefined.\n        this.zoomLayer.remove();\n      }\n      this.zoomLayer = null;\n    }\n\n    reset(keepZoomLayer = false, keepAnnotations = false) {\n      this.cancelRendering(keepAnnotations);\n      this.renderingState = RenderingStates.INITIAL;\n\n      const div = this.div;\n      div.style.width = Math.floor(this.viewport.width) + \"px\";\n      div.style.height = Math.floor(this.viewport.height) + \"px\";\n\n      const childNodes = div.childNodes;\n      const currentZoomLayerNode = (keepZoomLayer && this.zoomLayer) || null;\n      const currentAnnotationNode =\n        (keepAnnotations && this.annotationLayer && this.annotationLayer.div) ||\n        null;\n      for (let i = childNodes.length - 1; i >= 0; i--) {\n        const node = childNodes[i];\n        if (currentZoomLayerNode === node || currentAnnotationNode === node) {\n          continue;\n        }\n        div.removeChild(node);\n      }\n      div.removeAttribute(\"data-loaded\");\n\n      if (currentAnnotationNode) {\n        // Hide the annotation layer until all elements are resized\n        // so they are not displayed on the already resized page.\n        this.annotationLayer.hide();\n      } else if (this.annotationLayer) {\n        this.annotationLayer.cancel();\n        this.annotationLayer = null;\n      }\n\n      if (!currentZoomLayerNode) {\n        if (this.canvas) {\n          this.paintedViewportMap.delete(this.canvas);\n          // Zeroing the width and height causes Firefox to release graphics\n          // resources immediately, which can greatly reduce memory consumption.\n          this.canvas.width = 0;\n          this.canvas.height = 0;\n          delete this.canvas;\n        }\n        this._resetZoomLayer();\n      }\n      if (this.svg) {\n        this.paintedViewportMap.delete(this.svg);\n        delete this.svg;\n      }\n\n      this.loadingIconDiv = document.createElement(\"div\");\n      this.loadingIconDiv.className = \"loadingIcon\";\n      div.appendChild(this.loadingIconDiv);\n    }\n\n    update(scale, rotation, optionalContentConfigPromise = null) {\n      this.scale = scale || this.scale;\n      // The rotation may be zero.\n      if (typeof rotation !== \"undefined\") {\n        this.rotation = rotation;\n      }\n      if (optionalContentConfigPromise instanceof Promise) {\n        this._optionalContentConfigPromise = optionalContentConfigPromise;\n      }\n\n      const totalRotation = (this.rotation + this.pdfPageRotate) % 360;\n      this.viewport = this.viewport.clone({\n        scale: this.scale * CSS_UNITS,\n        rotation: totalRotation,\n      });\n\n      if (this.svg) {\n        this.cssTransform(this.svg, true);\n\n        this.eventBus.dispatch(\"pagerendered\", {\n          source: this,\n          pageNumber: this.id,\n          cssTransform: true,\n          timestamp: performance.now(),\n          error: this._renderError,\n        });\n        return;\n      }\n\n      let isScalingRestricted = false;\n      if (this.canvas && this.maxCanvasPixels > 0) {\n        const outputScale = this.outputScale;\n        if (\n          ((Math.floor(this.viewport.width) * outputScale.sx) | 0) *\n            ((Math.floor(this.viewport.height) * outputScale.sy) | 0) >\n          this.maxCanvasPixels\n        ) {\n          isScalingRestricted = true;\n        }\n      }\n\n      if (this.canvas) {\n        if (\n          this.useOnlyCssZoom ||\n          (this.hasRestrictedScaling && isScalingRestricted)\n        ) {\n          this.cssTransform(this.canvas, true);\n\n          this.eventBus.dispatch(\"pagerendered\", {\n            source: this,\n            pageNumber: this.id,\n            cssTransform: true,\n            timestamp: performance.now(),\n            error: this._renderError,\n          });\n          return;\n        }\n        if (!this.zoomLayer && !this.canvas.hasAttribute(\"hidden\")) {\n          this.zoomLayer = this.canvas.parentNode;\n          this.zoomLayer.style.position = \"absolute\";\n        }\n      }\n      if (this.zoomLayer) {\n        this.cssTransform(this.zoomLayer.firstChild);\n      }\n      this.reset(/* keepZoomLayer = */ true, /* keepAnnotations = */ true);\n    }\n\n    /**\n     * PLEASE NOTE: Most likely you want to use the `this.reset()` method,\n     *              rather than calling this one directly.\n     */\n    cancelRendering(keepAnnotations = false) {\n      if (this.paintTask) {\n        this.paintTask.cancel();\n        this.paintTask = null;\n      }\n      this.resume = null;\n\n      if (this.textLayer) {\n        this.textLayer.cancel();\n        this.textLayer = null;\n      }\n      if (!keepAnnotations && this.annotationLayer) {\n        this.annotationLayer.cancel();\n        this.annotationLayer = null;\n      }\n    }\n\n    cssTransform(target, redrawAnnotations = false) {\n      // Scale target (canvas or svg), its wrapper and page container.\n      const width = this.viewport.width;\n      const height = this.viewport.height;\n      const div = this.div;\n      target.style.width = target.parentNode.style.width = div.style.width =\n        Math.floor(width) + \"px\";\n      target.style.height = target.parentNode.style.height = div.style.height =\n        Math.floor(height) + \"px\";\n      // The canvas may have been originally rotated; rotate relative to that.\n      const relativeRotation =\n        this.viewport.rotation - this.paintedViewportMap.get(target).rotation;\n      const absRotation = Math.abs(relativeRotation);\n      let scaleX = 1,\n        scaleY = 1;\n      if (absRotation === 90 || absRotation === 270) {\n        // Scale x and y because of the rotation.\n        scaleX = height / width;\n        scaleY = width / height;\n      }\n      target.style.transform = `rotate(${relativeRotation}deg) scale(${scaleX}, ${scaleY})`;\n\n      if (this.textLayer) {\n        // Rotating the text layer is more complicated since the divs inside the\n        // the text layer are rotated.\n        // TODO: This could probably be simplified by drawing the text layer in\n        // one orientation and then rotating overall.\n        const textLayerViewport = this.textLayer.viewport;\n        const textRelativeRotation =\n          this.viewport.rotation - textLayerViewport.rotation;\n        const textAbsRotation = Math.abs(textRelativeRotation);\n        let scale = width / textLayerViewport.width;\n        if (textAbsRotation === 90 || textAbsRotation === 270) {\n          scale = width / textLayerViewport.height;\n        }\n        const textLayerDiv = this.textLayer.textLayerDiv;\n        let transX, transY;\n        switch (textAbsRotation) {\n          case 0:\n            transX = transY = 0;\n            break;\n          case 90:\n            transX = 0;\n            transY = \"-\" + textLayerDiv.style.height;\n            break;\n          case 180:\n            transX = \"-\" + textLayerDiv.style.width;\n            transY = \"-\" + textLayerDiv.style.height;\n            break;\n          case 270:\n            transX = \"-\" + textLayerDiv.style.width;\n            transY = 0;\n            break;\n          default:\n            console.error(\"Bad rotation value.\");\n            break;\n        }\n\n        textLayerDiv.style.transform =\n          `rotate(${textAbsRotation}deg) ` +\n          `scale(${scale}) ` +\n          `translate(${transX}, ${transY})`;\n        textLayerDiv.style.transformOrigin = \"0% 0%\";\n      }\n\n      if (redrawAnnotations && this.annotationLayer) {\n        this._renderAnnotationLayer();\n      }\n    }\n\n    get width() {\n      return this.viewport.width;\n    }\n\n    get height() {\n      return this.viewport.height;\n    }\n\n    getPagePoint(x, y) {\n      return this.viewport.convertToPdfPoint(x, y);\n    }\n\n    draw() {\n      if (this.renderingState !== RenderingStates.INITIAL) {\n        console.error(\"Must be in new state before drawing\");\n        this.reset(); // Ensure that we reset all state to prevent issues.\n      }\n      const { div, pdfPage } = this;\n\n      if (!pdfPage) {\n        this.renderingState = RenderingStates.FINISHED;\n\n        if (this.loadingIconDiv) {\n          div.removeChild(this.loadingIconDiv);\n          delete this.loadingIconDiv;\n        }\n        return Promise.reject(new Error(\"pdfPage is not loaded\"));\n      }\n\n      this.renderingState = RenderingStates.RUNNING;\n\n      // Wrap the canvas so that if it has a CSS transform for high DPI the\n      // overflow will be hidden in Firefox.\n      const canvasWrapper = document.createElement(\"div\");\n      canvasWrapper.style.width = div.style.width;\n      canvasWrapper.style.height = div.style.height;\n      canvasWrapper.classList.add(\"canvasWrapper\");\n\n      if (this.annotationLayer && this.annotationLayer.div) {\n        // The annotation layer needs to stay on top.\n        div.insertBefore(canvasWrapper, this.annotationLayer.div);\n      } else {\n        div.appendChild(canvasWrapper);\n      }\n\n      let textLayer = null;\n      if (this.textLayerMode !== TextLayerMode.DISABLE && this.textLayerFactory) {\n        const textLayerDiv = document.createElement(\"div\");\n        textLayerDiv.className = \"textLayer\";\n        textLayerDiv.style.width = canvasWrapper.style.width;\n        textLayerDiv.style.height = canvasWrapper.style.height;\n        if (this.annotationLayer && this.annotationLayer.div) {\n          // The annotation layer needs to stay on top.\n          div.insertBefore(textLayerDiv, this.annotationLayer.div);\n        } else {\n          div.appendChild(textLayerDiv);\n        }\n\n        textLayer = this.textLayerFactory.createTextLayerBuilder(\n          textLayerDiv,\n          this.id - 1,\n          this.viewport,\n          this.textLayerMode === TextLayerMode.ENABLE_ENHANCE,\n          this.eventBus\n        );\n      }\n      this.textLayer = textLayer;\n\n      let renderContinueCallback = null;\n      if (this.renderingQueue) {\n        renderContinueCallback = cont => {\n          if (!this.renderingQueue.isHighestPriority(this)) {\n            this.renderingState = RenderingStates.PAUSED;\n            this.resume = () => {\n              this.renderingState = RenderingStates.RUNNING;\n              cont();\n            };\n            return;\n          }\n          cont();\n        };\n      }\n\n      const finishPaintTask = async (error = null) => {\n        // The paintTask may have been replaced by a new one, so only remove\n        // the reference to the paintTask if it matches the one that is\n        // triggering this callback.\n        if (paintTask === this.paintTask) {\n          this.paintTask = null;\n        }\n\n        if (error instanceof RenderingCancelledException) {\n          this._renderError = null;\n          return;\n        }\n        this._renderError = error;\n\n        this.renderingState = RenderingStates.FINISHED;\n\n        if (this.loadingIconDiv) {\n          div.removeChild(this.loadingIconDiv);\n          delete this.loadingIconDiv;\n        }\n        this._resetZoomLayer(/* removeFromDOM = */ true);\n\n        this.eventBus.dispatch(\"pagerendered\", {\n          source: this,\n          pageNumber: this.id,\n          cssTransform: false,\n          timestamp: performance.now(),\n          error: this._renderError,\n        });\n\n        if (error) {\n          throw error;\n        }\n      };\n\n      const paintTask =\n        this.renderer === RendererType.SVG\n          ? this.paintOnSvg(canvasWrapper)\n          : this.paintOnCanvas(canvasWrapper);\n      paintTask.onRenderContinue = renderContinueCallback;\n      this.paintTask = paintTask;\n\n      const resultPromise = paintTask.promise.then(\n        function () {\n          return finishPaintTask(null).then(function () {\n            if (textLayer) {\n              const readableStream = pdfPage.streamTextContent({\n                normalizeWhitespace: true,\n              });\n              textLayer.setTextContentStream(readableStream);\n              textLayer.render();\n            }\n          });\n        },\n        function (reason) {\n          return finishPaintTask(reason);\n        }\n      );\n\n      if (this.annotationLayerFactory) {\n        if (!this.annotationLayer) {\n          this.annotationLayer = this.annotationLayerFactory.createAnnotationLayerBuilder(\n            div,\n            pdfPage,\n            /* annotationStorage = */ null,\n            this.imageResourcesPath,\n            this.renderInteractiveForms,\n            this.l10n,\n            this.enableScripting,\n            /* hasJSActionsPromise = */ null,\n            /* mouseState = */ null\n          );\n        }\n        this._renderAnnotationLayer();\n      }\n      div.setAttribute(\"data-loaded\", true);\n\n      this.eventBus.dispatch(\"pagerender\", {\n        source: this,\n        pageNumber: this.id,\n      });\n      return resultPromise;\n    }\n\n    paintOnCanvas(canvasWrapper) {\n      const renderCapability = createPromiseCapability();\n      const result = {\n        promise: renderCapability.promise,\n        onRenderContinue(cont) {\n          cont();\n        },\n        cancel() {\n          renderTask.cancel();\n        },\n      };\n\n      const viewport = this.viewport;\n      const canvas = document.createElement(\"canvas\");\n      this.l10n\n        .get(\"page_canvas\", { page: this.id }, \"Page {{page}}\")\n        .then(msg => {\n          canvas.setAttribute(\"aria-label\", msg);\n        });\n\n      // Keep the canvas hidden until the first draw callback, or until drawing\n      // is complete when `!this.renderingQueue`, to prevent black flickering.\n      canvas.setAttribute(\"hidden\", \"hidden\");\n      let isCanvasHidden = true;\n      const showCanvas = function () {\n        if (isCanvasHidden) {\n          canvas.removeAttribute(\"hidden\");\n          isCanvasHidden = false;\n        }\n      };\n\n      canvasWrapper.appendChild(canvas);\n      this.canvas = canvas;\n\n      if (\n        typeof PDFJSDev === \"undefined\" ||\n        PDFJSDev.test(\"MOZCENTRAL || GENERIC\")\n      ) {\n        canvas.mozOpaque = true;\n      }\n\n      const ctx = canvas.getContext(\"2d\", { alpha: false });\n      const outputScale = getOutputScale(ctx);\n      this.outputScale = outputScale;\n\n      if (this.useOnlyCssZoom) {\n        const actualSizeViewport = viewport.clone({ scale: CSS_UNITS });\n        // Use a scale that makes the canvas have the originally intended size\n        // of the page.\n        outputScale.sx *= actualSizeViewport.width / viewport.width;\n        outputScale.sy *= actualSizeViewport.height / viewport.height;\n        outputScale.scaled = true;\n      }\n\n      if (this.maxCanvasPixels > 0) {\n        const pixelsInViewport = viewport.width * viewport.height;\n        const maxScale = Math.sqrt(this.maxCanvasPixels / pixelsInViewport);\n        if (outputScale.sx > maxScale || outputScale.sy > maxScale) {\n          outputScale.sx = maxScale;\n          outputScale.sy = maxScale;\n          outputScale.scaled = true;\n          this.hasRestrictedScaling = true;\n        } else {\n          this.hasRestrictedScaling = false;\n        }\n      }\n\n      const sfx = approximateFraction(outputScale.sx);\n      const sfy = approximateFraction(outputScale.sy);\n      canvas.width = roundToDivide(viewport.width * outputScale.sx, sfx[0]);\n      canvas.height = roundToDivide(viewport.height * outputScale.sy, sfy[0]);\n      canvas.style.width = roundToDivide(viewport.width, sfx[1]) + \"px\";\n      canvas.style.height = roundToDivide(viewport.height, sfy[1]) + \"px\";\n      // Add the viewport so it's known what it was originally drawn with.\n      this.paintedViewportMap.set(canvas, viewport);\n\n      // Rendering area\n      const transform = !outputScale.scaled\n        ? null\n        : [outputScale.sx, 0, 0, outputScale.sy, 0, 0];\n      const renderContext = {\n        canvasContext: ctx,\n        transform,\n        viewport: this.viewport,\n        enableWebGL: this.enableWebGL,\n        renderInteractiveForms: this.renderInteractiveForms,\n        optionalContentConfigPromise: this._optionalContentConfigPromise,\n      };\n      const renderTask = this.pdfPage.render(renderContext);\n      renderTask.onContinue = function (cont) {\n        showCanvas();\n        if (result.onRenderContinue) {\n          result.onRenderContinue(cont);\n        } else {\n          cont();\n        }\n      };\n\n      renderTask.promise.then(\n        function () {\n          showCanvas();\n          renderCapability.resolve(undefined);\n        },\n        function (error) {\n          showCanvas();\n          renderCapability.reject(error);\n        }\n      );\n      return result;\n    }\n\n    paintOnSvg(wrapper) {\n      if (\n        typeof PDFJSDev !== \"undefined\" &&\n        PDFJSDev.test(\"MOZCENTRAL || CHROME\")\n      ) {\n        // Return a mock object, to prevent errors such as e.g.\n        // \"TypeError: paintTask.promise is undefined\".\n        return {\n          promise: Promise.reject(new Error(\"SVG rendering is not supported.\")),\n          onRenderContinue(cont) {},\n          cancel() {},\n        };\n      }\n\n      let cancelled = false;\n      const ensureNotCancelled = () => {\n        if (cancelled) {\n          throw new RenderingCancelledException(\n            `Rendering cancelled, page ${this.id}`,\n            \"svg\"\n          );\n        }\n      };\n\n      const pdfPage = this.pdfPage;\n      const actualSizeViewport = this.viewport.clone({ scale: CSS_UNITS });\n      const promise = pdfPage.getOperatorList().then(opList => {\n        ensureNotCancelled();\n        const svgGfx = new SVGGraphics(pdfPage.commonObjs, pdfPage.objs);\n        return svgGfx.getSVG(opList, actualSizeViewport).then(svg => {\n          ensureNotCancelled();\n          this.svg = svg;\n          this.paintedViewportMap.set(svg, actualSizeViewport);\n\n          svg.style.width = wrapper.style.width;\n          svg.style.height = wrapper.style.height;\n          this.renderingState = RenderingStates.FINISHED;\n          wrapper.appendChild(svg);\n        });\n      });\n\n      return {\n        promise,\n        onRenderContinue(cont) {\n          cont();\n        },\n        cancel() {\n          cancelled = true;\n        },\n      };\n    }\n\n    /**\n     * @param {string|null} label\n     */\n    setPageLabel(label) {\n      this.pageLabel = typeof label === \"string\" ? label : null;\n\n      if (this.pageLabel !== null) {\n        this.div.setAttribute(\"data-page-label\", this.pageLabel);\n      } else {\n        this.div.removeAttribute(\"data-page-label\");\n      }\n    }\n  }\n\n  return { PDFPageView };\n});\ndefine('skylark-pdfjs-viewer/text_layer_builder',[\n  \"skylark-pdfjs-display\",\n  \"./pdfjs_dev\"\n],function(pdfjsLib,PDFJSDev){\n  /* Copyright 2012 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { renderTextLayer } = pdfjsLib;\n\n  const EXPAND_DIVS_TIMEOUT = 300; // ms\n\n  /**\n   * @typedef {Object} TextLayerBuilderOptions\n   * @property {HTMLDivElement} textLayerDiv - The text layer container.\n   * @property {EventBus} eventBus - The application event bus.\n   * @property {number} pageIndex - The page index.\n   * @property {PageViewport} viewport - The viewport of the text layer.\n   * @property {PDFFindController} findController\n   * @property {boolean} enhanceTextSelection - Option to turn on improved\n   *   text selection.\n   */\n\n  /**\n   * The text layer builder provides text selection functionality for the PDF.\n   * It does this by creating overlay divs over the PDF's text. These divs\n   * contain text that matches the PDF text they are overlaying. This object\n   * also provides a way to highlight text that is being searched for.\n   */\n  class TextLayerBuilder {\n    constructor({\n      textLayerDiv,\n      eventBus,\n      pageIndex,\n      viewport,\n      findController = null,\n      enhanceTextSelection = false,\n    }) {\n      this.textLayerDiv = textLayerDiv;\n      this.eventBus = eventBus;\n      this.textContent = null;\n      this.textContentItemsStr = [];\n      this.textContentStream = null;\n      this.renderingDone = false;\n      this.pageIdx = pageIndex;\n      this.pageNumber = this.pageIdx + 1;\n      this.matches = [];\n      this.viewport = viewport;\n      this.textDivs = [];\n      this.findController = findController;\n      this.textLayerRenderTask = null;\n      this.enhanceTextSelection = enhanceTextSelection;\n\n      this._onUpdateTextLayerMatches = null;\n      this._bindMouse();\n    }\n\n    /**\n     * @private\n     */\n    _finishRendering() {\n      this.renderingDone = true;\n\n      if (!this.enhanceTextSelection) {\n        const endOfContent = document.createElement(\"div\");\n        endOfContent.className = \"endOfContent\";\n        this.textLayerDiv.appendChild(endOfContent);\n      }\n\n      this.eventBus.dispatch(\"textlayerrendered\", {\n        source: this,\n        pageNumber: this.pageNumber,\n        numTextDivs: this.textDivs.length,\n      });\n    }\n\n    /**\n     * Renders the text layer.\n     *\n     * @param {number} [timeout] - Wait for a specified amount of milliseconds\n     *                             before rendering.\n     */\n    render(timeout = 0) {\n      if (!(this.textContent || this.textContentStream) || this.renderingDone) {\n        return;\n      }\n      this.cancel();\n\n      this.textDivs = [];\n      const textLayerFrag = document.createDocumentFragment();\n      this.textLayerRenderTask = renderTextLayer({\n        textContent: this.textContent,\n        textContentStream: this.textContentStream,\n        container: textLayerFrag,\n        viewport: this.viewport,\n        textDivs: this.textDivs,\n        textContentItemsStr: this.textContentItemsStr,\n        timeout,\n        enhanceTextSelection: this.enhanceTextSelection,\n      });\n      this.textLayerRenderTask.promise.then(\n        () => {\n          this.textLayerDiv.appendChild(textLayerFrag);\n          this._finishRendering();\n          this._updateMatches();\n        },\n        function (reason) {\n          // Cancelled or failed to render text layer; skipping errors.\n        }\n      );\n\n      if (!this._onUpdateTextLayerMatches) {\n        this._onUpdateTextLayerMatches = evt => {\n          if (evt.pageIndex === this.pageIdx || evt.pageIndex === -1) {\n            this._updateMatches();\n          }\n        };\n        this.eventBus._on(\n          \"updatetextlayermatches\",\n          this._onUpdateTextLayerMatches\n        );\n      }\n    }\n\n    /**\n     * Cancel rendering of the text layer.\n     */\n    cancel() {\n      if (this.textLayerRenderTask) {\n        this.textLayerRenderTask.cancel();\n        this.textLayerRenderTask = null;\n      }\n      if (this._onUpdateTextLayerMatches) {\n        this.eventBus._off(\n          \"updatetextlayermatches\",\n          this._onUpdateTextLayerMatches\n        );\n        this._onUpdateTextLayerMatches = null;\n      }\n    }\n\n    setTextContentStream(readableStream) {\n      this.cancel();\n      this.textContentStream = readableStream;\n    }\n\n    setTextContent(textContent) {\n      this.cancel();\n      this.textContent = textContent;\n    }\n\n    _convertMatches(matches, matchesLength) {\n      // Early exit if there is nothing to convert.\n      if (!matches) {\n        return [];\n      }\n      const { textContentItemsStr } = this;\n\n      let i = 0,\n        iIndex = 0;\n      const end = textContentItemsStr.length - 1;\n      const result = [];\n\n      for (let m = 0, mm = matches.length; m < mm; m++) {\n        // Calculate the start position.\n        let matchIdx = matches[m];\n\n        // Loop over the divIdxs.\n        while (i !== end && matchIdx >= iIndex + textContentItemsStr[i].length) {\n          iIndex += textContentItemsStr[i].length;\n          i++;\n        }\n\n        if (i === textContentItemsStr.length) {\n          console.error(\"Could not find a matching mapping\");\n        }\n\n        const match = {\n          begin: {\n            divIdx: i,\n            offset: matchIdx - iIndex,\n          },\n        };\n\n        // Calculate the end position.\n        matchIdx += matchesLength[m];\n\n        // Somewhat the same array as above, but use > instead of >= to get\n        // the end position right.\n        while (i !== end && matchIdx > iIndex + textContentItemsStr[i].length) {\n          iIndex += textContentItemsStr[i].length;\n          i++;\n        }\n\n        match.end = {\n          divIdx: i,\n          offset: matchIdx - iIndex,\n        };\n        result.push(match);\n      }\n      return result;\n    }\n\n    _renderMatches(matches) {\n      // Early exit if there is nothing to render.\n      if (matches.length === 0) {\n        return;\n      }\n      const { findController, pageIdx, textContentItemsStr, textDivs } = this;\n\n      const isSelectedPage = pageIdx === findController.selected.pageIdx;\n      const selectedMatchIdx = findController.selected.matchIdx;\n      const highlightAll = findController.state.highlightAll;\n      let prevEnd = null;\n      const infinity = {\n        divIdx: -1,\n        offset: undefined,\n      };\n\n      function beginText(begin, className) {\n        const divIdx = begin.divIdx;\n        textDivs[divIdx].textContent = \"\";\n        appendTextToDiv(divIdx, 0, begin.offset, className);\n      }\n\n      function appendTextToDiv(divIdx, fromOffset, toOffset, className) {\n        const div = textDivs[divIdx];\n        const content = textContentItemsStr[divIdx].substring(\n          fromOffset,\n          toOffset\n        );\n        const node = document.createTextNode(content);\n        if (className) {\n          const span = document.createElement(\"span\");\n          span.className = className;\n          span.appendChild(node);\n          div.appendChild(span);\n          return;\n        }\n        div.appendChild(node);\n      }\n\n      let i0 = selectedMatchIdx,\n        i1 = i0 + 1;\n      if (highlightAll) {\n        i0 = 0;\n        i1 = matches.length;\n      } else if (!isSelectedPage) {\n        // Not highlighting all and this isn't the selected page, so do nothing.\n        return;\n      }\n\n      for (let i = i0; i < i1; i++) {\n        const match = matches[i];\n        const begin = match.begin;\n        const end = match.end;\n        const isSelected = isSelectedPage && i === selectedMatchIdx;\n        const highlightSuffix = isSelected ? \" selected\" : \"\";\n\n        if (isSelected) {\n          // Attempt to scroll the selected match into view.\n          findController.scrollMatchIntoView({\n            element: textDivs[begin.divIdx],\n            pageIndex: pageIdx,\n            matchIndex: selectedMatchIdx,\n          });\n        }\n\n        // Match inside new div.\n        if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {\n          // If there was a previous div, then add the text at the end.\n          if (prevEnd !== null) {\n            appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);\n          }\n          // Clear the divs and set the content until the starting point.\n          beginText(begin);\n        } else {\n          appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);\n        }\n\n        if (begin.divIdx === end.divIdx) {\n          appendTextToDiv(\n            begin.divIdx,\n            begin.offset,\n            end.offset,\n            \"highlight\" + highlightSuffix\n          );\n        } else {\n          appendTextToDiv(\n            begin.divIdx,\n            begin.offset,\n            infinity.offset,\n            \"highlight begin\" + highlightSuffix\n          );\n          for (let n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {\n            textDivs[n0].className = \"highlight middle\" + highlightSuffix;\n          }\n          beginText(end, \"highlight end\" + highlightSuffix);\n        }\n        prevEnd = end;\n      }\n\n      if (prevEnd) {\n        appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);\n      }\n    }\n\n    _updateMatches() {\n      // Only show matches when all rendering is done.\n      if (!this.renderingDone) {\n        return;\n      }\n      const {\n        findController,\n        matches,\n        pageIdx,\n        textContentItemsStr,\n        textDivs,\n      } = this;\n      let clearedUntilDivIdx = -1;\n\n      // Clear all current matches.\n      for (let i = 0, ii = matches.length; i < ii; i++) {\n        const match = matches[i];\n        const begin = Math.max(clearedUntilDivIdx, match.begin.divIdx);\n        for (let n = begin, end = match.end.divIdx; n <= end; n++) {\n          const div = textDivs[n];\n          div.textContent = textContentItemsStr[n];\n          div.className = \"\";\n        }\n        clearedUntilDivIdx = match.end.divIdx + 1;\n      }\n\n      if (!findController || !findController.highlightMatches) {\n        return;\n      }\n      // Convert the matches on the `findController` into the match format\n      // used for the textLayer.\n      const pageMatches = findController.pageMatches[pageIdx] || null;\n      const pageMatchesLength = findController.pageMatchesLength[pageIdx] || null;\n\n      this.matches = this._convertMatches(pageMatches, pageMatchesLength);\n      this._renderMatches(this.matches);\n    }\n\n    /**\n     * Improves text selection by adding an additional div where the mouse was\n     * clicked. This reduces flickering of the content if the mouse is slowly\n     * dragged up or down.\n     *\n     * @private\n     */\n    _bindMouse() {\n      const div = this.textLayerDiv;\n      let expandDivsTimer = null;\n\n      div.addEventListener(\"mousedown\", evt => {\n        if (this.enhanceTextSelection && this.textLayerRenderTask) {\n          this.textLayerRenderTask.expandTextDivs(true);\n          if (\n            (typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"MOZCENTRAL\")) &&\n            expandDivsTimer\n          ) {\n            clearTimeout(expandDivsTimer);\n            expandDivsTimer = null;\n          }\n          return;\n        }\n\n        const end = div.querySelector(\".endOfContent\");\n        if (!end) {\n          return;\n        }\n        if (typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"MOZCENTRAL\")) {\n          // On non-Firefox browsers, the selection will feel better if the height\n          // of the `endOfContent` div is adjusted to start at mouse click\n          // location. This avoids flickering when the selection moves up.\n          // However it does not work when selection is started on empty space.\n          let adjustTop = evt.target !== div;\n          if (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) {\n            adjustTop =\n              adjustTop &&\n              window\n                .getComputedStyle(end)\n                .getPropertyValue(\"-moz-user-select\") !== \"none\";\n          }\n          if (adjustTop) {\n            const divBounds = div.getBoundingClientRect();\n            const r = Math.max(0, (evt.pageY - divBounds.top) / divBounds.height);\n            end.style.top = (r * 100).toFixed(2) + \"%\";\n          }\n        }\n        end.classList.add(\"active\");\n      });\n\n      div.addEventListener(\"mouseup\", () => {\n        if (this.enhanceTextSelection && this.textLayerRenderTask) {\n          if (typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"MOZCENTRAL\")) {\n            expandDivsTimer = setTimeout(() => {\n              if (this.textLayerRenderTask) {\n                this.textLayerRenderTask.expandTextDivs(false);\n              }\n              expandDivsTimer = null;\n            }, EXPAND_DIVS_TIMEOUT);\n          } else {\n            this.textLayerRenderTask.expandTextDivs(false);\n          }\n          return;\n        }\n\n        const end = div.querySelector(\".endOfContent\");\n        if (!end) {\n          return;\n        }\n        if (typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"MOZCENTRAL\")) {\n          end.style.top = \"\";\n        }\n        end.classList.remove(\"active\");\n      });\n    }\n  }\n\n  /**\n   * @implements IPDFTextLayerFactory\n   */\n  class DefaultTextLayerFactory {\n    /**\n     * @param {HTMLDivElement} textLayerDiv\n     * @param {number} pageIndex\n     * @param {PageViewport} viewport\n     * @param {boolean} enhanceTextSelection\n     * @param {EventBus} eventBus\n     * @returns {TextLayerBuilder}\n     */\n    createTextLayerBuilder(\n      textLayerDiv,\n      pageIndex,\n      viewport,\n      enhanceTextSelection = false,\n      eventBus\n    ) {\n      return new TextLayerBuilder({\n        textLayerDiv,\n        pageIndex,\n        viewport,\n        enhanceTextSelection,\n        eventBus,\n      });\n    }\n  }\n\n  return { \n    DefaultTextLayerFactory, \n    TextLayerBuilder \n  };\n});\ndefine('skylark-pdfjs-viewer/base_viewer',[\n  \"skylark-pdfjs-display\",\n  \"./pdfjs_dev\",\n  \"./ui_utils\",\n  \"./pdf_rendering_queue\",\n  \"./annotation_layer_builder\",\n  \"./pdf_page_view\",\n  \"./pdf_link_service\",\n  \"./text_layer_builder\"\n],function(\n  pdfjsLib,\n  PDFJSDev,\n  ui_utils,\n  pdf_rendering_queue,\n  annotation_layer_builder,\n  pdf_page_view,\n  pdf_link_service,\n  text_layer_builder\n\n){\n\n  /* Copyright 2014 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { createPromiseCapability, version } = pdfjsLib;\n  const {\n    CSS_UNITS,\n    DEFAULT_SCALE,\n    DEFAULT_SCALE_VALUE,\n    getVisibleElements,\n    isPortraitOrientation,\n    isValidRotation,\n    isValidScrollMode,\n    isValidSpreadMode,\n    MAX_AUTO_SCALE,\n    moveToEndOfArray,\n    NullL10n,\n    PresentationModeState,\n    RendererType,\n    SCROLLBAR_PADDING,\n    scrollIntoView,\n    ScrollMode,\n    SpreadMode,\n    TextLayerMode,\n    UNKNOWN_SCALE,\n    VERTICAL_PADDING,\n    watchScroll,\n  } = ui_utils;\n  const { PDFRenderingQueue, RenderingStates } = pdf_rendering_queue;\n  const { AnnotationLayerBuilder } = annotation_layer_builder;\n  const { PDFPageView } = pdf_page_view;\n  const { SimpleLinkService } = pdf_link_service;\n  const { TextLayerBuilder } = text_layer_builder;\n\n  const DEFAULT_CACHE_SIZE = 10;\n\n  /**\n   * @typedef {Object} PDFViewerOptions\n   * @property {HTMLDivElement} container - The container for the viewer element.\n   * @property {HTMLDivElement} [viewer] - The viewer element.\n   * @property {EventBus} eventBus - The application event bus.\n   * @property {IPDFLinkService} linkService - The navigation/linking service.\n   * @property {DownloadManager} [downloadManager] - The download manager\n   *   component.\n   * @property {PDFFindController} [findController] - The find controller\n   *   component.\n   * @property {PDFRenderingQueue} [renderingQueue] - The rendering queue object.\n   * @property {boolean} [removePageBorders] - Removes the border shadow around\n   *   the pages. The default value is `false`.\n   * @property {number} [textLayerMode] - Controls if the text layer used for\n   *   selection and searching is created, and if the improved text selection\n   *   behaviour is enabled. The constants from {TextLayerMode} should be used.\n   *   The default value is `TextLayerMode.ENABLE`.\n   * @property {string} [imageResourcesPath] - Path for image resources, mainly\n   *   mainly for annotation icons. Include trailing slash.\n   * @property {boolean} [renderInteractiveForms] - Enables rendering of\n   *   interactive form elements. The default value is `true`.\n   * @property {boolean} [enablePrintAutoRotate] - Enables automatic rotation of\n   *   landscape pages upon printing. The default is `false`.\n   * @property {string} renderer - 'canvas' or 'svg'. The default is 'canvas'.\n   * @property {boolean} [enableWebGL] - Enables WebGL accelerated rendering for\n   *   some operations. The default value is `false`.\n   * @property {boolean} [useOnlyCssZoom] - Enables CSS only zooming. The default\n   *   value is `false`.\n   * @property {number} [maxCanvasPixels] - The maximum supported canvas size in\n   *   total pixels, i.e. width * height. Use -1 for no limit. The default value\n   *   is 4096 * 4096 (16 mega-pixels).\n   * @property {IL10n} l10n - Localization service.\n   * @property {boolean} [enableScripting] - Enable embedded script execution.\n   *   The default value is `false`.\n   * @property {Object} [mouseState] - The mouse button state. The default value\n   *   is `null`.\n   */\n\n  function PDFPageViewBuffer(size) {\n    const data = [];\n    this.push = function (view) {\n      const i = data.indexOf(view);\n      if (i >= 0) {\n        data.splice(i, 1);\n      }\n      data.push(view);\n      if (data.length > size) {\n        data.shift().destroy();\n      }\n    };\n    /**\n     * After calling resize, the size of the buffer will be newSize. The optional\n     * parameter pagesToKeep is, if present, an array of pages to push to the back\n     * of the buffer, delaying their destruction. The size of pagesToKeep has no\n     * impact on the final size of the buffer; if pagesToKeep has length larger\n     * than newSize, some of those pages will be destroyed anyway.\n     */\n    this.resize = function (newSize, pagesToKeep) {\n      size = newSize;\n      if (pagesToKeep) {\n        const pageIdsToKeep = new Set();\n        for (let i = 0, iMax = pagesToKeep.length; i < iMax; ++i) {\n          pageIdsToKeep.add(pagesToKeep[i].id);\n        }\n        moveToEndOfArray(data, function (page) {\n          return pageIdsToKeep.has(page.id);\n        });\n      }\n      while (data.length > size) {\n        data.shift().destroy();\n      }\n    };\n\n    this.has = function (view) {\n      return data.includes(view);\n    };\n  }\n\n  function isSameScale(oldScale, newScale) {\n    if (newScale === oldScale) {\n      return true;\n    }\n    if (Math.abs(newScale - oldScale) < 1e-15) {\n      // Prevent unnecessary re-rendering of all pages when the scale\n      // changes only because of limited numerical precision.\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Simple viewer control to display PDF content/pages.\n   * @implements {IRenderableView}\n   */\n  class BaseViewer {\n    /**\n     * @param {PDFViewerOptions} options\n     */\n    constructor(options) {\n      if (this.constructor === BaseViewer) {\n        throw new Error(\"Cannot initialize BaseViewer.\");\n      }\n\n      //TODO : checking\n      const viewerVersion =\n        typeof PDFJSDev !== \"undefined\" ? PDFJSDev.eval(\"BUNDLE_VERSION\") : null;\n      if (version !== viewerVersion) {\n        throw new Error(\n          `The API version \"${version}\" does not match the Viewer version \"${viewerVersion}\".`\n        );\n      }\n      this._name = this.constructor.name;\n\n      this.container = options.container;\n      this.viewer = options.viewer || options.container.firstElementChild;\n\n      //TODO : checking\n      if (\n        typeof PDFJSDev === \"undefined\" ||\n        PDFJSDev.test(\"!PRODUCTION || GENERIC\")\n      ) {\n        if (\n          !(\n            ///this.container?.tagName.toUpperCase() === \"DIV\" && // lwf \n            this.container && this.container.tagName.toUpperCase() === \"DIV\" &&\n            ///this.viewer?.tagName.toUpperCase() === \"DIV\" // lwf\n            this.viewer && this.viewer.tagName.toUpperCase() === \"DIV\"\n          )\n        ) {\n          throw new Error(\"Invalid `container` and/or `viewer` option.\");\n        }\n\n        if (getComputedStyle(this.container).position !== \"absolute\") {\n          throw new Error(\"The `container` must be absolutely positioned.\");\n        }\n      }\n      this.eventBus = options.eventBus;\n      this.linkService = options.linkService || new SimpleLinkService();\n      this.downloadManager = options.downloadManager || null;\n      this.findController = options.findController || null;\n      this.removePageBorders = options.removePageBorders || false;\n      this.textLayerMode = Number.isInteger(options.textLayerMode)\n        ? options.textLayerMode\n        : TextLayerMode.ENABLE;\n      this.imageResourcesPath = options.imageResourcesPath || \"\";\n      this.renderInteractiveForms =\n        typeof options.renderInteractiveForms === \"boolean\"\n          ? options.renderInteractiveForms\n          : true;\n      this.enablePrintAutoRotate = options.enablePrintAutoRotate || false;\n      this.renderer = options.renderer || RendererType.CANVAS;\n      this.enableWebGL = options.enableWebGL || false;\n      this.useOnlyCssZoom = options.useOnlyCssZoom || false;\n      this.maxCanvasPixels = options.maxCanvasPixels;\n      this.l10n = options.l10n || NullL10n;\n      this.enableScripting = options.enableScripting || false;\n      this._mouseState = options.mouseState || null;\n\n      this.defaultRenderingQueue = !options.renderingQueue;\n      if (this.defaultRenderingQueue) {\n        // Custom rendering queue is not specified, using default one\n        this.renderingQueue = new PDFRenderingQueue();\n        this.renderingQueue.setViewer(this);\n      } else {\n        this.renderingQueue = options.renderingQueue;\n      }\n\n      this.scroll = watchScroll(this.container, this._scrollUpdate.bind(this));\n      this.presentationModeState = PresentationModeState.UNKNOWN;\n      this._onBeforeDraw = this._onAfterDraw = null;\n      this._resetView();\n\n      if (this.removePageBorders) {\n        this.viewer.classList.add(\"removePageBorders\");\n      }\n      // Defer the dispatching of this event, to give other viewer components\n      // time to initialize *and* register 'baseviewerinit' event listeners.\n      Promise.resolve().then(() => {\n        this.eventBus.dispatch(\"baseviewerinit\", { source: this });\n      });\n    }\n\n    get pagesCount() {\n      return this._pages.length;\n    }\n\n    getPageView(index) {\n      return this._pages[index];\n    }\n\n    /**\n     * @type {boolean} - True if all {PDFPageView} objects are initialized.\n     */\n    get pageViewsReady() {\n      if (!this._pagesCapability.settled) {\n        return false;\n      }\n      // Prevent printing errors when 'disableAutoFetch' is set, by ensuring\n      // that *all* pages have in fact been completely loaded.\n      return this._pages.every(function (pageView) {\n        return pageView && pageView.pdfPage;\n      });\n    }\n\n    /**\n     * @type {number}\n     */\n    get currentPageNumber() {\n      return this._currentPageNumber;\n    }\n\n    /**\n     * @param {number} val - The page number.\n     */\n    set currentPageNumber(val) {\n      if (!Number.isInteger(val)) {\n        throw new Error(\"Invalid page number.\");\n      }\n      if (!this.pdfDocument) {\n        return;\n      }\n      // The intent can be to just reset a scroll position and/or scale.\n      if (!this._setCurrentPageNumber(val, /* resetCurrentPageView = */ true)) {\n        console.error(\n          `${this._name}.currentPageNumber: \"${val}\" is not a valid page.`\n        );\n      }\n    }\n\n    /**\n     * @returns {boolean} Whether the pageNumber is valid (within bounds).\n     * @private\n     */\n    _setCurrentPageNumber(val, resetCurrentPageView = false) {\n      if (this._currentPageNumber === val) {\n        if (resetCurrentPageView) {\n          this._resetCurrentPageView();\n        }\n        return true;\n      }\n\n      if (!(0 < val && val <= this.pagesCount)) {\n        return false;\n      }\n      const previous = this._currentPageNumber;\n      this._currentPageNumber = val;\n\n      this.eventBus.dispatch(\"pagechanging\", {\n        source: this,\n        pageNumber: val,\n        pageLabel: this._pageLabels && this._pageLabels[val - 1],\n        previous,\n      });\n\n      if (resetCurrentPageView) {\n        this._resetCurrentPageView();\n      }\n      return true;\n    }\n\n    /**\n     * @type {string|null} Returns the current page label, or `null` if no page\n     *   labels exist.\n     */\n    get currentPageLabel() {\n      return this._pageLabels && this._pageLabels[this._currentPageNumber - 1];\n    }\n\n    /**\n     * @param {string} val - The page label.\n     */\n    set currentPageLabel(val) {\n      if (!this.pdfDocument) {\n        return;\n      }\n      let page = val | 0; // Fallback page number.\n      if (this._pageLabels) {\n        const i = this._pageLabels.indexOf(val);\n        if (i >= 0) {\n          page = i + 1;\n        }\n      }\n      // The intent can be to just reset a scroll position and/or scale.\n      if (!this._setCurrentPageNumber(page, /* resetCurrentPageView = */ true)) {\n        console.error(\n          `${this._name}.currentPageLabel: \"${val}\" is not a valid page.`\n        );\n      }\n    }\n\n    /**\n     * @type {number}\n     */\n    get currentScale() {\n      return this._currentScale !== UNKNOWN_SCALE\n        ? this._currentScale\n        : DEFAULT_SCALE;\n    }\n\n    /**\n     * @param {number} val - Scale of the pages in percents.\n     */\n    set currentScale(val) {\n      if (isNaN(val)) {\n        throw new Error(\"Invalid numeric scale.\");\n      }\n      if (!this.pdfDocument) {\n        return;\n      }\n      this._setScale(val, false);\n    }\n\n    /**\n     * @type {string}\n     */\n    get currentScaleValue() {\n      return this._currentScaleValue;\n    }\n\n    /**\n     * @param val - The scale of the pages (in percent or predefined value).\n     */\n    set currentScaleValue(val) {\n      if (!this.pdfDocument) {\n        return;\n      }\n      this._setScale(val, false);\n    }\n\n    /**\n     * @type {number}\n     */\n    get pagesRotation() {\n      return this._pagesRotation;\n    }\n\n    /**\n     * @param {number} rotation - The rotation of the pages (0, 90, 180, 270).\n     */\n    set pagesRotation(rotation) {\n      if (!isValidRotation(rotation)) {\n        throw new Error(\"Invalid pages rotation angle.\");\n      }\n      if (!this.pdfDocument) {\n        return;\n      }\n      if (this._pagesRotation === rotation) {\n        return; // The rotation didn't change.\n      }\n      this._pagesRotation = rotation;\n\n      const pageNumber = this._currentPageNumber;\n\n      for (let i = 0, ii = this._pages.length; i < ii; i++) {\n        const pageView = this._pages[i];\n        pageView.update(pageView.scale, rotation);\n      }\n      // Prevent errors in case the rotation changes *before* the scale has been\n      // set to a non-default value.\n      if (this._currentScaleValue) {\n        this._setScale(this._currentScaleValue, true);\n      }\n\n      this.eventBus.dispatch(\"rotationchanging\", {\n        source: this,\n        pagesRotation: rotation,\n        pageNumber,\n      });\n\n      if (this.defaultRenderingQueue) {\n        this.update();\n      }\n    }\n\n    get firstPagePromise() {\n      return this.pdfDocument ? this._firstPageCapability.promise : null;\n    }\n\n    get onePageRendered() {\n      return this.pdfDocument ? this._onePageRenderedCapability.promise : null;\n    }\n\n    get pagesPromise() {\n      return this.pdfDocument ? this._pagesCapability.promise : null;\n    }\n\n    /**\n     * @private\n     */\n    get _viewerElement() {\n      // In most viewers, e.g. `PDFViewer`, this should return `this.viewer`.\n      throw new Error(\"Not implemented: _viewerElement\");\n    }\n\n    /**\n     * @private\n     */\n    _onePageRenderedOrForceFetch() {\n      // Unless the viewer *and* its pages are visible, rendering won't start and\n      // `this._onePageRenderedCapability` thus won't be resolved.\n      // To ensure that automatic printing, on document load, still works even in\n      // those cases we force-allow fetching of all pages when:\n      //  - The viewer is hidden in the DOM, e.g. in a `display: none` <iframe>\n      //    element; fixes bug 1618621.\n      //  - The viewer is visible, but none of the pages are (e.g. if the\n      //    viewer is very small); fixes bug 1618955.\n      if (\n        !this.container.offsetParent ||\n        this._getVisiblePages().views.length === 0\n      ) {\n        return Promise.resolve();\n      }\n      return this._onePageRenderedCapability.promise;\n    }\n\n    /**\n     * @param pdfDocument {PDFDocument}\n     */\n    setDocument(pdfDocument) {\n      if (this.pdfDocument) {\n        this.eventBus.dispatch(\"pagesdestroy\", { source: this });\n\n        this._cancelRendering();\n        this._resetView();\n\n        if (this.findController) {\n          this.findController.setDocument(null);\n        }\n      }\n\n      this.pdfDocument = pdfDocument;\n      if (!pdfDocument) {\n        return;\n      }\n      const pagesCount = pdfDocument.numPages;\n      const firstPagePromise = pdfDocument.getPage(1);\n      // Rendering (potentially) depends on this, hence fetching it immediately.\n      const optionalContentConfigPromise = pdfDocument.getOptionalContentConfig();\n\n      this._pagesCapability.promise.then(() => {\n        this.eventBus.dispatch(\"pagesloaded\", {\n          source: this,\n          pagesCount,\n        });\n      });\n\n      this._onBeforeDraw = evt => {\n        const pageView = this._pages[evt.pageNumber - 1];\n        if (!pageView) {\n          return;\n        }\n        // Add the page to the buffer at the start of drawing. That way it can be\n        // evicted from the buffer and destroyed even if we pause its rendering.\n        this._buffer.push(pageView);\n      };\n      this.eventBus._on(\"pagerender\", this._onBeforeDraw);\n\n      this._onAfterDraw = evt => {\n        if (evt.cssTransform || this._onePageRenderedCapability.settled) {\n          return;\n        }\n        this._onePageRenderedCapability.resolve();\n\n        this.eventBus._off(\"pagerendered\", this._onAfterDraw);\n        this._onAfterDraw = null;\n      };\n      this.eventBus._on(\"pagerendered\", this._onAfterDraw);\n\n      // Fetch a single page so we can get a viewport that will be the default\n      // viewport for all pages\n      firstPagePromise\n        .then(firstPdfPage => {\n          this._firstPageCapability.resolve(firstPdfPage);\n          this._optionalContentConfigPromise = optionalContentConfigPromise;\n\n          const scale = this.currentScale;\n          const viewport = firstPdfPage.getViewport({ scale: scale * CSS_UNITS });\n          const textLayerFactory =\n            this.textLayerMode !== TextLayerMode.DISABLE ? this : null;\n\n          for (let pageNum = 1; pageNum <= pagesCount; ++pageNum) {\n            const pageView = new PDFPageView({\n              container: this._viewerElement,\n              eventBus: this.eventBus,\n              id: pageNum,\n              scale,\n              defaultViewport: viewport.clone(),\n              optionalContentConfigPromise,\n              renderingQueue: this.renderingQueue,\n              textLayerFactory,\n              textLayerMode: this.textLayerMode,\n              annotationLayerFactory: this,\n              imageResourcesPath: this.imageResourcesPath,\n              renderInteractiveForms: this.renderInteractiveForms,\n              renderer: this.renderer,\n              enableWebGL: this.enableWebGL,\n              useOnlyCssZoom: this.useOnlyCssZoom,\n              maxCanvasPixels: this.maxCanvasPixels,\n              l10n: this.l10n,\n              enableScripting: this.enableScripting,\n            });\n            this._pages.push(pageView);\n          }\n          // Set the first `pdfPage` immediately, since it's already loaded,\n          // rather than having to repeat the `PDFDocumentProxy.getPage` call in\n          // the `this._ensurePdfPageLoaded` method before rendering can start.\n          const firstPageView = this._pages[0];\n          if (firstPageView) {\n            firstPageView.setPdfPage(firstPdfPage);\n            this.linkService.cachePageRef(1, firstPdfPage.ref);\n          }\n          if (this._spreadMode !== SpreadMode.NONE) {\n            this._updateSpreadMode();\n          }\n\n          // Fetch all the pages since the viewport is needed before printing\n          // starts to create the correct size canvas. Wait until one page is\n          // rendered so we don't tie up too many resources early on.\n          this._onePageRenderedOrForceFetch().then(() => {\n            if (this.findController) {\n              this.findController.setDocument(pdfDocument); // Enable searching.\n            }\n\n            // In addition to 'disableAutoFetch' being set, also attempt to reduce\n            // resource usage when loading *very* long/large documents.\n            if (pdfDocument.loadingParams.disableAutoFetch || pagesCount > 7500) {\n              // XXX: Printing is semi-broken with auto fetch disabled.\n              this._pagesCapability.resolve();\n              return;\n            }\n            let getPagesLeft = pagesCount - 1; // The first page was already loaded.\n\n            if (getPagesLeft <= 0) {\n              this._pagesCapability.resolve();\n              return;\n            }\n            for (let pageNum = 2; pageNum <= pagesCount; ++pageNum) {\n              pdfDocument.getPage(pageNum).then(\n                pdfPage => {\n                  const pageView = this._pages[pageNum - 1];\n                  if (!pageView.pdfPage) {\n                    pageView.setPdfPage(pdfPage);\n                  }\n                  this.linkService.cachePageRef(pageNum, pdfPage.ref);\n                  if (--getPagesLeft === 0) {\n                    this._pagesCapability.resolve();\n                  }\n                },\n                reason => {\n                  console.error(\n                    `Unable to get page ${pageNum} to initialize viewer`,\n                    reason\n                  );\n                  if (--getPagesLeft === 0) {\n                    this._pagesCapability.resolve();\n                  }\n                }\n              );\n            }\n          });\n\n          this.eventBus.dispatch(\"pagesinit\", { source: this });\n\n          if (this.defaultRenderingQueue) {\n            this.update();\n          }\n        })\n        .catch(reason => {\n          console.error(\"Unable to initialize viewer\", reason);\n        });\n    }\n\n    /**\n     * @param {Array|null} labels\n     */\n    setPageLabels(labels) {\n      if (!this.pdfDocument) {\n        return;\n      }\n      if (!labels) {\n        this._pageLabels = null;\n      } else if (\n        !(Array.isArray(labels) && this.pdfDocument.numPages === labels.length)\n      ) {\n        this._pageLabels = null;\n        console.error(`${this._name}.setPageLabels: Invalid page labels.`);\n      } else {\n        this._pageLabels = labels;\n      }\n      // Update all the `PDFPageView` instances.\n      for (let i = 0, ii = this._pages.length; i < ii; i++) {\n        const pageView = this._pages[i];\n        const label = this._pageLabels && this._pageLabels[i];\n        pageView.setPageLabel(label);\n      }\n    }\n\n    _resetView() {\n      this._pages = [];\n      this._currentPageNumber = 1;\n      this._currentScale = UNKNOWN_SCALE;\n      this._currentScaleValue = null;\n      this._pageLabels = null;\n      this._buffer = new PDFPageViewBuffer(DEFAULT_CACHE_SIZE);\n      this._location = null;\n      this._pagesRotation = 0;\n      this._optionalContentConfigPromise = null;\n      this._pagesRequests = new WeakMap();\n      this._firstPageCapability = createPromiseCapability();\n      this._onePageRenderedCapability = createPromiseCapability();\n      this._pagesCapability = createPromiseCapability();\n      this._scrollMode = ScrollMode.VERTICAL;\n      this._spreadMode = SpreadMode.NONE;\n\n      if (this._onBeforeDraw) {\n        this.eventBus._off(\"pagerender\", this._onBeforeDraw);\n        this._onBeforeDraw = null;\n      }\n      if (this._onAfterDraw) {\n        this.eventBus._off(\"pagerendered\", this._onAfterDraw);\n        this._onAfterDraw = null;\n      }\n      this._resetScriptingEvents();\n\n      // Remove the pages from the DOM...\n      this.viewer.textContent = \"\";\n      // ... and reset the Scroll mode CSS class(es) afterwards.\n      this._updateScrollMode();\n    }\n\n    _scrollUpdate() {\n      if (this.pagesCount === 0) {\n        return;\n      }\n      this.update();\n    }\n\n    _scrollIntoView({ pageDiv, pageSpot = null, pageNumber = null }) {\n      scrollIntoView(pageDiv, pageSpot);\n    }\n\n    _setScaleUpdatePages(newScale, newValue, noScroll = false, preset = false) {\n      this._currentScaleValue = newValue.toString();\n\n      if (isSameScale(this._currentScale, newScale)) {\n        if (preset) {\n          this.eventBus.dispatch(\"scalechanging\", {\n            source: this,\n            scale: newScale,\n            presetValue: newValue,\n          });\n        }\n        return;\n      }\n\n      for (let i = 0, ii = this._pages.length; i < ii; i++) {\n        this._pages[i].update(newScale);\n      }\n      this._currentScale = newScale;\n\n      if (!noScroll) {\n        let page = this._currentPageNumber,\n          dest;\n        if (\n          this._location &&\n          !(this.isInPresentationMode || this.isChangingPresentationMode)\n        ) {\n          page = this._location.pageNumber;\n          dest = [\n            null,\n            { name: \"XYZ\" },\n            this._location.left,\n            this._location.top,\n            null,\n          ];\n        }\n        this.scrollPageIntoView({\n          pageNumber: page,\n          destArray: dest,\n          allowNegativeOffset: true,\n        });\n      }\n\n      this.eventBus.dispatch(\"scalechanging\", {\n        source: this,\n        scale: newScale,\n        presetValue: preset ? newValue : undefined,\n      });\n\n      if (this.defaultRenderingQueue) {\n        this.update();\n      }\n    }\n\n    /**\n     * @private\n     */\n    get _pageWidthScaleFactor() {\n      if (\n        this.spreadMode !== SpreadMode.NONE &&\n        this.scrollMode !== ScrollMode.HORIZONTAL &&\n        !this.isInPresentationMode\n      ) {\n        return 2;\n      }\n      return 1;\n    }\n\n    _setScale(value, noScroll = false) {\n      let scale = parseFloat(value);\n\n      if (scale > 0) {\n        this._setScaleUpdatePages(scale, value, noScroll, /* preset = */ false);\n      } else {\n        const currentPage = this._pages[this._currentPageNumber - 1];\n        if (!currentPage) {\n          return;\n        }\n        const noPadding = this.isInPresentationMode || this.removePageBorders;\n        let hPadding = noPadding ? 0 : SCROLLBAR_PADDING;\n        let vPadding = noPadding ? 0 : VERTICAL_PADDING;\n\n        if (!noPadding && this._isScrollModeHorizontal) {\n          [hPadding, vPadding] = [vPadding, hPadding]; // Swap the padding values.\n        }\n        const pageWidthScale =\n          (((this.container.clientWidth - hPadding) / currentPage.width) *\n            currentPage.scale) /\n          this._pageWidthScaleFactor;\n        const pageHeightScale =\n          ((this.container.clientHeight - vPadding) / currentPage.height) *\n          currentPage.scale;\n        switch (value) {\n          case \"page-actual\":\n            scale = 1;\n            break;\n          case \"page-width\":\n            scale = pageWidthScale;\n            break;\n          case \"page-height\":\n            scale = pageHeightScale;\n            break;\n          case \"page-fit\":\n            scale = Math.min(pageWidthScale, pageHeightScale);\n            break;\n          case \"auto\":\n            // For pages in landscape mode, fit the page height to the viewer\n            // *unless* the page would thus become too wide to fit horizontally.\n            const horizontalScale = isPortraitOrientation(currentPage)\n              ? pageWidthScale\n              : Math.min(pageHeightScale, pageWidthScale);\n            scale = Math.min(MAX_AUTO_SCALE, horizontalScale);\n            break;\n          default:\n            console.error(\n              `${this._name}._setScale: \"${value}\" is an unknown zoom value.`\n            );\n            return;\n        }\n        this._setScaleUpdatePages(scale, value, noScroll, /* preset = */ true);\n      }\n    }\n\n    /**\n     * Refreshes page view: scrolls to the current page and updates the scale.\n     * @private\n     */\n    _resetCurrentPageView() {\n      if (this.isInPresentationMode) {\n        // Fixes the case when PDF has different page sizes.\n        this._setScale(this._currentScaleValue, true);\n      }\n\n      const pageView = this._pages[this._currentPageNumber - 1];\n      this._scrollIntoView({ pageDiv: pageView.div });\n    }\n\n    /**\n     * @param {string} label - The page label.\n     * @returns {number|null} The page number corresponding to the page label,\n     *   or `null` when no page labels exist and/or the input is invalid.\n     */\n    pageLabelToPageNumber(label) {\n      if (!this._pageLabels) {\n        return null;\n      }\n      const i = this._pageLabels.indexOf(label);\n      if (i < 0) {\n        return null;\n      }\n      return i + 1;\n    }\n\n    /**\n     * @typedef ScrollPageIntoViewParameters\n     * @property {number} pageNumber - The page number.\n     * @property {Array} [destArray] - The original PDF destination array, in the\n     *   format: <page-ref> </XYZ|/FitXXX> <args..>\n     * @property {boolean} [allowNegativeOffset] - Allow negative page offsets.\n     *   The default value is `false`.\n     * @property {boolean} [ignoreDestinationZoom] - Ignore the zoom argument in\n     *   the destination array. The default value is `false`.\n     */\n\n    /**\n     * Scrolls page into view.\n     * @param {ScrollPageIntoViewParameters} params\n     */\n    scrollPageIntoView({\n      pageNumber,\n      destArray = null,\n      allowNegativeOffset = false,\n      ignoreDestinationZoom = false,\n    }) {\n      if (!this.pdfDocument) {\n        return;\n      }\n      const pageView =\n        Number.isInteger(pageNumber) && this._pages[pageNumber - 1];\n      if (!pageView) {\n        console.error(\n          `${this._name}.scrollPageIntoView: ` +\n            `\"${pageNumber}\" is not a valid pageNumber parameter.`\n        );\n        return;\n      }\n\n      if (this.isInPresentationMode || !destArray) {\n        this._setCurrentPageNumber(pageNumber, /* resetCurrentPageView = */ true);\n        return;\n      }\n      let x = 0,\n        y = 0;\n      let width = 0,\n        height = 0,\n        widthScale,\n        heightScale;\n      const changeOrientation = pageView.rotation % 180 !== 0;\n      const pageWidth =\n        (changeOrientation ? pageView.height : pageView.width) /\n        pageView.scale /\n        CSS_UNITS;\n      const pageHeight =\n        (changeOrientation ? pageView.width : pageView.height) /\n        pageView.scale /\n        CSS_UNITS;\n      let scale = 0;\n      switch (destArray[1].name) {\n        case \"XYZ\":\n          x = destArray[2];\n          y = destArray[3];\n          scale = destArray[4];\n          // If x and/or y coordinates are not supplied, default to\n          // _top_ left of the page (not the obvious bottom left,\n          // since aligning the bottom of the intended page with the\n          // top of the window is rarely helpful).\n          x = x !== null ? x : 0;\n          y = y !== null ? y : pageHeight;\n          break;\n        case \"Fit\":\n        case \"FitB\":\n          scale = \"page-fit\";\n          break;\n        case \"FitH\":\n        case \"FitBH\":\n          y = destArray[2];\n          scale = \"page-width\";\n          // According to the PDF spec, section 12.3.2.2, a `null` value in the\n          // parameter should maintain the position relative to the new page.\n          if (y === null && this._location) {\n            x = this._location.left;\n            y = this._location.top;\n          } else if (typeof y !== \"number\") {\n            // The \"top\" value isn't optional, according to the spec, however some\n            // bad PDF generators will pretend that it is (fixes bug 1663390).\n            y = pageHeight;\n          }\n          break;\n        case \"FitV\":\n        case \"FitBV\":\n          x = destArray[2];\n          width = pageWidth;\n          height = pageHeight;\n          scale = \"page-height\";\n          break;\n        case \"FitR\":\n          x = destArray[2];\n          y = destArray[3];\n          width = destArray[4] - x;\n          height = destArray[5] - y;\n          const hPadding = this.removePageBorders ? 0 : SCROLLBAR_PADDING;\n          const vPadding = this.removePageBorders ? 0 : VERTICAL_PADDING;\n\n          widthScale =\n            (this.container.clientWidth - hPadding) / width / CSS_UNITS;\n          heightScale =\n            (this.container.clientHeight - vPadding) / height / CSS_UNITS;\n          scale = Math.min(Math.abs(widthScale), Math.abs(heightScale));\n          break;\n        default:\n          console.error(\n            `${this._name}.scrollPageIntoView: ` +\n              `\"${destArray[1].name}\" is not a valid destination type.`\n          );\n          return;\n      }\n\n      if (!ignoreDestinationZoom) {\n        if (scale && scale !== this._currentScale) {\n          this.currentScaleValue = scale;\n        } else if (this._currentScale === UNKNOWN_SCALE) {\n          this.currentScaleValue = DEFAULT_SCALE_VALUE;\n        }\n      }\n\n      if (scale === \"page-fit\" && !destArray[4]) {\n        this._scrollIntoView({\n          pageDiv: pageView.div,\n          pageNumber,\n        });\n        return;\n      }\n\n      const boundingRect = [\n        pageView.viewport.convertToViewportPoint(x, y),\n        pageView.viewport.convertToViewportPoint(x + width, y + height),\n      ];\n      let left = Math.min(boundingRect[0][0], boundingRect[1][0]);\n      let top = Math.min(boundingRect[0][1], boundingRect[1][1]);\n\n      if (!allowNegativeOffset) {\n        // Some bad PDF generators will create destinations with e.g. top values\n        // that exceeds the page height. Ensure that offsets are not negative,\n        // to prevent a previous page from becoming visible (fixes bug 874482).\n        left = Math.max(left, 0);\n        top = Math.max(top, 0);\n      }\n      this._scrollIntoView({\n        pageDiv: pageView.div,\n        pageSpot: { left, top },\n        pageNumber,\n      });\n    }\n\n    _updateLocation(firstPage) {\n      const currentScale = this._currentScale;\n      const currentScaleValue = this._currentScaleValue;\n      const normalizedScaleValue =\n        parseFloat(currentScaleValue) === currentScale\n          ? Math.round(currentScale * 10000) / 100\n          : currentScaleValue;\n\n      const pageNumber = firstPage.id;\n      let pdfOpenParams = \"#page=\" + pageNumber;\n      pdfOpenParams += \"&zoom=\" + normalizedScaleValue;\n      const currentPageView = this._pages[pageNumber - 1];\n      const container = this.container;\n      const topLeft = currentPageView.getPagePoint(\n        container.scrollLeft - firstPage.x,\n        container.scrollTop - firstPage.y\n      );\n      const intLeft = Math.round(topLeft[0]);\n      const intTop = Math.round(topLeft[1]);\n      pdfOpenParams += \",\" + intLeft + \",\" + intTop;\n\n      this._location = {\n        pageNumber,\n        scale: normalizedScaleValue,\n        top: intTop,\n        left: intLeft,\n        rotation: this._pagesRotation,\n        pdfOpenParams,\n      };\n    }\n\n    _updateHelper(visiblePages) {\n      throw new Error(\"Not implemented: _updateHelper\");\n    }\n\n    update() {\n      const visible = this._getVisiblePages();\n      const visiblePages = visible.views,\n        numVisiblePages = visiblePages.length;\n\n      if (numVisiblePages === 0) {\n        return;\n      }\n      const newCacheSize = Math.max(DEFAULT_CACHE_SIZE, 2 * numVisiblePages + 1);\n      this._buffer.resize(newCacheSize, visiblePages);\n\n      this.renderingQueue.renderHighestPriority(visible);\n\n      this._updateHelper(visiblePages); // Run any class-specific update code.\n\n      this._updateLocation(visible.first);\n      this.eventBus.dispatch(\"updateviewarea\", {\n        source: this,\n        location: this._location,\n      });\n    }\n\n    containsElement(element) {\n      return this.container.contains(element);\n    }\n\n    focus() {\n      this.container.focus();\n    }\n\n    get _isScrollModeHorizontal() {\n      // Used to ensure that pre-rendering of the next/previous page works\n      // correctly, since Scroll/Spread modes are ignored in Presentation Mode.\n      return this.isInPresentationMode\n        ? false\n        : this._scrollMode === ScrollMode.HORIZONTAL;\n    }\n\n    get _isContainerRtl() {\n      return getComputedStyle(this.container).direction === \"rtl\";\n    }\n\n    get isInPresentationMode() {\n      return this.presentationModeState === PresentationModeState.FULLSCREEN;\n    }\n\n    get isChangingPresentationMode() {\n      return this.presentationModeState === PresentationModeState.CHANGING;\n    }\n\n    get isHorizontalScrollbarEnabled() {\n      return this.isInPresentationMode\n        ? false\n        : this.container.scrollWidth > this.container.clientWidth;\n    }\n\n    get isVerticalScrollbarEnabled() {\n      return this.isInPresentationMode\n        ? false\n        : this.container.scrollHeight > this.container.clientHeight;\n    }\n\n    /**\n     * Helper method for `this._getVisiblePages`. Should only ever be used when\n     * the viewer can only display a single page at a time, for example in:\n     *  - `PDFSinglePageViewer`.\n     *  - `PDFViewer` with Presentation Mode active.\n     */\n    _getCurrentVisiblePage() {\n      if (!this.pagesCount) {\n        return { views: [] };\n      }\n      const pageView = this._pages[this._currentPageNumber - 1];\n      // NOTE: Compute the `x` and `y` properties of the current view,\n      // since `this._updateLocation` depends of them being available.\n      const element = pageView.div;\n\n      const view = {\n        id: pageView.id,\n        x: element.offsetLeft + element.clientLeft,\n        y: element.offsetTop + element.clientTop,\n        view: pageView,\n      };\n      return { first: view, last: view, views: [view] };\n    }\n\n    _getVisiblePages() {\n      return getVisibleElements({\n        scrollEl: this.container,\n        views: this._pages,\n        sortByVisibility: true,\n        horizontal: this._isScrollModeHorizontal,\n        rtl: this._isScrollModeHorizontal && this._isContainerRtl,\n      });\n    }\n\n    /**\n     * @param {number} pageNumber\n     */\n    isPageVisible(pageNumber) {\n      if (!this.pdfDocument) {\n        return false;\n      }\n      if (\n        !(\n          Number.isInteger(pageNumber) &&\n          pageNumber > 0 &&\n          pageNumber <= this.pagesCount\n        )\n      ) {\n        console.error(\n          `${this._name}.isPageVisible: \"${pageNumber}\" is not a valid page.`\n        );\n        return false;\n      }\n      return this._getVisiblePages().views.some(function (view) {\n        return view.id === pageNumber;\n      });\n    }\n\n    /**\n     * @param {number} pageNumber\n     */\n    isPageCached(pageNumber) {\n      if (!this.pdfDocument || !this._buffer) {\n        return false;\n      }\n      if (\n        !(\n          Number.isInteger(pageNumber) &&\n          pageNumber > 0 &&\n          pageNumber <= this.pagesCount\n        )\n      ) {\n        console.error(\n          `${this._name}.isPageCached: \"${pageNumber}\" is not a valid page.`\n        );\n        return false;\n      }\n      const pageView = this._pages[pageNumber - 1];\n      if (!pageView) {\n        return false;\n      }\n      return this._buffer.has(pageView);\n    }\n\n    cleanup() {\n      for (let i = 0, ii = this._pages.length; i < ii; i++) {\n        if (\n          this._pages[i] &&\n          this._pages[i].renderingState !== RenderingStates.FINISHED\n        ) {\n          this._pages[i].reset();\n        }\n      }\n    }\n\n    /**\n     * @private\n     */\n    _cancelRendering() {\n      for (let i = 0, ii = this._pages.length; i < ii; i++) {\n        if (this._pages[i]) {\n          this._pages[i].cancelRendering();\n        }\n      }\n    }\n\n    /**\n     * @param {PDFPageView} pageView\n     * @returns {Promise} Returns a promise containing a {PDFPageProxy} object.\n     * @private\n     */\n    _ensurePdfPageLoaded(pageView) {\n      if (pageView.pdfPage) {\n        return Promise.resolve(pageView.pdfPage);\n      }\n      if (this._pagesRequests.has(pageView)) {\n        return this._pagesRequests.get(pageView);\n      }\n      const promise = this.pdfDocument\n        .getPage(pageView.id)\n        .then(pdfPage => {\n          if (!pageView.pdfPage) {\n            pageView.setPdfPage(pdfPage);\n          }\n          this._pagesRequests.delete(pageView);\n          return pdfPage;\n        })\n        .catch(reason => {\n          console.error(\"Unable to get page for page view\", reason);\n          // Page error -- there is nothing that can be done.\n          this._pagesRequests.delete(pageView);\n        });\n      this._pagesRequests.set(pageView, promise);\n      return promise;\n    }\n\n    forceRendering(currentlyVisiblePages) {\n      const visiblePages = currentlyVisiblePages || this._getVisiblePages();\n      const scrollAhead = this._isScrollModeHorizontal\n        ? this.scroll.right\n        : this.scroll.down;\n      const pageView = this.renderingQueue.getHighestPriority(\n        visiblePages,\n        this._pages,\n        scrollAhead\n      );\n      if (pageView) {\n        this._ensurePdfPageLoaded(pageView).then(() => {\n          this.renderingQueue.renderView(pageView);\n        });\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * @param {HTMLDivElement} textLayerDiv\n     * @param {number} pageIndex\n     * @param {PageViewport} viewport\n     * @param {boolean} enhanceTextSelection\n     * @param {EventBus} eventBus\n     * @returns {TextLayerBuilder}\n     */\n    createTextLayerBuilder(\n      textLayerDiv,\n      pageIndex,\n      viewport,\n      enhanceTextSelection = false,\n      eventBus\n    ) {\n      return new TextLayerBuilder({\n        textLayerDiv,\n        eventBus,\n        pageIndex,\n        viewport,\n        findController: this.isInPresentationMode ? null : this.findController,\n        enhanceTextSelection: this.isInPresentationMode\n          ? false\n          : enhanceTextSelection,\n      });\n    }\n\n    /**\n     * @param {HTMLDivElement} pageDiv\n     * @param {PDFPage} pdfPage\n     * @param {AnnotationStorage} [annotationStorage] - Storage for annotation\n     *   data in forms.\n     * @param {string} [imageResourcesPath] - Path for image resources, mainly\n     *   for annotation icons. Include trailing slash.\n     * @param {boolean} renderInteractiveForms\n     * @param {IL10n} l10n\n     * @param {boolean} [enableScripting]\n     * @param {Promise<boolean>} [hasJSActionsPromise]\n     * @param {Object} [mouseState]\n     * @returns {AnnotationLayerBuilder}\n     */\n    createAnnotationLayerBuilder(\n      pageDiv,\n      pdfPage,\n      annotationStorage = null,\n      imageResourcesPath = \"\",\n      renderInteractiveForms = false,\n      l10n = NullL10n,\n      enableScripting = false,\n      hasJSActionsPromise = null,\n      mouseState = null\n    ) {\n      return new AnnotationLayerBuilder({\n        pageDiv,\n        pdfPage,\n        annotationStorage:\n          ///annotationStorage || this.pdfDocument?.annotationStorage, // lwf\n          annotationStorage || (this.pdfDocument && this.pdfDocument.annotationStorage),\n        imageResourcesPath,\n        renderInteractiveForms,\n        linkService: this.linkService,\n        downloadManager: this.downloadManager,\n        l10n,\n        enableScripting,\n        hasJSActionsPromise:\n          ///hasJSActionsPromise || this.pdfDocument?.hasJSActions(), // lwf\n          hasJSActionsPromise || (this.pdfDocument && this.pdfDocument.hasJSActions()),\n        mouseState: mouseState || this._mouseState,\n      });\n    }\n\n    /**\n     * @type {boolean} Whether all pages of the PDF document have identical\n     *   widths and heights.\n     */\n    get hasEqualPageSizes() {\n      const firstPageView = this._pages[0];\n      for (let i = 1, ii = this._pages.length; i < ii; ++i) {\n        const pageView = this._pages[i];\n        if (\n          pageView.width !== firstPageView.width ||\n          pageView.height !== firstPageView.height\n        ) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Returns sizes of the pages.\n     * @returns {Array} Array of objects with width/height/rotation fields.\n     */\n    getPagesOverview() {\n      const pagesOverview = this._pages.map(function (pageView) {\n        const viewport = pageView.pdfPage.getViewport({ scale: 1 });\n        return {\n          width: viewport.width,\n          height: viewport.height,\n          rotation: viewport.rotation,\n        };\n      });\n      if (!this.enablePrintAutoRotate) {\n        return pagesOverview;\n      }\n      return pagesOverview.map(function (size) {\n        if (isPortraitOrientation(size)) {\n          return size;\n        }\n        return {\n          width: size.height,\n          height: size.width,\n          rotation: (size.rotation + 90) % 360,\n        };\n      });\n    }\n\n    /**\n     * @type {Promise<OptionalContentConfig | null>}\n     */\n    get optionalContentConfigPromise() {\n      if (!this.pdfDocument) {\n        return Promise.resolve(null);\n      }\n      if (!this._optionalContentConfigPromise) {\n        // Prevent issues if the getter is accessed *before* the `onePageRendered`\n        // promise has resolved; won't (normally) happen in the default viewer.\n        return this.pdfDocument.getOptionalContentConfig();\n      }\n      return this._optionalContentConfigPromise;\n    }\n\n    /**\n     * @param {Promise<OptionalContentConfig>} promise - A promise that is\n     *   resolved with an {@link OptionalContentConfig} instance.\n     */\n    set optionalContentConfigPromise(promise) {\n      if (!(promise instanceof Promise)) {\n        throw new Error(`Invalid optionalContentConfigPromise: ${promise}`);\n      }\n      if (!this.pdfDocument) {\n        return;\n      }\n      if (!this._optionalContentConfigPromise) {\n        // Ignore the setter *before* the `onePageRendered` promise has resolved,\n        // since it'll be overwritten anyway; won't happen in the default viewer.\n        return;\n      }\n      this._optionalContentConfigPromise = promise;\n\n      for (const pageView of this._pages) {\n        pageView.update(pageView.scale, pageView.rotation, promise);\n      }\n      this.update();\n\n      this.eventBus.dispatch(\"optionalcontentconfigchanged\", {\n        source: this,\n        promise,\n      });\n    }\n\n    /**\n     * @type {number} One of the values in {ScrollMode}.\n     */\n    get scrollMode() {\n      return this._scrollMode;\n    }\n\n    /**\n     * @param {number} mode - The direction in which the document pages should be\n     *   laid out within the scrolling container.\n     *   The constants from {ScrollMode} should be used.\n     */\n    set scrollMode(mode) {\n      if (this._scrollMode === mode) {\n        return; // The Scroll mode didn't change.\n      }\n      if (!isValidScrollMode(mode)) {\n        throw new Error(`Invalid scroll mode: ${mode}`);\n      }\n      this._scrollMode = mode;\n      this.eventBus.dispatch(\"scrollmodechanged\", { source: this, mode });\n\n      this._updateScrollMode(/* pageNumber = */ this._currentPageNumber);\n    }\n\n    _updateScrollMode(pageNumber = null) {\n      const scrollMode = this._scrollMode,\n        viewer = this.viewer;\n\n      viewer.classList.toggle(\n        \"scrollHorizontal\",\n        scrollMode === ScrollMode.HORIZONTAL\n      );\n      viewer.classList.toggle(\"scrollWrapped\", scrollMode === ScrollMode.WRAPPED);\n\n      if (!this.pdfDocument || !pageNumber) {\n        return;\n      }\n      // Non-numeric scale values can be sensitive to the scroll orientation.\n      // Call this before re-scrolling to the current page, to ensure that any\n      // changes in scale don't move the current page.\n      if (this._currentScaleValue && isNaN(this._currentScaleValue)) {\n        this._setScale(this._currentScaleValue, true);\n      }\n      this._setCurrentPageNumber(pageNumber, /* resetCurrentPageView = */ true);\n      this.update();\n    }\n\n    /**\n     * @type {number} One of the values in {SpreadMode}.\n     */\n    get spreadMode() {\n      return this._spreadMode;\n    }\n\n    /**\n     * @param {number} mode - Group the pages in spreads, starting with odd- or\n     *   even-number pages (unless `SpreadMode.NONE` is used).\n     *   The constants from {SpreadMode} should be used.\n     */\n    set spreadMode(mode) {\n      if (this._spreadMode === mode) {\n        return; // The Spread mode didn't change.\n      }\n      if (!isValidSpreadMode(mode)) {\n        throw new Error(`Invalid spread mode: ${mode}`);\n      }\n      this._spreadMode = mode;\n      this.eventBus.dispatch(\"spreadmodechanged\", { source: this, mode });\n\n      this._updateSpreadMode(/* pageNumber = */ this._currentPageNumber);\n    }\n\n    _updateSpreadMode(pageNumber = null) {\n      if (!this.pdfDocument) {\n        return;\n      }\n      const viewer = this.viewer,\n        pages = this._pages;\n      // Temporarily remove all the pages from the DOM.\n      viewer.textContent = \"\";\n\n      if (this._spreadMode === SpreadMode.NONE) {\n        for (let i = 0, iMax = pages.length; i < iMax; ++i) {\n          viewer.appendChild(pages[i].div);\n        }\n      } else {\n        const parity = this._spreadMode - 1;\n        let spread = null;\n        for (let i = 0, iMax = pages.length; i < iMax; ++i) {\n          if (spread === null) {\n            spread = document.createElement(\"div\");\n            spread.className = \"spread\";\n            viewer.appendChild(spread);\n          } else if (i % 2 === parity) {\n            spread = spread.cloneNode(false);\n            viewer.appendChild(spread);\n          }\n          spread.appendChild(pages[i].div);\n        }\n      }\n\n      if (!pageNumber) {\n        return;\n      }\n      if (this._currentScaleValue && isNaN(this._currentScaleValue)) {\n        this._setScale(this._currentScaleValue, true);\n      }\n      this._setCurrentPageNumber(pageNumber, /* resetCurrentPageView = */ true);\n      this.update();\n    }\n\n    /**\n     * @private\n     */\n    _getPageAdvance(currentPageNumber, previous = false) {\n      if (this.isInPresentationMode) {\n        return 1;\n      }\n      switch (this._scrollMode) {\n        case ScrollMode.WRAPPED: {\n          const { views } = this._getVisiblePages(),\n            pageLayout = new Map();\n\n          // Determine the current (visible) page layout.\n          for (const { id, y, percent, widthPercent } of views) {\n            if (percent === 0 || widthPercent < 100) {\n              continue;\n            }\n            let yArray = pageLayout.get(y);\n            if (!yArray) {\n              ///pageLayout.set(y, (yArray ||= [])); // lwf\n              pageLayout.set(y, (yArray = []));\n            }\n            yArray.push(id);\n          }\n          // Find the row of the current page.\n          for (const yArray of pageLayout.values()) {\n            const currentIndex = yArray.indexOf(currentPageNumber);\n            if (currentIndex === -1) {\n              continue;\n            }\n            const numPages = yArray.length;\n            if (numPages === 1) {\n              break;\n            }\n            // Handle documents with varying page sizes.\n            if (previous) {\n              for (let i = currentIndex - 1, ii = 0; i >= ii; i--) {\n                const currentId = yArray[i],\n                  expectedId = yArray[i + 1] - 1;\n                if (currentId < expectedId) {\n                  return currentPageNumber - expectedId;\n                }\n              }\n            } else {\n              for (let i = currentIndex + 1, ii = numPages; i < ii; i++) {\n                const currentId = yArray[i],\n                  expectedId = yArray[i - 1] + 1;\n                if (currentId > expectedId) {\n                  return expectedId - currentPageNumber;\n                }\n              }\n            }\n            // The current row is \"complete\", advance to the previous/next one.\n            if (previous) {\n              const firstId = yArray[0];\n              if (firstId < currentPageNumber) {\n                return currentPageNumber - firstId + 1;\n              }\n            } else {\n              const lastId = yArray[numPages - 1];\n              if (lastId > currentPageNumber) {\n                return lastId - currentPageNumber + 1;\n              }\n            }\n            break;\n          }\n          break;\n        }\n        case ScrollMode.HORIZONTAL: {\n          break;\n        }\n        case ScrollMode.VERTICAL: {\n          if (this._spreadMode === SpreadMode.NONE) {\n            break; // Normal vertical scrolling.\n          }\n          const parity = this._spreadMode - 1;\n\n          if (previous && currentPageNumber % 2 !== parity) {\n            break; // Left-hand side page.\n          } else if (!previous && currentPageNumber % 2 === parity) {\n            break; // Right-hand side page.\n          }\n          const { views } = this._getVisiblePages(),\n            expectedId = previous ? currentPageNumber - 1 : currentPageNumber + 1;\n\n          for (const { id, percent, widthPercent } of views) {\n            if (id !== expectedId) {\n              continue;\n            }\n            if (percent > 0 && widthPercent === 100) {\n              return 2;\n            }\n            break;\n          }\n          break;\n        }\n      }\n      return 1;\n    }\n\n    /**\n     * Go to the next page, taking scroll/spread-modes into account.\n     * @returns {boolean} Whether navigation occured.\n     */\n    nextPage() {\n      const currentPageNumber = this._currentPageNumber,\n        pagesCount = this.pagesCount;\n\n      if (currentPageNumber >= pagesCount) {\n        return false;\n      }\n      const advance =\n        this._getPageAdvance(currentPageNumber, /* previous = */ false) || 1;\n\n      this.currentPageNumber = Math.min(currentPageNumber + advance, pagesCount);\n      return true;\n    }\n\n    /**\n     * Go to the previous page, taking scroll/spread-modes into account.\n     * @returns {boolean} Whether navigation occured.\n     */\n    previousPage() {\n      const currentPageNumber = this._currentPageNumber;\n\n      if (currentPageNumber <= 1) {\n        return false;\n      }\n      const advance =\n        this._getPageAdvance(currentPageNumber, /* previous = */ true) || 1;\n\n      this.currentPageNumber = Math.max(currentPageNumber - advance, 1);\n      return true;\n    }\n\n    initializeScriptingEvents() {\n      if (!this.enableScripting || this._pageOpenPendingSet) {\n        return;\n      }\n      const eventBus = this.eventBus,\n        pageOpenPendingSet = (this._pageOpenPendingSet = new Set()),\n        //scriptingEvents = (this._scriptingEvents ||= Object.create(null)); // lwf\n        scriptingEvents = (this._scriptingEvents || (this._scriptingEvents = Object.create(null)));\n\n      const dispatchPageClose = pageNumber => {\n        if (pageOpenPendingSet.has(pageNumber)) {\n          return; // No \"pageopen\" event was dispatched for the previous page.\n        }\n        eventBus.dispatch(\"pageclose\", { source: this, pageNumber });\n      };\n      const dispatchPageOpen = pageNumber => {\n        const pageView = this._pages[pageNumber - 1];\n        //if (pageView?.renderingState === RenderingStates.FINISHED) { // lwf\n        if (pageView && pageView.renderingState === RenderingStates.FINISHED) {\n          pageOpenPendingSet.delete(pageNumber);\n\n          eventBus.dispatch(\"pageopen\", {\n            source: this,\n            pageNumber,\n            ///actionsPromise: pageView.pdfPage?.getJSActions(),// lwf\n            actionsPromise: pageView.pdfPage && pageView.pdfPage.getJSActions(),\n          });\n        } else {\n          pageOpenPendingSet.add(pageNumber);\n        }\n      };\n\n      scriptingEvents.onPageChanging = ({ pageNumber, previous }) => {\n        if (pageNumber === previous) {\n          return; // The active page didn't change.\n        }\n        dispatchPageClose(previous);\n        dispatchPageOpen(pageNumber);\n      };\n      eventBus._on(\"pagechanging\", scriptingEvents.onPageChanging);\n\n      scriptingEvents.onPageRendered = ({ pageNumber }) => {\n        if (!pageOpenPendingSet.has(pageNumber)) {\n          return; // No pending \"pageopen\" event for the newly rendered page.\n        }\n        if (pageNumber !== this._currentPageNumber) {\n          return; // The newly rendered page is no longer the current one.\n        }\n        dispatchPageOpen(pageNumber);\n      };\n      eventBus._on(\"pagerendered\", scriptingEvents.onPageRendered);\n\n      scriptingEvents.onPagesDestroy = () => {\n        dispatchPageClose(this._currentPageNumber);\n      };\n      eventBus._on(\"pagesdestroy\", scriptingEvents.onPagesDestroy);\n\n      // Ensure that a \"pageopen\" event is dispatched for the initial page.\n      dispatchPageOpen(this._currentPageNumber);\n    }\n\n    /**\n     * @private\n     */\n    _resetScriptingEvents() {\n      if (!this.enableScripting || !this._pageOpenPendingSet) {\n        return;\n      }\n      const eventBus = this.eventBus,\n        scriptingEvents = this._scriptingEvents;\n\n      // Remove the event listeners.\n      eventBus._off(\"pagechanging\", scriptingEvents.onPageChanging);\n      scriptingEvents.onPageChanging = null;\n\n      eventBus._off(\"pagerendered\", scriptingEvents.onPageRendered);\n      scriptingEvents.onPageRendered = null;\n\n      eventBus._off(\"pagesdestroy\", scriptingEvents.onPagesDestroy);\n      scriptingEvents.onPagesDestroy = null;\n\n      this._pageOpenPendingSet = null;\n    }\n  }\n\n  return { BaseViewer };\n});\ndefine('skylark-pdfjs-viewer/pdf_viewer',[\n  \"skylark-pdfjs-display\",\n  \"./ui_utils\",\n  \"./base_viewer\"\n],function(pdfjsLib,ui_utils,base_viewer){\n  /* Copyright 2014 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { ScrollMode, SpreadMode } = ui_utils;\n  const { BaseViewer } = base_viewer;\n  const { shadow } = pdfjsLib;\n\n  class PDFViewer extends BaseViewer {\n    get _viewerElement() {\n      return shadow(this, \"_viewerElement\", this.viewer);\n    }\n\n    _scrollIntoView({ pageDiv, pageSpot = null, pageNumber = null }) {\n      if (!pageSpot && !this.isInPresentationMode) {\n        const left = pageDiv.offsetLeft + pageDiv.clientLeft;\n        const right = left + pageDiv.clientWidth;\n        const { scrollLeft, clientWidth } = this.container;\n        if (\n          this._isScrollModeHorizontal ||\n          left < scrollLeft ||\n          right > scrollLeft + clientWidth\n        ) {\n          pageSpot = { left: 0, top: 0 };\n        }\n      }\n      super._scrollIntoView({ pageDiv, pageSpot, pageNumber });\n    }\n\n    _getVisiblePages() {\n      if (this.isInPresentationMode) {\n        // The algorithm in `getVisibleElements` doesn't work in all browsers and\n        // configurations (e.g. Chrome) when Presentation Mode is active.\n        return this._getCurrentVisiblePage();\n      }\n      return super._getVisiblePages();\n    }\n\n    _updateHelper(visiblePages) {\n      if (this.isInPresentationMode) {\n        return;\n      }\n      let currentId = this._currentPageNumber;\n      let stillFullyVisible = false;\n\n      for (const page of visiblePages) {\n        if (page.percent < 100) {\n          break;\n        }\n        if (\n          page.id === currentId &&\n          this._scrollMode === ScrollMode.VERTICAL &&\n          this._spreadMode === SpreadMode.NONE\n        ) {\n          stillFullyVisible = true;\n          break;\n        }\n      }\n      if (!stillFullyVisible) {\n        currentId = visiblePages[0].id;\n      }\n      this._setCurrentPageNumber(currentId);\n    }\n  }\n\n  return { PDFViewer };\n});\ndefine('skylark-pdfjs-viewer/pdf_single_page_viewer',[\n  \"skylark-pdfjs-display\",\n  \"./base_viewer\"\n],function(pdfjsLib,base_viewer){\n  /* Copyright 2017 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { BaseViewer } = base_viewer;\n  const { shadow } = pdfjsLib;\n\n  class PDFSinglePageViewer extends BaseViewer {\n    constructor(options) {\n      super(options);\n\n      this.eventBus._on(\"pagesinit\", evt => {\n        // Since the pages are placed in a `DocumentFragment`, make sure that\n        // the current page becomes visible upon loading of the document.\n        this._ensurePageViewVisible();\n      });\n    }\n\n    get _viewerElement() {\n      // Since we only want to display *one* page at a time when using the\n      // `PDFSinglePageViewer`, we cannot append them to the `viewer` DOM element.\n      // Instead, they are placed in a `DocumentFragment`, and only the current\n      // page is displayed in the viewer (refer to `this._ensurePageViewVisible`).\n      return shadow(this, \"_viewerElement\", this._shadowViewer);\n    }\n\n    get _pageWidthScaleFactor() {\n      return 1;\n    }\n\n    _resetView() {\n      super._resetView();\n      this._previousPageNumber = 1;\n      this._shadowViewer = document.createDocumentFragment();\n      this._updateScrollDown = null;\n    }\n\n    _ensurePageViewVisible() {\n      const pageView = this._pages[this._currentPageNumber - 1];\n      const previousPageView = this._pages[this._previousPageNumber - 1];\n\n      const viewerNodes = this.viewer.childNodes;\n      switch (viewerNodes.length) {\n        case 0: // Should *only* occur on initial loading.\n          this.viewer.appendChild(pageView.div);\n          break;\n        case 1: // The normal page-switching case.\n          if (viewerNodes[0] !== previousPageView.div) {\n            throw new Error(\n              \"_ensurePageViewVisible: Unexpected previously visible page.\"\n            );\n          }\n          if (pageView === previousPageView) {\n            break; // The correct page is already visible.\n          }\n          // Switch visible pages, and reset the viewerContainer scroll position.\n          this._shadowViewer.appendChild(previousPageView.div);\n          this.viewer.appendChild(pageView.div);\n\n          this.container.scrollTop = 0;\n          break;\n        default:\n          throw new Error(\n            \"_ensurePageViewVisible: Only one page should be visible at a time.\"\n          );\n      }\n      this._previousPageNumber = this._currentPageNumber;\n    }\n\n    _scrollUpdate() {\n      if (this._updateScrollDown) {\n        this._updateScrollDown();\n      }\n      super._scrollUpdate();\n    }\n\n    _scrollIntoView({ pageDiv, pageSpot = null, pageNumber = null }) {\n      if (pageNumber) {\n        // Ensure that `this._currentPageNumber` is correct.\n        this._setCurrentPageNumber(pageNumber);\n      }\n      const scrolledDown = this._currentPageNumber >= this._previousPageNumber;\n\n      this._ensurePageViewVisible();\n      // Ensure that rendering always occurs, to avoid showing a blank page,\n      // even if the current position doesn't change when the page is scrolled.\n      this.update();\n\n      super._scrollIntoView({ pageDiv, pageSpot, pageNumber });\n\n      // Since scrolling is tracked using `requestAnimationFrame`, update the\n      // scroll direction during the next `this._scrollUpdate` invocation.\n      this._updateScrollDown = () => {\n        this.scroll.down = scrolledDown;\n        this._updateScrollDown = null;\n      };\n    }\n\n    _getVisiblePages() {\n      return this._getCurrentVisiblePage();\n    }\n\n    _updateHelper(visiblePages) {}\n\n    get _isScrollModeHorizontal() {\n      // The Scroll/Spread modes are never used in `PDFSinglePageViewer`.\n      return shadow(this, \"_isScrollModeHorizontal\", false);\n    }\n\n    _updateScrollMode() {}\n\n    _updateSpreadMode() {}\n\n    _getPageAdvance() {\n      return 1;\n    }\n  }\n\n  return { PDFSinglePageViewer };\n});\ndefine('skylark-pdfjs-viewer/secondary_toolbar',[\n  \"./ui_utils\",\n  \"./pdf_cursor_tools\",\n  \"./pdf_single_page_viewer\"\n],function(ui_utils,pdf_cursor_tools,pdf_single_page_viewer){\n  /* Copyright 2012 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { SCROLLBAR_PADDING, ScrollMode, SpreadMode } = ui_utils;\n  const { CursorTool } = pdf_cursor_tools;\n  const { PDFSinglePageViewer } = pdf_single_page_viewer;\n\n  /**\n   * @typedef {Object} SecondaryToolbarOptions\n   * @property {HTMLDivElement} toolbar - Container for the secondary toolbar.\n   * @property {HTMLButtonElement} toggleButton - Button to toggle the visibility\n   *   of the secondary toolbar.\n   * @property {HTMLDivElement} toolbarButtonContainer - Container where all the\n   *   toolbar buttons are placed. The maximum height of the toolbar is controlled\n   *   dynamically by adjusting the 'max-height' CSS property of this DOM element.\n   * @property {HTMLButtonElement} presentationModeButton - Button for entering\n   *   presentation mode.\n   * @property {HTMLButtonElement} openFileButton - Button to open a file.\n   * @property {HTMLButtonElement} printButton - Button to print the document.\n   * @property {HTMLButtonElement} downloadButton - Button to download the\n   *   document.\n   * @property {HTMLLinkElement} viewBookmarkButton - Button to obtain a bookmark\n   *   link to the current location in the document.\n   * @property {HTMLButtonElement} firstPageButton - Button to go to the first\n   *   page in the document.\n   * @property {HTMLButtonElement} lastPageButton - Button to go to the last page\n   *   in the document.\n   * @property {HTMLButtonElement} pageRotateCwButton - Button to rotate the pages\n   *   clockwise.\n   * @property {HTMLButtonElement} pageRotateCcwButton - Button to rotate the\n   *   pages counterclockwise.\n   * @property {HTMLButtonElement} cursorSelectToolButton - Button to enable the\n   *   select tool.\n   * @property {HTMLButtonElement} cursorHandToolButton - Button to enable the\n   *   hand tool.\n   * @property {HTMLButtonElement} documentPropertiesButton - Button for opening\n   *   the document properties dialog.\n   */\n\n  class SecondaryToolbar {\n    /**\n     * @param {SecondaryToolbarOptions} options\n     * @param {HTMLDivElement} mainContainer\n     * @param {EventBus} eventBus\n     */\n    constructor(options, mainContainer, eventBus) {\n      this.toolbar = options.toolbar;\n      this.toggleButton = options.toggleButton;\n      this.toolbarButtonContainer = options.toolbarButtonContainer;\n      this.buttons = [\n        {\n          element: options.presentationModeButton,\n          eventName: \"presentationmode\",\n          close: true,\n        },\n        { element: options.openFileButton, eventName: \"openfile\", close: true },\n        { element: options.printButton, eventName: \"print\", close: true },\n        { element: options.downloadButton, eventName: \"download\", close: true },\n        { element: options.viewBookmarkButton, eventName: null, close: true },\n        { element: options.firstPageButton, eventName: \"firstpage\", close: true },\n        { element: options.lastPageButton, eventName: \"lastpage\", close: true },\n        {\n          element: options.pageRotateCwButton,\n          eventName: \"rotatecw\",\n          close: false,\n        },\n        {\n          element: options.pageRotateCcwButton,\n          eventName: \"rotateccw\",\n          close: false,\n        },\n        {\n          element: options.cursorSelectToolButton,\n          eventName: \"switchcursortool\",\n          eventDetails: { tool: CursorTool.SELECT },\n          close: true,\n        },\n        {\n          element: options.cursorHandToolButton,\n          eventName: \"switchcursortool\",\n          eventDetails: { tool: CursorTool.HAND },\n          close: true,\n        },\n        {\n          element: options.scrollVerticalButton,\n          eventName: \"switchscrollmode\",\n          eventDetails: { mode: ScrollMode.VERTICAL },\n          close: true,\n        },\n        {\n          element: options.scrollHorizontalButton,\n          eventName: \"switchscrollmode\",\n          eventDetails: { mode: ScrollMode.HORIZONTAL },\n          close: true,\n        },\n        {\n          element: options.scrollWrappedButton,\n          eventName: \"switchscrollmode\",\n          eventDetails: { mode: ScrollMode.WRAPPED },\n          close: true,\n        },\n        {\n          element: options.spreadNoneButton,\n          eventName: \"switchspreadmode\",\n          eventDetails: { mode: SpreadMode.NONE },\n          close: true,\n        },\n        {\n          element: options.spreadOddButton,\n          eventName: \"switchspreadmode\",\n          eventDetails: { mode: SpreadMode.ODD },\n          close: true,\n        },\n        {\n          element: options.spreadEvenButton,\n          eventName: \"switchspreadmode\",\n          eventDetails: { mode: SpreadMode.EVEN },\n          close: true,\n        },\n        {\n          element: options.documentPropertiesButton,\n          eventName: \"documentproperties\",\n          close: true,\n        },\n      ];\n      this.items = {\n        firstPage: options.firstPageButton,\n        lastPage: options.lastPageButton,\n        pageRotateCw: options.pageRotateCwButton,\n        pageRotateCcw: options.pageRotateCcwButton,\n      };\n\n      this.mainContainer = mainContainer;\n      this.eventBus = eventBus;\n\n      this.opened = false;\n      this.containerHeight = null;\n      this.previousContainerHeight = null;\n\n      this.reset();\n\n      // Bind the event listeners for click, cursor tool, and scroll/spread mode\n      // actions.\n      this._bindClickListeners();\n      this._bindCursorToolsListener(options);\n      this._bindScrollModeListener(options);\n      this._bindSpreadModeListener(options);\n\n      // Bind the event listener for adjusting the 'max-height' of the toolbar.\n      this.eventBus._on(\"resize\", this._setMaxHeight.bind(this));\n\n      // Hide the Scroll/Spread mode buttons, when they're not applicable to the\n      // current `BaseViewer` instance (in particular `PDFSinglePageViewer`).\n      this.eventBus._on(\"baseviewerinit\", evt => {\n        if (evt.source instanceof PDFSinglePageViewer) {\n          this.toolbarButtonContainer.classList.add(\n            \"hiddenScrollModeButtons\",\n            \"hiddenSpreadModeButtons\"\n          );\n        } else {\n          this.toolbarButtonContainer.classList.remove(\n            \"hiddenScrollModeButtons\",\n            \"hiddenSpreadModeButtons\"\n          );\n        }\n      });\n    }\n\n    /**\n     * @type {boolean}\n     */\n    get isOpen() {\n      return this.opened;\n    }\n\n    setPageNumber(pageNumber) {\n      this.pageNumber = pageNumber;\n      this._updateUIState();\n    }\n\n    setPagesCount(pagesCount) {\n      this.pagesCount = pagesCount;\n      this._updateUIState();\n    }\n\n    reset() {\n      this.pageNumber = 0;\n      this.pagesCount = 0;\n      this._updateUIState();\n\n      // Reset the Scroll/Spread buttons too, since they're document specific.\n      this.eventBus.dispatch(\"secondarytoolbarreset\", { source: this });\n    }\n\n    _updateUIState() {\n      this.items.firstPage.disabled = this.pageNumber <= 1;\n      this.items.lastPage.disabled = this.pageNumber >= this.pagesCount;\n      this.items.pageRotateCw.disabled = this.pagesCount === 0;\n      this.items.pageRotateCcw.disabled = this.pagesCount === 0;\n    }\n\n    _bindClickListeners() {\n      // Button to toggle the visibility of the secondary toolbar.\n      this.toggleButton.addEventListener(\"click\", this.toggle.bind(this));\n\n      // All items within the secondary toolbar.\n      for (const { element, eventName, close, eventDetails } of this.buttons) {\n        element.addEventListener(\"click\", evt => {\n          if (eventName !== null) {\n            const details = { source: this };\n            for (const property in eventDetails) {\n              details[property] = eventDetails[property];\n            }\n            this.eventBus.dispatch(eventName, details);\n          }\n          if (close) {\n            this.close();\n          }\n        });\n      }\n    }\n\n    _bindCursorToolsListener(buttons) {\n      this.eventBus._on(\"cursortoolchanged\", function ({ tool }) {\n        buttons.cursorSelectToolButton.classList.toggle(\n          \"toggled\",\n          tool === CursorTool.SELECT\n        );\n        buttons.cursorHandToolButton.classList.toggle(\n          \"toggled\",\n          tool === CursorTool.HAND\n        );\n      });\n    }\n\n    _bindScrollModeListener(buttons) {\n      function scrollModeChanged({ mode }) {\n        buttons.scrollVerticalButton.classList.toggle(\n          \"toggled\",\n          mode === ScrollMode.VERTICAL\n        );\n        buttons.scrollHorizontalButton.classList.toggle(\n          \"toggled\",\n          mode === ScrollMode.HORIZONTAL\n        );\n        buttons.scrollWrappedButton.classList.toggle(\n          \"toggled\",\n          mode === ScrollMode.WRAPPED\n        );\n\n        // Temporarily *disable* the Spread buttons when horizontal scrolling is\n        // enabled, since the non-default Spread modes doesn't affect the layout.\n        const isScrollModeHorizontal = mode === ScrollMode.HORIZONTAL;\n        buttons.spreadNoneButton.disabled = isScrollModeHorizontal;\n        buttons.spreadOddButton.disabled = isScrollModeHorizontal;\n        buttons.spreadEvenButton.disabled = isScrollModeHorizontal;\n      }\n      this.eventBus._on(\"scrollmodechanged\", scrollModeChanged);\n\n      this.eventBus._on(\"secondarytoolbarreset\", evt => {\n        if (evt.source === this) {\n          scrollModeChanged({ mode: ScrollMode.VERTICAL });\n        }\n      });\n    }\n\n    _bindSpreadModeListener(buttons) {\n      function spreadModeChanged({ mode }) {\n        buttons.spreadNoneButton.classList.toggle(\n          \"toggled\",\n          mode === SpreadMode.NONE\n        );\n        buttons.spreadOddButton.classList.toggle(\n          \"toggled\",\n          mode === SpreadMode.ODD\n        );\n        buttons.spreadEvenButton.classList.toggle(\n          \"toggled\",\n          mode === SpreadMode.EVEN\n        );\n      }\n      this.eventBus._on(\"spreadmodechanged\", spreadModeChanged);\n\n      this.eventBus._on(\"secondarytoolbarreset\", evt => {\n        if (evt.source === this) {\n          spreadModeChanged({ mode: SpreadMode.NONE });\n        }\n      });\n    }\n\n    open() {\n      if (this.opened) {\n        return;\n      }\n      this.opened = true;\n      this._setMaxHeight();\n\n      this.toggleButton.classList.add(\"toggled\");\n      this.toolbar.classList.remove(\"hidden\");\n    }\n\n    close() {\n      if (!this.opened) {\n        return;\n      }\n      this.opened = false;\n      this.toolbar.classList.add(\"hidden\");\n      this.toggleButton.classList.remove(\"toggled\");\n    }\n\n    toggle() {\n      if (this.opened) {\n        this.close();\n      } else {\n        this.open();\n      }\n    }\n\n    /**\n     * @private\n     */\n    _setMaxHeight() {\n      if (!this.opened) {\n        return; // Only adjust the 'max-height' if the toolbar is visible.\n      }\n      this.containerHeight = this.mainContainer.clientHeight;\n\n      if (this.containerHeight === this.previousContainerHeight) {\n        return;\n      }\n      this.toolbarButtonContainer.style.maxHeight = `${\n        this.containerHeight - SCROLLBAR_PADDING\n      }px`;\n\n      this.previousContainerHeight = this.containerHeight;\n    }\n  }\n\n  return { SecondaryToolbar };\n});\ndefine('skylark-pdfjs-viewer/toolbar',[\n  \"./pdfjs_dev\",\n  \"./ui_utils\"\n],function(PDFJSDev, ui_utils){\n  /* Copyright 2016 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const {\n    animationStarted,\n    DEFAULT_SCALE,\n    DEFAULT_SCALE_VALUE,\n    MAX_SCALE,\n    MIN_SCALE,\n    noContextMenuHandler,\n    NullL10n,\n  } = ui_utils;\n\n  const PAGE_NUMBER_LOADING_INDICATOR = \"visiblePageIsLoading\";\n  // Keep the two values below up-to-date with the values in `web/viewer.css`:\n  const SCALE_SELECT_CONTAINER_WIDTH = 140; // px\n  const SCALE_SELECT_WIDTH = 162; // px\n\n  /**\n   * @typedef {Object} ToolbarOptions\n   * @property {HTMLDivElement} container - Container for the secondary toolbar.\n   * @property {HTMLSpanElement} numPages - Label that contains number of pages.\n   * @property {HTMLInputElement} pageNumber - Control for display and user input\n   *   of the current page number.\n   * @property {HTMLSpanElement} scaleSelectContainer - Container where scale\n   *   controls are placed. The width is adjusted on UI initialization.\n   * @property {HTMLSelectElement} scaleSelect - Scale selection control.\n   * @property {HTMLOptionElement} customScaleOption - The item used to display\n   *   a non-predefined scale.\n   * @property {HTMLButtonElement} previous - Button to go to the previous page.\n   * @property {HTMLButtonElement} next - Button to go to the next page.\n   * @property {HTMLButtonElement} zoomIn - Button to zoom in the pages.\n   * @property {HTMLButtonElement} zoomOut - Button to zoom out the pages.\n   * @property {HTMLButtonElement} viewFind - Button to open find bar.\n   * @property {HTMLButtonElement} openFile - Button to open a new document.\n   * @property {HTMLButtonElement} presentationModeButton - Button to switch to\n   *   presentation mode.\n   * @property {HTMLButtonElement} download - Button to download the document.\n   * @property {HTMLAElement} viewBookmark - Element to link current url of\n   *   the page view.\n   */\n\n  class Toolbar {\n    /**\n     * @param {ToolbarOptions} options\n     * @param {EventBus} eventBus\n     * @param {IL10n} l10n - Localization service.\n     */\n    constructor(options, eventBus, l10n = NullL10n) {\n      this.toolbar = options.container;\n      this.eventBus = eventBus;\n      this.l10n = l10n;\n      this.buttons = [\n        { element: options.previous, eventName: \"previouspage\" },\n        { element: options.next, eventName: \"nextpage\" },\n        { element: options.zoomIn, eventName: \"zoomin\" },\n        { element: options.zoomOut, eventName: \"zoomout\" },\n        { element: options.openFile, eventName: \"openfile\" },\n        { element: options.print, eventName: \"print\" },\n        {\n          element: options.presentationModeButton,\n          eventName: \"presentationmode\",\n        },\n        { element: options.download, eventName: \"download\" },\n        { element: options.viewBookmark, eventName: null },\n      ];\n      this.items = {\n        numPages: options.numPages,\n        pageNumber: options.pageNumber,\n        scaleSelectContainer: options.scaleSelectContainer,\n        scaleSelect: options.scaleSelect,\n        customScaleOption: options.customScaleOption,\n        previous: options.previous,\n        next: options.next,\n        zoomIn: options.zoomIn,\n        zoomOut: options.zoomOut,\n      };\n\n      this._wasLocalized = false;\n      this.reset();\n\n      // Bind the event listeners for click and various other actions.\n      this._bindListeners();\n    }\n\n    setPageNumber(pageNumber, pageLabel) {\n      this.pageNumber = pageNumber;\n      this.pageLabel = pageLabel;\n      this._updateUIState(false);\n    }\n\n    setPagesCount(pagesCount, hasPageLabels) {\n      this.pagesCount = pagesCount;\n      this.hasPageLabels = hasPageLabels;\n      this._updateUIState(true);\n    }\n\n    setPageScale(pageScaleValue, pageScale) {\n      this.pageScaleValue = (pageScaleValue || pageScale).toString();\n      this.pageScale = pageScale;\n      this._updateUIState(false);\n    }\n\n    reset() {\n      this.pageNumber = 0;\n      this.pageLabel = null;\n      this.hasPageLabels = false;\n      this.pagesCount = 0;\n      this.pageScaleValue = DEFAULT_SCALE_VALUE;\n      this.pageScale = DEFAULT_SCALE;\n      this._updateUIState(true);\n      this.updateLoadingIndicatorState();\n    }\n\n    _bindListeners() {\n      const { pageNumber, scaleSelect } = this.items;\n      const self = this;\n\n      // The buttons within the toolbar.\n      for (const { element, eventName } of this.buttons) {\n        element.addEventListener(\"click\", evt => {\n          if (eventName !== null) {\n            this.eventBus.dispatch(eventName, { source: this });\n          }\n        });\n      }\n      // The non-button elements within the toolbar.\n      pageNumber.addEventListener(\"click\", function () {\n        this.select();\n      });\n      pageNumber.addEventListener(\"change\", function () {\n        self.eventBus.dispatch(\"pagenumberchanged\", {\n          source: self,\n          value: this.value,\n        });\n      });\n\n      scaleSelect.addEventListener(\"change\", function () {\n        if (this.value === \"custom\") {\n          return;\n        }\n        self.eventBus.dispatch(\"scalechanged\", {\n          source: self,\n          value: this.value,\n        });\n      });\n      // Suppress context menus for some controls.\n      scaleSelect.oncontextmenu = noContextMenuHandler;\n\n      this.eventBus._on(\"localized\", () => {\n        this._wasLocalized = true;\n        this._adjustScaleWidth();\n        this._updateUIState(true);\n      });\n    }\n\n    _updateUIState(resetNumPages = false) {\n      if (!this._wasLocalized) {\n        // Don't update the UI state until we localize the toolbar.\n        return;\n      }\n      const { pageNumber, pagesCount, pageScaleValue, pageScale, items } = this;\n\n      if (resetNumPages) {\n        if (this.hasPageLabels) {\n          items.pageNumber.type = \"text\";\n        } else {\n          items.pageNumber.type = \"number\";\n          this.l10n\n            .get(\"of_pages\", { pagesCount }, \"of {{pagesCount}}\")\n            .then(msg => {\n              items.numPages.textContent = msg;\n            });\n        }\n        items.pageNumber.max = pagesCount;\n      }\n\n      if (this.hasPageLabels) {\n        items.pageNumber.value = this.pageLabel;\n        this.l10n\n          .get(\n            \"page_of_pages\",\n            { pageNumber, pagesCount },\n            \"({{pageNumber}} of {{pagesCount}})\"\n          )\n          .then(msg => {\n            items.numPages.textContent = msg;\n          });\n      } else {\n        items.pageNumber.value = pageNumber;\n      }\n\n      items.previous.disabled = pageNumber <= 1;\n      items.next.disabled = pageNumber >= pagesCount;\n\n      items.zoomOut.disabled = pageScale <= MIN_SCALE;\n      items.zoomIn.disabled = pageScale >= MAX_SCALE;\n\n      const customScale = Math.round(pageScale * 10000) / 100;\n      this.l10n\n        .get(\"page_scale_percent\", { scale: customScale }, \"{{scale}}%\")\n        .then(msg => {\n          let predefinedValueFound = false;\n          for (const option of items.scaleSelect.options) {\n            if (option.value !== pageScaleValue) {\n              option.selected = false;\n              continue;\n            }\n            option.selected = true;\n            predefinedValueFound = true;\n          }\n          if (!predefinedValueFound) {\n            items.customScaleOption.textContent = msg;\n            items.customScaleOption.selected = true;\n          }\n        });\n    }\n\n    updateLoadingIndicatorState(loading = false) {\n      const pageNumberInput = this.items.pageNumber;\n\n      pageNumberInput.classList.toggle(PAGE_NUMBER_LOADING_INDICATOR, loading);\n    }\n\n    /**\n     * Increase the width of the zoom dropdown DOM element if, and only if, it's\n     * too narrow to fit the *longest* of the localized strings.\n     * @private\n     */\n    async _adjustScaleWidth() {\n      const { items, l10n } = this;\n\n      const predefinedValuesPromise = Promise.all([\n        l10n.get(\"page_scale_auto\", null, \"Automatic Zoom\"),\n        l10n.get(\"page_scale_actual\", null, \"Actual Size\"),\n        l10n.get(\"page_scale_fit\", null, \"Page Fit\"),\n        l10n.get(\"page_scale_width\", null, \"Page Width\"),\n      ]);\n\n      // The temporary canvas is used to measure text length in the DOM.\n      let canvas = document.createElement(\"canvas\");\n      if (\n        typeof PDFJSDev === \"undefined\" ||\n        PDFJSDev.test(\"MOZCENTRAL || GENERIC\")\n      ) {\n        canvas.mozOpaque = true;\n      }\n      let ctx = canvas.getContext(\"2d\", { alpha: false });\n\n      await animationStarted;\n      const { fontSize, fontFamily } = getComputedStyle(items.scaleSelect);\n      ctx.font = `${fontSize} ${fontFamily}`;\n\n      let maxWidth = 0;\n      for (const predefinedValue of await predefinedValuesPromise) {\n        const { width } = ctx.measureText(predefinedValue);\n        if (width > maxWidth) {\n          maxWidth = width;\n        }\n      }\n      const overflow = SCALE_SELECT_WIDTH - SCALE_SELECT_CONTAINER_WIDTH;\n      maxWidth += 2 * overflow;\n\n      if (maxWidth > SCALE_SELECT_CONTAINER_WIDTH) {\n        items.scaleSelect.style.width = `${maxWidth + overflow}px`;\n        items.scaleSelectContainer.style.width = `${maxWidth}px`;\n      }\n      // Zeroing the width and height cause Firefox to release graphics resources\n      // immediately, which can greatly reduce memory consumption.\n      canvas.width = 0;\n      canvas.height = 0;\n      canvas = ctx = null;\n    }\n  }\n\n  return { Toolbar };\n});\ndefine('skylark-pdfjs-viewer/view_history',[\n  \"./pdfjs_dev\"\n],function(PDFJSDev){\n  /* Copyright 2012 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const DEFAULT_VIEW_HISTORY_CACHE_SIZE = 20;\n\n  /**\n   * View History - This is a utility for saving various view parameters for\n   *                recently opened files.\n   *\n   * The way that the view parameters are stored depends on how PDF.js is built,\n   * for 'gulp <flag>' the following cases exist:\n   *  - MOZCENTRAL        - uses sessionStorage.\n   *  - GENERIC or CHROME - uses localStorage, if it is available.\n   */\n  class ViewHistory {\n    constructor(fingerprint, cacheSize = DEFAULT_VIEW_HISTORY_CACHE_SIZE) {\n      this.fingerprint = fingerprint;\n      this.cacheSize = cacheSize;\n\n      this._initializedPromise = this._readFromStorage().then(databaseStr => {\n        const database = JSON.parse(databaseStr || \"{}\");\n        let index = -1;\n        if (!Array.isArray(database.files)) {\n          database.files = [];\n        } else {\n          while (database.files.length >= this.cacheSize) {\n            database.files.shift();\n          }\n\n          for (let i = 0, ii = database.files.length; i < ii; i++) {\n            const branch = database.files[i];\n            if (branch.fingerprint === this.fingerprint) {\n              index = i;\n              break;\n            }\n          }\n        }\n        if (index === -1) {\n          index = database.files.push({ fingerprint: this.fingerprint }) - 1;\n        }\n        this.file = database.files[index];\n        this.database = database;\n      });\n    }\n\n    async _writeToStorage() {\n      const databaseStr = JSON.stringify(this.database);\n\n      if (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"MOZCENTRAL\")) {\n        sessionStorage.setItem(\"pdfjs.history\", databaseStr);\n        return;\n      }\n      localStorage.setItem(\"pdfjs.history\", databaseStr);\n    }\n\n    async _readFromStorage() {\n      if (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"MOZCENTRAL\")) {\n        return sessionStorage.getItem(\"pdfjs.history\");\n      }\n      return localStorage.getItem(\"pdfjs.history\");\n    }\n\n    async set(name, val) {\n      await this._initializedPromise;\n      this.file[name] = val;\n      return this._writeToStorage();\n    }\n\n    async setMultiple(properties) {\n      await this._initializedPromise;\n      for (const name in properties) {\n        this.file[name] = properties[name];\n      }\n      return this._writeToStorage();\n    }\n\n    async get(name, defaultValue) {\n      await this._initializedPromise;\n      const val = this.file[name];\n      return val !== undefined ? val : defaultValue;\n    }\n\n    async getMultiple(properties) {\n      await this._initializedPromise;\n      const values = Object.create(null);\n\n      for (const name in properties) {\n        const val = this.file[name];\n        values[name] = val !== undefined ? val : properties[name];\n      }\n      return values;\n    }\n  }\n\n  return { ViewHistory };\n});\ndefine('skylark-pdfjs-viewer/app',[\n  \"skylark-pdfjs-display\",\n  \"./pdfjs_dev\",\n\n  \"./ui_utils\",\n  \"./app_options\",\n\n  \"./pdf_cursor_tools\",\n  \"./pdf_rendering_queue\",\n  \"./overlay_manager\",\n  \"./password_prompt\",\n  \"./pdf_attachment_viewer\",\n  \"./pdf_document_properties\",\n  \"./pdf_find_bar\",\n  \"./pdf_find_controller\",\n  \"./pdf_history\",\n  \"./pdf_layer_viewer\",\n  \"./pdf_link_service\",\n  \"./pdf_outline_viewer\",\n  \"./pdf_presentation_mode\",\n  \"./pdf_sidebar\",\n  \"./pdf_sidebar_resizer\",\n  \"./pdf_thumbnail_viewer\",\n  \"./pdf_viewer\",\n  \"./secondary_toolbar\",\n  \"./toolbar\",\n  \"./viewer_compatibility\",\n  \"./view_history\"\n\n],function(\n  pdfjsLib,\n  PDFJSDev,\n\n  ui_utils,\n  app_options,\n\n  pdf_cursor_tools,\n  pdf_rendering_queue,\n  overlay_manager,\n  password_prompt,\n  pdf_attachment_viewer,\n  pdf_document_properties,\n  pdf_find_bar,\n  pdf_find_controller,\n  pdf_history,\n  pdf_layer_viewer,\n  pdf_link_service,\n  pdf_outline_viewer,\n  pdf_presentation_mode,\n  pdf_sidebar,\n  pdf_sidebar_resizer,\n  pdf_thumbnail_viewer,\n  pdf_viewer,\n  secondary_toolbar,\n  toolbar,\n  viewer_compatibility,\n  view_history\n\n  ){\n\n  /* Copyright 2012 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n  /* globals PDFBug, Stats */\n\n\n\n  const {\n    animationStarted,\n    AutoPrintRegExp,\n    DEFAULT_SCALE_VALUE,\n    EventBus,\n    getActiveOrFocusedElement,\n    getPDFFileNameFromURL,\n    isValidRotation,\n    isValidScrollMode,\n    isValidSpreadMode,\n    MAX_SCALE,\n    MIN_SCALE,\n    noContextMenuHandler,\n    normalizeWheelEventDirection,\n    parseQueryString,\n    ProgressBar,\n    RendererType,\n    ScrollMode,\n    SidebarView,\n    SpreadMode,\n    TextLayerMode,\n  } = ui_utils;\n\n\n\n  const { AppOptions, OptionKind } = app_options;\n  const {\n    build,\n    createPromiseCapability,\n    getDocument,\n    getFilenameFromUrl,\n    GlobalWorkerOptions,\n    InvalidPDFException,\n    LinkTarget,\n    loadScript,\n    MissingPDFException,\n    OPS,\n    PDFWorker,\n    PermissionFlag,\n    shadow,\n    UnexpectedResponseException,\n    UNSUPPORTED_FEATURES,\n    version,\n  } = pdfjsLib;\n\n\n  const { CursorTool, PDFCursorTools } = pdf_cursor_tools;\n  const { PDFRenderingQueue, RenderingStates } = pdf_rendering_queue;\n  const { OverlayManager } = overlay_manager;\n  const { PasswordPrompt } = password_prompt;\n  const { PDFAttachmentViewer } = pdf_attachment_viewer;\n  const { PDFDocumentProperties } = pdf_document_properties;\n  const { PDFFindBar } = pdf_find_bar;\n  const { PDFFindController } = pdf_find_controller;\n  const { PDFHistory } = pdf_history;\n  const { PDFLayerViewer } = pdf_layer_viewer;\n  const { PDFLinkService } = pdf_link_service;\n  const { PDFOutlineViewer } = pdf_outline_viewer;\n  const { PDFPresentationMode } = pdf_presentation_mode;\n  const { PDFSidebar } = pdf_sidebar;\n  const { PDFSidebarResizer } = pdf_sidebar_resizer;\n  const { PDFThumbnailViewer } = pdf_thumbnail_viewer;\n  const { PDFViewer } = pdf_viewer;\n  const { SecondaryToolbar } = secondary_toolbar;\n  const { Toolbar } = toolbar;\n  const { viewerCompatibilityParams } = viewer_compatibility;\n  const { ViewHistory } = view_history;\n\n  const DEFAULT_SCALE_DELTA = 1.1;\n  const DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT = 5000; // ms\n  const FORCE_PAGES_LOADED_TIMEOUT = 10000; // ms\n  const WHEEL_ZOOM_DISABLED_TIMEOUT = 1000; // ms\n  const ENABLE_PERMISSIONS_CLASS = \"enablePermissions\";\n\n  const ViewOnLoad = {\n    UNKNOWN: -1,\n    PREVIOUS: 0, // Default value.\n    INITIAL: 1,\n  };\n\n  const ViewerCssTheme = {\n    AUTOMATIC: 0, // Default value.\n    LIGHT: 1,\n    DARK: 2,\n  };\n\n  // Keep these in sync with mozilla-central's Histograms.json.\n  const KNOWN_VERSIONS = [\n    \"1.0\",\n    \"1.1\",\n    \"1.2\",\n    \"1.3\",\n    \"1.4\",\n    \"1.5\",\n    \"1.6\",\n    \"1.7\",\n    \"1.8\",\n    \"1.9\",\n    \"2.0\",\n    \"2.1\",\n    \"2.2\",\n    \"2.3\",\n  ];\n  // Keep these in sync with mozilla-central's Histograms.json.\n  const KNOWN_GENERATORS = [\n    \"acrobat distiller\",\n    \"acrobat pdfwriter\",\n    \"adobe livecycle\",\n    \"adobe pdf library\",\n    \"adobe photoshop\",\n    \"ghostscript\",\n    \"tcpdf\",\n    \"cairo\",\n    \"dvipdfm\",\n    \"dvips\",\n    \"pdftex\",\n    \"pdfkit\",\n    \"itext\",\n    \"prince\",\n    \"quarkxpress\",\n    \"mac os x\",\n    \"microsoft\",\n    \"openoffice\",\n    \"oracle\",\n    \"luradocument\",\n    \"pdf-xchange\",\n    \"antenna house\",\n    \"aspose.cells\",\n    \"fpdf\",\n  ];\n\n  class DefaultExternalServices {\n    constructor() {\n      throw new Error(\"Cannot initialize DefaultExternalServices.\");\n    }\n\n    static updateFindControlState(data) {}\n\n    static updateFindMatchesCount(data) {}\n\n    static initPassiveLoading(callbacks) {}\n\n    static async fallback(data) {}\n\n    static reportTelemetry(data) {}\n\n    static createDownloadManager(options) {\n      throw new Error(\"Not implemented: createDownloadManager\");\n    }\n\n    static createPreferences() {\n      throw new Error(\"Not implemented: createPreferences\");\n    }\n\n    static createL10n(options) {\n      throw new Error(\"Not implemented: createL10n\");\n    }\n\n    static createScripting(options) {\n      throw new Error(\"Not implemented: createScripting\");\n    }\n\n    static get supportsIntegratedFind() {\n      return shadow(this, \"supportsIntegratedFind\", false);\n    }\n\n    static get supportsDocumentFonts() {\n      return shadow(this, \"supportsDocumentFonts\", true);\n    }\n\n    static get supportedMouseWheelZoomModifierKeys() {\n      return shadow(this, \"supportedMouseWheelZoomModifierKeys\", {\n        ctrlKey: true,\n        metaKey: true,\n      });\n    }\n\n    static get isInAutomation() {\n      return shadow(this, \"isInAutomation\", false);\n    }\n  }\n\n  const PDFViewerApplication = {\n    initialBookmark: document.location.hash.substring(1),\n    _initializedCapability: createPromiseCapability(),\n    fellback: false,\n    appConfig: null,\n    pdfDocument: null,\n    pdfLoadingTask: null,\n    printService: null,\n    /** @type {PDFViewer} */\n    pdfViewer: null,\n    /** @type {PDFThumbnailViewer} */\n    pdfThumbnailViewer: null,\n    /** @type {PDFRenderingQueue} */\n    pdfRenderingQueue: null,\n    /** @type {PDFPresentationMode} */\n    pdfPresentationMode: null,\n    /** @type {PDFDocumentProperties} */\n    pdfDocumentProperties: null,\n    /** @type {PDFLinkService} */\n    pdfLinkService: null,\n    /** @type {PDFHistory} */\n    pdfHistory: null,\n    /** @type {PDFSidebar} */\n    pdfSidebar: null,\n    /** @type {PDFSidebarResizer} */\n    pdfSidebarResizer: null,\n    /** @type {PDFOutlineViewer} */\n    pdfOutlineViewer: null,\n    /** @type {PDFAttachmentViewer} */\n    pdfAttachmentViewer: null,\n    /** @type {PDFLayerViewer} */\n    pdfLayerViewer: null,\n    /** @type {PDFCursorTools} */\n    pdfCursorTools: null,\n    /** @type {ViewHistory} */\n    store: null,\n    /** @type {DownloadManager} */\n    downloadManager: null,\n    /** @type {OverlayManager} */\n    overlayManager: null,\n    /** @type {Preferences} */\n    preferences: null,\n    /** @type {Toolbar} */\n    toolbar: null,\n    /** @type {SecondaryToolbar} */\n    secondaryToolbar: null,\n    /** @type {EventBus} */\n    eventBus: null,\n    /** @type {IL10n} */\n    l10n: null,\n    isInitialViewSet: false,\n    downloadComplete: false,\n    isViewerEmbedded: window.parent !== window,\n    url: \"\",\n    baseUrl: \"\",\n    externalServices: DefaultExternalServices,\n    _boundEvents: Object.create(null),\n    documentInfo: null,\n    metadata: null,\n    _contentDispositionFilename: null,\n    _contentLength: null,\n    triggerDelayedFallback: null,\n    _saveInProgress: false,\n    _wheelUnusedTicks: 0,\n    _idleCallbacks: new Set(),\n    _scriptingInstance: null,\n    _mouseState: Object.create(null),\n\n    // Called once when the document is loaded.\n    async initialize(appConfig) {\n      this.preferences = this.externalServices.createPreferences();\n      this.appConfig = appConfig;\n\n      await this._readPreferences();\n      await this._parseHashParameters();\n      this._forceCssTheme();\n      await this._initializeL10n();\n\n      if (\n        this.isViewerEmbedded &&\n        AppOptions.get(\"externalLinkTarget\") === LinkTarget.NONE\n      ) {\n        // Prevent external links from \"replacing\" the viewer,\n        // when it's embedded in e.g. an <iframe> or an <object>.\n        AppOptions.set(\"externalLinkTarget\", LinkTarget.TOP);\n      }\n      await this._initializeViewerComponents();\n\n      // Bind the various event handlers *after* the viewer has been\n      // initialized, to prevent errors if an event arrives too soon.\n      this.bindEvents();\n      this.bindWindowEvents();\n\n      // We can start UI localization now.\n      const appContainer = appConfig.appContainer || document.documentElement;\n      this.l10n.translate(appContainer).then(() => {\n        // Dispatch the 'localized' event on the `eventBus` once the viewer\n        // has been fully initialized and translated.\n        this.eventBus.dispatch(\"localized\", { source: this });\n      });\n\n      this._initializedCapability.resolve();\n    },\n\n    /**\n     * @private\n     */\n    async _readPreferences() {\n      if (\n        (typeof PDFJSDev === \"undefined\" ||\n          PDFJSDev.test(\"!PRODUCTION || GENERIC\")) &&\n        AppOptions.get(\"disablePreferences\")\n      ) {\n        // Give custom implementations of the default viewer a simpler way to\n        // opt-out of having the `Preferences` override existing `AppOptions`.\n        return;\n      }\n      try {\n        AppOptions.setAll(await this.preferences.getAll());\n      } catch (reason) {\n        ///console.error(`_readPreferences: \"${reason?.message}\".`);  // lwf\n        console.error(`_readPreferences: \"${reason && reason.message}\".`); \n      }\n    },\n\n    /**\n     * Potentially parse special debugging flags in the hash section of the URL.\n     * @private\n     */\n    async _parseHashParameters() {\n      if (!AppOptions.get(\"pdfBugEnabled\")) {\n        return undefined;\n      }\n      const hash = document.location.hash.substring(1);\n      if (!hash) {\n        return undefined;\n      }\n      const hashParams = parseQueryString(hash),\n        waitOn = [];\n\n      if (\"disableworker\" in hashParams && hashParams.disableworker === \"true\") {\n        waitOn.push(loadFakeWorker());\n      }\n      if (\"disablerange\" in hashParams) {\n        AppOptions.set(\"disableRange\", hashParams.disablerange === \"true\");\n      }\n      if (\"disablestream\" in hashParams) {\n        AppOptions.set(\"disableStream\", hashParams.disablestream === \"true\");\n      }\n      if (\"disableautofetch\" in hashParams) {\n        AppOptions.set(\n          \"disableAutoFetch\",\n          hashParams.disableautofetch === \"true\"\n        );\n      }\n      if (\"disablefontface\" in hashParams) {\n        AppOptions.set(\"disableFontFace\", hashParams.disablefontface === \"true\");\n      }\n      if (\"disablehistory\" in hashParams) {\n        AppOptions.set(\"disableHistory\", hashParams.disablehistory === \"true\");\n      }\n      if (\"webgl\" in hashParams) {\n        AppOptions.set(\"enableWebGL\", hashParams.webgl === \"true\");\n      }\n      if (\"verbosity\" in hashParams) {\n        AppOptions.set(\"verbosity\", hashParams.verbosity | 0);\n      }\n      if (\"textlayer\" in hashParams) {\n        switch (hashParams.textlayer) {\n          case \"off\":\n            AppOptions.set(\"textLayerMode\", TextLayerMode.DISABLE);\n            break;\n          case \"visible\":\n          case \"shadow\":\n          case \"hover\":\n            const viewer = this.appConfig.viewerContainer;\n            viewer.classList.add(\"textLayer-\" + hashParams.textlayer);\n            break;\n        }\n      }\n      if (\"pdfbug\" in hashParams) {\n        AppOptions.set(\"pdfBug\", true);\n        AppOptions.set(\"fontExtraProperties\", true);\n\n        const enabled = hashParams.pdfbug.split(\",\");\n        waitOn.push(loadAndEnablePDFBug(enabled));\n      }\n      // It is not possible to change locale for the (various) extension builds.\n      if (\n        (typeof PDFJSDev === \"undefined\" ||\n          PDFJSDev.test(\"!PRODUCTION || GENERIC\")) &&\n        \"locale\" in hashParams\n      ) {\n        AppOptions.set(\"locale\", hashParams.locale);\n      }\n\n      if (waitOn.length === 0) {\n        return undefined;\n      }\n      return Promise.all(waitOn).catch(reason => {\n        console.error(`_parseHashParameters: \"${reason.message}\".`);\n      });\n    },\n\n    /**\n     * @private\n     */\n    async _initializeL10n() {\n      this.l10n = this.externalServices.createL10n(\n        typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"!PRODUCTION || GENERIC\")\n          ? { locale: AppOptions.get(\"locale\") }\n          : null\n      );\n      const dir = await this.l10n.getDirection();\n      document.getElementsByTagName(\"html\")[0].dir = dir;\n    },\n\n    /**\n     * @private\n     */\n    _forceCssTheme() {\n      const cssTheme = AppOptions.get(\"viewerCssTheme\");\n      if (\n        cssTheme === ViewerCssTheme.AUTOMATIC ||\n        !Object.values(ViewerCssTheme).includes(cssTheme)\n      ) {\n        return;\n      }\n      try {\n        const styleSheet = document.styleSheets[0];\n        //const cssRules = styleSheet?.cssRules || []; // lwf\n        const cssRules = styleSheet && styleSheet.cssRules || [];\n        for (let i = 0, ii = cssRules.length; i < ii; i++) {\n          const rule = cssRules[i];\n          if (\n            rule instanceof CSSMediaRule &&\n            ///rule.media?.[0] === \"(prefers-color-scheme: dark)\" // lwf\n            rule.media && rule.media[0] === \"(prefers-color-scheme: dark)\"\n          ) {\n            if (cssTheme === ViewerCssTheme.LIGHT) {\n              styleSheet.deleteRule(i);\n              return;\n            }\n            // cssTheme === ViewerCssTheme.DARK\n            const darkRules = /^@media \\(prefers-color-scheme: dark\\) {\\n\\s*([\\w\\s-.,:;/\\\\{}()]+)\\n}$/.exec(\n              rule.cssText\n            );\n            ///if (darkRules?.[1]) { // lwf\n            if (darkRules && darkRules[1]) {\n              styleSheet.deleteRule(i);\n              styleSheet.insertRule(darkRules[1], i);\n            }\n            return;\n          }\n        }\n      } catch (reason) {\n        ///console.error(`_forceCssTheme: \"${reason?.message}\".`); // lwf\n        console.error(`_forceCssTheme: \"${reason && reason.message}\".`);\n      }\n    },\n\n    /**\n     * @private\n     */\n    async _initializeViewerComponents() {\n      const appConfig = this.appConfig;\n\n      const eventBus =\n        appConfig.eventBus ||\n        new EventBus({ isInAutomation: this.externalServices.isInAutomation });\n      this.eventBus = eventBus;\n\n      this.overlayManager = new OverlayManager();\n\n      const pdfRenderingQueue = new PDFRenderingQueue();\n      pdfRenderingQueue.onIdle = this.cleanup.bind(this);\n      this.pdfRenderingQueue = pdfRenderingQueue;\n\n      const pdfLinkService = new PDFLinkService({\n        eventBus,\n        externalLinkTarget: AppOptions.get(\"externalLinkTarget\"),\n        externalLinkRel: AppOptions.get(\"externalLinkRel\"),\n        ignoreDestinationZoom: AppOptions.get(\"ignoreDestinationZoom\"),\n      });\n      this.pdfLinkService = pdfLinkService;\n\n      const downloadManager = this.externalServices.createDownloadManager();\n      this.downloadManager = downloadManager;\n\n      const findController = new PDFFindController({\n        linkService: pdfLinkService,\n        eventBus,\n      });\n      this.findController = findController;\n\n      const container = appConfig.mainContainer;\n      const viewer = appConfig.viewerContainer;\n      this.pdfViewer = new PDFViewer({\n        container,\n        viewer,\n        eventBus,\n        renderingQueue: pdfRenderingQueue,\n        linkService: pdfLinkService,\n        downloadManager,\n        findController,\n        renderer: AppOptions.get(\"renderer\"),\n        enableWebGL: AppOptions.get(\"enableWebGL\"),\n        l10n: this.l10n,\n        textLayerMode: AppOptions.get(\"textLayerMode\"),\n        imageResourcesPath: AppOptions.get(\"imageResourcesPath\"),\n        renderInteractiveForms: AppOptions.get(\"renderInteractiveForms\"),\n        enablePrintAutoRotate: AppOptions.get(\"enablePrintAutoRotate\"),\n        useOnlyCssZoom: AppOptions.get(\"useOnlyCssZoom\"),\n        maxCanvasPixels: AppOptions.get(\"maxCanvasPixels\"),\n        enableScripting: AppOptions.get(\"enableScripting\"),\n        mouseState: this._mouseState,\n      });\n      pdfRenderingQueue.setViewer(this.pdfViewer);\n      pdfLinkService.setViewer(this.pdfViewer);\n\n      this.pdfThumbnailViewer = new PDFThumbnailViewer({\n        container: appConfig.sidebar.thumbnailView,\n        eventBus,\n        renderingQueue: pdfRenderingQueue,\n        linkService: pdfLinkService,\n        l10n: this.l10n,\n      });\n      pdfRenderingQueue.setThumbnailViewer(this.pdfThumbnailViewer);\n\n      this.pdfHistory = new PDFHistory({\n        linkService: pdfLinkService,\n        eventBus,\n      });\n      pdfLinkService.setHistory(this.pdfHistory);\n\n      if (!this.supportsIntegratedFind) {\n        this.findBar = new PDFFindBar(appConfig.findBar, eventBus, this.l10n);\n      }\n\n      this.pdfDocumentProperties = new PDFDocumentProperties(\n        appConfig.documentProperties,\n        this.overlayManager,\n        eventBus,\n        this.l10n\n      );\n\n      this.pdfCursorTools = new PDFCursorTools({\n        container,\n        eventBus,\n        cursorToolOnLoad: AppOptions.get(\"cursorToolOnLoad\"),\n      });\n\n      this.toolbar = new Toolbar(appConfig.toolbar, eventBus, this.l10n);\n\n      this.secondaryToolbar = new SecondaryToolbar(\n        appConfig.secondaryToolbar,\n        container,\n        eventBus\n      );\n\n      if (this.supportsFullscreen) {\n        this.pdfPresentationMode = new PDFPresentationMode({\n          container,\n          pdfViewer: this.pdfViewer,\n          eventBus,\n          contextMenuItems: appConfig.fullscreen,\n        });\n      }\n\n      this.passwordPrompt = new PasswordPrompt(\n        appConfig.passwordOverlay,\n        this.overlayManager,\n        this.l10n\n      );\n\n      this.pdfOutlineViewer = new PDFOutlineViewer({\n        container: appConfig.sidebar.outlineView,\n        eventBus,\n        linkService: pdfLinkService,\n      });\n\n      this.pdfAttachmentViewer = new PDFAttachmentViewer({\n        container: appConfig.sidebar.attachmentsView,\n        eventBus,\n        downloadManager,\n      });\n\n      this.pdfLayerViewer = new PDFLayerViewer({\n        container: appConfig.sidebar.layersView,\n        eventBus,\n        l10n: this.l10n,\n      });\n\n      this.pdfSidebar = new PDFSidebar({\n        elements: appConfig.sidebar,\n        pdfViewer: this.pdfViewer,\n        pdfThumbnailViewer: this.pdfThumbnailViewer,\n        eventBus,\n        l10n: this.l10n,\n      });\n      this.pdfSidebar.onToggled = this.forceRendering.bind(this);\n\n      this.pdfSidebarResizer = new PDFSidebarResizer(\n        appConfig.sidebarResizer,\n        eventBus,\n        this.l10n\n      );\n    },\n\n    run(config) {\n      this.initialize(config).then(webViewerInitialized);\n    },\n\n    get initialized() {\n      return this._initializedCapability.settled;\n    },\n\n    get initializedPromise() {\n      return this._initializedCapability.promise;\n    },\n\n    zoomIn(ticks) {\n      if (this.pdfViewer.isInPresentationMode) {\n        return;\n      }\n      let newScale = this.pdfViewer.currentScale;\n      do {\n        newScale = (newScale * DEFAULT_SCALE_DELTA).toFixed(2);\n        newScale = Math.ceil(newScale * 10) / 10;\n        newScale = Math.min(MAX_SCALE, newScale);\n      } while (--ticks > 0 && newScale < MAX_SCALE);\n      this.pdfViewer.currentScaleValue = newScale;\n    },\n\n    zoomOut(ticks) {\n      if (this.pdfViewer.isInPresentationMode) {\n        return;\n      }\n      let newScale = this.pdfViewer.currentScale;\n      do {\n        newScale = (newScale / DEFAULT_SCALE_DELTA).toFixed(2);\n        newScale = Math.floor(newScale * 10) / 10;\n        newScale = Math.max(MIN_SCALE, newScale);\n      } while (--ticks > 0 && newScale > MIN_SCALE);\n      this.pdfViewer.currentScaleValue = newScale;\n    },\n\n    zoomReset() {\n      if (this.pdfViewer.isInPresentationMode) {\n        return;\n      }\n      this.pdfViewer.currentScaleValue = DEFAULT_SCALE_VALUE;\n    },\n\n    get pagesCount() {\n      return this.pdfDocument ? this.pdfDocument.numPages : 0;\n    },\n\n    get page() {\n      return this.pdfViewer.currentPageNumber;\n    },\n\n    set page(val) {\n      this.pdfViewer.currentPageNumber = val;\n    },\n\n    get supportsPrinting() {\n      return PDFPrintServiceFactory.instance.supportsPrinting;\n    },\n\n    get supportsFullscreen() {\n      let support;\n      if (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"MOZCENTRAL\")) {\n        support =\n          document.fullscreenEnabled === true ||\n          document.mozFullScreenEnabled === true;\n      } else {\n        const doc = document.documentElement;\n        support = !!(\n          doc.requestFullscreen ||\n          doc.mozRequestFullScreen ||\n          doc.webkitRequestFullScreen\n        );\n\n        if (\n          document.fullscreenEnabled === false ||\n          document.mozFullScreenEnabled === false ||\n          document.webkitFullscreenEnabled === false\n        ) {\n          support = false;\n        }\n      }\n      return shadow(this, \"supportsFullscreen\", support);\n    },\n\n    get supportsIntegratedFind() {\n      return this.externalServices.supportsIntegratedFind;\n    },\n\n    get supportsDocumentFonts() {\n      return this.externalServices.supportsDocumentFonts;\n    },\n\n    get loadingBar() {\n      const bar = new ProgressBar(\"#loadingBar\");\n      return shadow(this, \"loadingBar\", bar);\n    },\n\n    get supportedMouseWheelZoomModifierKeys() {\n      return this.externalServices.supportedMouseWheelZoomModifierKeys;\n    },\n\n    initPassiveLoading() {\n      if (\n        typeof PDFJSDev === \"undefined\" ||\n        !PDFJSDev.test(\"MOZCENTRAL || CHROME\")\n      ) {\n        throw new Error(\"Not implemented: initPassiveLoading\");\n      }\n      this.externalServices.initPassiveLoading({\n        onOpenWithTransport(url, length, transport) {\n          PDFViewerApplication.open(url, { length, range: transport });\n        },\n        onOpenWithData(data) {\n          PDFViewerApplication.open(data);\n        },\n        onOpenWithURL(url, length, originalUrl) {\n          let file = url,\n            args = null;\n          if (length !== undefined) {\n            args = { length };\n          }\n          if (originalUrl !== undefined) {\n            file = { url, originalUrl };\n          }\n          PDFViewerApplication.open(file, args);\n        },\n        onError(err) {\n          PDFViewerApplication.l10n\n            .get(\n              \"loading_error\",\n              null,\n              \"An error occurred while loading the PDF.\"\n            )\n            .then(msg => {\n              PDFViewerApplication.error(msg, err);\n            });\n        },\n        onProgress(loaded, total) {\n          PDFViewerApplication.progress(loaded / total);\n        },\n      });\n    },\n\n    setTitleUsingUrl(url = \"\") {\n      this.url = url;\n      this.baseUrl = url.split(\"#\")[0];\n      let title = getPDFFileNameFromURL(url, \"\");\n      if (!title) {\n        try {\n          title = decodeURIComponent(getFilenameFromUrl(url)) || url;\n        } catch (ex) {\n          // decodeURIComponent may throw URIError,\n          // fall back to using the unprocessed url in that case\n          title = url;\n        }\n      }\n      this.setTitle(title);\n    },\n\n    setTitle(title) {\n      if (this.isViewerEmbedded) {\n        // Embedded PDF viewers should not be changing their parent page's title.\n        return;\n      }\n      document.title = title;\n    },\n\n    get _docFilename() {\n      // Use `this.url` instead of `this.baseUrl` to perform filename detection\n      // based on the reference fragment as ultimate fallback if needed.\n      return this._contentDispositionFilename || getPDFFileNameFromURL(this.url);\n    },\n\n    /**\n     * @private\n     */\n    _cancelIdleCallbacks() {\n      if (!this._idleCallbacks.size) {\n        return;\n      }\n      for (const callback of this._idleCallbacks) {\n        window.cancelIdleCallback(callback);\n      }\n      this._idleCallbacks.clear();\n    },\n\n    /**\n     * @private\n     */\n    async _destroyScriptingInstance() {\n      if (!this._scriptingInstance) {\n        return;\n      }\n      const { scripting, internalEvents, domEvents } = this._scriptingInstance;\n      try {\n        await scripting.destroySandbox();\n      } catch (ex) {}\n\n      for (const [name, listener] of internalEvents) {\n        this.eventBus._off(name, listener);\n      }\n      internalEvents.clear();\n\n      for (const [name, listener] of domEvents) {\n        window.removeEventListener(name, listener);\n      }\n      domEvents.clear();\n\n      delete this._mouseState.isDown;\n      this._scriptingInstance = null;\n    },\n\n    /**\n     * Closes opened PDF document.\n     * @returns {Promise} - Returns the promise, which is resolved when all\n     *                      destruction is completed.\n     */\n    async close() {\n      const errorWrapper = this.appConfig.errorWrapper.container;\n      errorWrapper.setAttribute(\"hidden\", \"true\");\n\n      if (!this.pdfLoadingTask) {\n        return undefined;\n      }\n      const promises = [];\n\n      promises.push(this.pdfLoadingTask.destroy());\n      this.pdfLoadingTask = null;\n\n      if (this.pdfDocument) {\n        this.pdfDocument = null;\n\n        this.pdfThumbnailViewer.setDocument(null);\n        this.pdfViewer.setDocument(null);\n        this.pdfLinkService.setDocument(null);\n        this.pdfDocumentProperties.setDocument(null);\n      }\n      webViewerResetPermissions();\n      this.store = null;\n      this.isInitialViewSet = false;\n      this.downloadComplete = false;\n      this.url = \"\";\n      this.baseUrl = \"\";\n      this.documentInfo = null;\n      this.metadata = null;\n      this._contentDispositionFilename = null;\n      this._contentLength = null;\n      this.triggerDelayedFallback = null;\n      this._saveInProgress = false;\n\n      this._cancelIdleCallbacks();\n      promises.push(this._destroyScriptingInstance());\n\n      this.pdfSidebar.reset();\n      this.pdfOutlineViewer.reset();\n      this.pdfAttachmentViewer.reset();\n      this.pdfLayerViewer.reset();\n\n      if (this.pdfHistory) {\n        this.pdfHistory.reset();\n      }\n      if (this.findBar) {\n        this.findBar.reset();\n      }\n      this.toolbar.reset();\n      this.secondaryToolbar.reset();\n\n      if (typeof PDFBug !== \"undefined\") {\n        PDFBug.cleanup();\n      }\n      await Promise.all(promises);\n\n      return undefined;\n    },\n\n    /**\n     * Opens PDF document specified by URL or array with additional arguments.\n     * @param {string|TypedArray|ArrayBuffer} file - PDF location or binary data.\n     * @param {Object} [args] - Additional arguments for the getDocument call,\n     *                          e.g. HTTP headers ('httpHeaders') or alternative\n     *                          data transport ('range').\n     * @returns {Promise} - Returns the promise, which is resolved when document\n     *                      is opened.\n     */\n    async open(file, args) {\n      if (this.pdfLoadingTask) {\n        // We need to destroy already opened document.\n        await this.close();\n      }\n      // Set the necessary global worker parameters, using the available options.\n      const workerParameters = AppOptions.getAll(OptionKind.WORKER);\n      for (const key in workerParameters) {\n        GlobalWorkerOptions[key] = workerParameters[key];\n      }\n\n      const parameters = Object.create(null);\n      if (typeof file === \"string\") {\n        // URL\n        this.setTitleUsingUrl(file);\n        parameters.url = file;\n      } else if (file && \"byteLength\" in file) {\n        // ArrayBuffer\n        parameters.data = file;\n      } else if (file.url && file.originalUrl) {\n        this.setTitleUsingUrl(file.originalUrl);\n        parameters.url = file.url;\n      }\n      // Set the necessary API parameters, using the available options.\n      const apiParameters = AppOptions.getAll(OptionKind.API);\n      for (const key in apiParameters) {\n        let value = apiParameters[key];\n\n        if (key === \"docBaseUrl\" && !value) {\n          if (typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"PRODUCTION\")) {\n            value = document.URL.split(\"#\")[0];\n          } else if (PDFJSDev.test(\"MOZCENTRAL || CHROME\")) {\n            value = this.baseUrl;\n          }\n        }\n        parameters[key] = value;\n      }\n      // Finally, update the API parameters with the arguments (if they exist).\n      if (args) {\n        for (const key in args) {\n          parameters[key] = args[key];\n        }\n      }\n\n      const loadingTask = getDocument(parameters);\n      this.pdfLoadingTask = loadingTask;\n\n      loadingTask.onPassword = (updateCallback, reason) => {\n        this.pdfLinkService.externalLinkEnabled = false;\n        this.passwordPrompt.setUpdateCallback(updateCallback, reason);\n        this.passwordPrompt.open();\n      };\n\n      loadingTask.onProgress = ({ loaded, total }) => {\n        this.progress(loaded / total);\n      };\n\n      // Listen for unsupported features to trigger the fallback UI.\n      loadingTask.onUnsupportedFeature = this.fallback.bind(this);\n\n      return loadingTask.promise.then(\n        pdfDocument => {\n          this.load(pdfDocument);\n        },\n        exception => {\n          if (loadingTask !== this.pdfLoadingTask) {\n            return undefined; // Ignore errors for previously opened PDF files.\n          }\n\n          ///const message = exception?.message; // lwf\n          const message = exception && exception.message;\n          let loadingErrorMessage;\n          if (exception instanceof InvalidPDFException) {\n            // change error message also for other builds\n            loadingErrorMessage = this.l10n.get(\n              \"invalid_file_error\",\n              null,\n              \"Invalid or corrupted PDF file.\"\n            );\n          } else if (exception instanceof MissingPDFException) {\n            // special message for missing PDF's\n            loadingErrorMessage = this.l10n.get(\n              \"missing_file_error\",\n              null,\n              \"Missing PDF file.\"\n            );\n          } else if (exception instanceof UnexpectedResponseException) {\n            loadingErrorMessage = this.l10n.get(\n              \"unexpected_response_error\",\n              null,\n              \"Unexpected server response.\"\n            );\n          } else {\n            loadingErrorMessage = this.l10n.get(\n              \"loading_error\",\n              null,\n              \"An error occurred while loading the PDF.\"\n            );\n          }\n\n          return loadingErrorMessage.then(msg => {\n            this.error(msg, { message });\n            throw exception;\n          });\n        }\n      );\n    },\n\n    download({ sourceEventType = \"download\" } = {}) {\n      function downloadByUrl() {\n        downloadManager.downloadUrl(url, filename);\n      }\n\n      const downloadManager = this.downloadManager,\n        url = this.baseUrl,\n        filename = this._docFilename;\n\n      // When the PDF document isn't ready, or the PDF file is still downloading,\n      // simply download using the URL.\n      if (!this.pdfDocument || !this.downloadComplete) {\n        downloadByUrl();\n        return;\n      }\n\n      this.pdfDocument\n        .getData()\n        .then(function (data) {\n          const blob = new Blob([data], { type: \"application/pdf\" });\n          downloadManager.download(blob, url, filename, sourceEventType);\n        })\n        .catch(downloadByUrl); // Error occurred, try downloading with the URL.\n    },\n\n    async save({ sourceEventType = \"download\" } = {}) {\n      if (this._saveInProgress) {\n        return;\n      }\n\n      const downloadManager = this.downloadManager,\n        url = this.baseUrl,\n        filename = this._docFilename;\n\n      // When the PDF document isn't ready, or the PDF file is still downloading,\n      // simply download using the URL.\n      if (!this.pdfDocument || !this.downloadComplete) {\n        this.download({ sourceEventType });\n        return;\n      }\n      this._saveInProgress = true;\n\n      ///await this._scriptingInstance?.scripting.dispatchEventInSandbox({ // lwf\n      await this._scriptingInstance && this._scriptingInstance.scripting.dispatchEventInSandbox({\n        id: \"doc\",\n        name: \"WillSave\",\n      });\n\n      this.pdfDocument\n        .saveDocument(this.pdfDocument.annotationStorage)\n        .then(data => {\n          const blob = new Blob([data], { type: \"application/pdf\" });\n          downloadManager.download(blob, url, filename, sourceEventType);\n        })\n        .catch(() => {\n          this.download({ sourceEventType });\n        })\n        .finally(async () => {\n          ///await this._scriptingInstance?.scripting.dispatchEventInSandbox({ // lwf\n          await this._scriptingInstance && this._scriptingInstance.scripting.dispatchEventInSandbox({\n            id: \"doc\",\n            name: \"DidSave\",\n          });\n\n          this._saveInProgress = false;\n        });\n    },\n\n    downloadOrSave(options) {\n      ///if (this.pdfDocument?.annotationStorage.size > 0) { // lwf\n      if (this.pdfDocument && this.pdfDocument.annotationStorage.size > 0) {\n        this.save(options);\n      } else {\n        this.download(options);\n      }\n    },\n\n    /**\n     * For PDF documents that contain e.g. forms and javaScript, we should only\n     * trigger the fallback bar once the user has interacted with the page.\n     * @private\n     */\n    _delayedFallback(featureId) {\n      // Ensure that telemetry is always reported, since it's not guaranteed\n      // that the fallback bar will be shown (depends on user interaction).\n      this.externalServices.reportTelemetry({\n        type: \"unsupportedFeature\",\n        featureId,\n      });\n\n      if (!this.triggerDelayedFallback) {\n        this.triggerDelayedFallback = () => {\n          this.fallback(featureId);\n          this.triggerDelayedFallback = null;\n        };\n      }\n    },\n\n    fallback(featureId) {\n      this.externalServices.reportTelemetry({\n        type: \"unsupportedFeature\",\n        featureId,\n      });\n\n      // Only trigger the fallback once so we don't spam the user with messages\n      // for one PDF.\n      if (this.fellback) {\n        return;\n      }\n      this.fellback = true;\n      this.externalServices\n        .fallback({\n          featureId,\n          url: this.baseUrl,\n        })\n        .then(download => {\n          if (!download) {\n            return;\n          }\n          this.download({ sourceEventType: \"download\" });\n        });\n    },\n\n    /**\n     * Show the error box.\n     * @param {string} message - A message that is human readable.\n     * @param {Object} [moreInfo] - Further information about the error that is\n     *                              more technical.  Should have a 'message' and\n     *                              optionally a 'stack' property.\n     */\n    error(message, moreInfo) {\n      const moreInfoText = [\n        this.l10n.get(\n          \"error_version_info\",\n          { version: version || \"?\", build: build || \"?\" },\n          \"PDF.js v{{version}} (build: {{build}})\"\n        ),\n      ];\n      if (moreInfo) {\n        moreInfoText.push(\n          this.l10n.get(\n            \"error_message\",\n            { message: moreInfo.message },\n            \"Message: {{message}}\"\n          )\n        );\n        if (moreInfo.stack) {\n          moreInfoText.push(\n            this.l10n.get(\n              \"error_stack\",\n              { stack: moreInfo.stack },\n              \"Stack: {{stack}}\"\n            )\n          );\n        } else {\n          if (moreInfo.filename) {\n            moreInfoText.push(\n              this.l10n.get(\n                \"error_file\",\n                { file: moreInfo.filename },\n                \"File: {{file}}\"\n              )\n            );\n          }\n          if (moreInfo.lineNumber) {\n            moreInfoText.push(\n              this.l10n.get(\n                \"error_line\",\n                { line: moreInfo.lineNumber },\n                \"Line: {{line}}\"\n              )\n            );\n          }\n        }\n      }\n\n      if (typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"MOZCENTRAL\")) {\n        const errorWrapperConfig = this.appConfig.errorWrapper;\n        const errorWrapper = errorWrapperConfig.container;\n        errorWrapper.removeAttribute(\"hidden\");\n\n        const errorMessage = errorWrapperConfig.errorMessage;\n        errorMessage.textContent = message;\n\n        const closeButton = errorWrapperConfig.closeButton;\n        closeButton.onclick = function () {\n          errorWrapper.setAttribute(\"hidden\", \"true\");\n        };\n\n        const errorMoreInfo = errorWrapperConfig.errorMoreInfo;\n        const moreInfoButton = errorWrapperConfig.moreInfoButton;\n        const lessInfoButton = errorWrapperConfig.lessInfoButton;\n        moreInfoButton.onclick = function () {\n          errorMoreInfo.removeAttribute(\"hidden\");\n          moreInfoButton.setAttribute(\"hidden\", \"true\");\n          lessInfoButton.removeAttribute(\"hidden\");\n          errorMoreInfo.style.height = errorMoreInfo.scrollHeight + \"px\";\n        };\n        lessInfoButton.onclick = function () {\n          errorMoreInfo.setAttribute(\"hidden\", \"true\");\n          moreInfoButton.removeAttribute(\"hidden\");\n          lessInfoButton.setAttribute(\"hidden\", \"true\");\n        };\n        moreInfoButton.oncontextmenu = noContextMenuHandler;\n        lessInfoButton.oncontextmenu = noContextMenuHandler;\n        closeButton.oncontextmenu = noContextMenuHandler;\n        moreInfoButton.removeAttribute(\"hidden\");\n        lessInfoButton.setAttribute(\"hidden\", \"true\");\n        Promise.all(moreInfoText).then(parts => {\n          errorMoreInfo.value = parts.join(\"\\n\");\n        });\n      } else {\n        Promise.all(moreInfoText).then(parts => {\n          console.error(message + \"\\n\" + parts.join(\"\\n\"));\n        });\n        this.fallback();\n      }\n    },\n\n    progress(level) {\n      if (this.downloadComplete) {\n        // Don't accidentally show the loading bar again when the entire file has\n        // already been fetched (only an issue when disableAutoFetch is enabled).\n        return;\n      }\n      const percent = Math.round(level * 100);\n      // When we transition from full request to range requests, it's possible\n      // that we discard some of the loaded data. This can cause the loading\n      // bar to move backwards. So prevent this by only updating the bar if it\n      // increases.\n      if (percent > this.loadingBar.percent || isNaN(percent)) {\n        this.loadingBar.percent = percent;\n\n        // When disableAutoFetch is enabled, it's not uncommon for the entire file\n        // to never be fetched (depends on e.g. the file structure). In this case\n        // the loading bar will not be completely filled, nor will it be hidden.\n        // To prevent displaying a partially filled loading bar permanently, we\n        // hide it when no data has been loaded during a certain amount of time.\n        const disableAutoFetch = this.pdfDocument\n          ? this.pdfDocument.loadingParams.disableAutoFetch\n          : AppOptions.get(\"disableAutoFetch\");\n\n        if (disableAutoFetch && percent) {\n          if (this.disableAutoFetchLoadingBarTimeout) {\n            clearTimeout(this.disableAutoFetchLoadingBarTimeout);\n            this.disableAutoFetchLoadingBarTimeout = null;\n          }\n          this.loadingBar.show();\n\n          this.disableAutoFetchLoadingBarTimeout = setTimeout(() => {\n            this.loadingBar.hide();\n            this.disableAutoFetchLoadingBarTimeout = null;\n          }, DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT);\n        }\n      }\n    },\n\n    load(pdfDocument) {\n      this.pdfDocument = pdfDocument;\n\n      pdfDocument.getDownloadInfo().then(({ length }) => {\n        this._contentLength = length; // Ensure that the correct length is used.\n        this.downloadComplete = true;\n        this.loadingBar.hide();\n\n        firstPagePromise.then(() => {\n          this.eventBus.dispatch(\"documentloaded\", { source: this });\n        });\n      });\n\n      // Since the `setInitialView` call below depends on this being resolved,\n      // fetch it early to avoid delaying initial rendering of the PDF document.\n      const pageLayoutPromise = pdfDocument.getPageLayout().catch(function () {\n        /* Avoid breaking initial rendering; ignoring errors. */\n      });\n      const pageModePromise = pdfDocument.getPageMode().catch(function () {\n        /* Avoid breaking initial rendering; ignoring errors. */\n      });\n      const openActionPromise = pdfDocument.getOpenAction().catch(function () {\n        /* Avoid breaking initial rendering; ignoring errors. */\n      });\n\n      this.toolbar.setPagesCount(pdfDocument.numPages, false);\n      this.secondaryToolbar.setPagesCount(pdfDocument.numPages);\n\n      let baseDocumentUrl;\n      if (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) {\n        baseDocumentUrl = null;\n      } else if (PDFJSDev.test(\"MOZCENTRAL\")) {\n        baseDocumentUrl = this.baseUrl;\n      } else if (PDFJSDev.test(\"CHROME\")) {\n        baseDocumentUrl = location.href.split(\"#\")[0];\n      }\n      this.pdfLinkService.setDocument(pdfDocument, baseDocumentUrl);\n      this.pdfDocumentProperties.setDocument(pdfDocument, this.url);\n\n      const pdfViewer = this.pdfViewer;\n      pdfViewer.setDocument(pdfDocument);\n      const { firstPagePromise, onePageRendered, pagesPromise } = pdfViewer;\n\n      const pdfThumbnailViewer = this.pdfThumbnailViewer;\n      pdfThumbnailViewer.setDocument(pdfDocument);\n\n      const storedPromise = (this.store = new ViewHistory(\n        pdfDocument.fingerprint\n      ))\n        .getMultiple({\n          page: null,\n          zoom: DEFAULT_SCALE_VALUE,\n          scrollLeft: \"0\",\n          scrollTop: \"0\",\n          rotation: null,\n          sidebarView: SidebarView.UNKNOWN,\n          scrollMode: ScrollMode.UNKNOWN,\n          spreadMode: SpreadMode.UNKNOWN,\n        })\n        .catch(() => {\n          /* Unable to read from storage; ignoring errors. */\n          return Object.create(null);\n        });\n\n      firstPagePromise.then(pdfPage => {\n        this.loadingBar.setWidth(this.appConfig.viewerContainer);\n        this._initializeAnnotationStorageCallbacks(pdfDocument);\n\n        Promise.all([\n          animationStarted,\n          storedPromise,\n          pageLayoutPromise,\n          pageModePromise,\n          openActionPromise,\n        ])\n          .then(async ([timeStamp, stored, pageLayout, pageMode, openAction]) => {\n            const viewOnLoad = AppOptions.get(\"viewOnLoad\");\n\n            this._initializePdfHistory({\n              fingerprint: pdfDocument.fingerprint,\n              viewOnLoad,\n              initialDest: openAction && openAction.dest,\n            });\n            const initialBookmark = this.initialBookmark;\n\n            // Initialize the default values, from user preferences.\n            const zoom = AppOptions.get(\"defaultZoomValue\");\n            let hash = zoom ? `zoom=${zoom}` : null;\n\n            let rotation = null;\n            let sidebarView = AppOptions.get(\"sidebarViewOnLoad\");\n            let scrollMode = AppOptions.get(\"scrollModeOnLoad\");\n            let spreadMode = AppOptions.get(\"spreadModeOnLoad\");\n\n            if (stored.page && viewOnLoad !== ViewOnLoad.INITIAL) {\n              hash =\n                `page=${stored.page}&zoom=${zoom || stored.zoom},` +\n                `${stored.scrollLeft},${stored.scrollTop}`;\n\n              rotation = parseInt(stored.rotation, 10);\n              // Always let user preference take precedence over the view history.\n              if (sidebarView === SidebarView.UNKNOWN) {\n                sidebarView = stored.sidebarView | 0;\n              }\n              if (scrollMode === ScrollMode.UNKNOWN) {\n                scrollMode = stored.scrollMode | 0;\n              }\n              if (spreadMode === SpreadMode.UNKNOWN) {\n                spreadMode = stored.spreadMode | 0;\n              }\n            }\n            // Always let the user preference/view history take precedence.\n            if (pageMode && sidebarView === SidebarView.UNKNOWN) {\n              sidebarView = apiPageModeToSidebarView(pageMode);\n            }\n            if (pageLayout && spreadMode === SpreadMode.UNKNOWN) {\n              spreadMode = apiPageLayoutToSpreadMode(pageLayout);\n            }\n\n            this.setInitialView(hash, {\n              rotation,\n              sidebarView,\n              scrollMode,\n              spreadMode,\n            });\n            this.eventBus.dispatch(\"documentinit\", { source: this });\n            // Make all navigation keys work on document load,\n            // unless the viewer is embedded in a web page.\n            if (!this.isViewerEmbedded) {\n              pdfViewer.focus();\n            }\n\n            // Currently only the \"copy\"-permission is supported, hence we delay\n            // the `getPermissions` API call until *after* rendering has started.\n            this._initializePermissions(pdfDocument);\n\n            // For documents with different page sizes, once all pages are\n            // resolved, ensure that the correct location becomes visible on load.\n            // (To reduce the risk, in very large and/or slow loading documents,\n            //  that the location changes *after* the user has started interacting\n            //  with the viewer, wait for either `pagesPromise` or a timeout.)\n            await Promise.race([\n              pagesPromise,\n              new Promise(resolve => {\n                setTimeout(resolve, FORCE_PAGES_LOADED_TIMEOUT);\n              }),\n            ]);\n            if (!initialBookmark && !hash) {\n              return;\n            }\n            if (pdfViewer.hasEqualPageSizes) {\n              return;\n            }\n            this.initialBookmark = initialBookmark;\n\n            // eslint-disable-next-line no-self-assign\n            pdfViewer.currentScaleValue = pdfViewer.currentScaleValue;\n            // Re-apply the initial document location.\n            this.setInitialView(hash);\n          })\n          .catch(() => {\n            // Ensure that the document is always completely initialized,\n            // even if there are any errors thrown above.\n            this.setInitialView();\n          })\n          .then(function () {\n            // At this point, rendering of the initial page(s) should always have\n            // started (and may even have completed).\n            // To prevent any future issues, e.g. the document being completely\n            // blank on load, always trigger rendering here.\n            pdfViewer.update();\n          });\n      });\n\n      pagesPromise.then(() => {\n        this._initializeAutoPrint(pdfDocument, openActionPromise);\n      });\n\n      onePageRendered.then(() => {\n        pdfDocument.getOutline().then(outline => {\n          this.pdfOutlineViewer.render({ outline, pdfDocument });\n        });\n        pdfDocument.getAttachments().then(attachments => {\n          this.pdfAttachmentViewer.render({ attachments });\n        });\n        // Ensure that the layers accurately reflects the current state in the\n        // viewer itself, rather than the default state provided by the API.\n        pdfViewer.optionalContentConfigPromise.then(optionalContentConfig => {\n          this.pdfLayerViewer.render({ optionalContentConfig, pdfDocument });\n        });\n        if (\"requestIdleCallback\" in window) {\n          const callback = window.requestIdleCallback(\n            () => {\n              this._collectTelemetry(pdfDocument);\n              this._idleCallbacks.delete(callback);\n            },\n            { timeout: 1000 }\n          );\n          this._idleCallbacks.add(callback);\n        }\n        this._initializeJavaScript(pdfDocument);\n      });\n\n      this._initializePageLabels(pdfDocument);\n      this._initializeMetadata(pdfDocument);\n    },\n\n    /**\n     * @private\n     */\n    async _initializeJavaScript(pdfDocument) {\n      if (!AppOptions.get(\"enableScripting\")) {\n        return;\n      }\n      const [objects, calculationOrder, docActions] = await Promise.all([\n        pdfDocument.getFieldObjects(),\n        pdfDocument.getCalculationOrderIds(),\n        pdfDocument.getJSActions(),\n      ]);\n\n      if (!objects && !docActions) {\n        // No FieldObjects or JavaScript actions were found in the document.\n        return;\n      }\n      if (pdfDocument !== this.pdfDocument) {\n        return; // The document was closed while the data resolved.\n      }\n      const scripting = this.externalServices.createScripting(\n        typeof PDFJSDev === \"undefined\" ||\n          PDFJSDev.test(\"!PRODUCTION || GENERIC || CHROME\")\n          ? { sandboxBundleSrc: AppOptions.get(\"sandboxBundleSrc\") }\n          : null\n      );\n      // Store a reference to the current scripting-instance, to allow destruction\n      // of the sandbox and removal of the event listeners at document closing.\n      const internalEvents = new Map(),\n        domEvents = new Map();\n      this._scriptingInstance = {\n        scripting,\n        ready: false,\n        internalEvents,\n        domEvents,\n      };\n\n      if (!this.documentInfo) {\n        // It should be *extremely* rare for metadata to not have been resolved\n        // when this code runs, but ensure that we handle that case here.\n        await new Promise(resolve => {\n          this.eventBus._on(\n            \"metadataloaded\",\n            evt => {\n              resolve();\n            },\n            { once: true }\n          );\n        });\n        if (pdfDocument !== this.pdfDocument) {\n          return; // The document was closed while the metadata resolved.\n        }\n      }\n      if (!this._contentLength) {\n        // Always waiting for the entire PDF document to be loaded will, most\n        // likely, delay sandbox-creation too much in the general case for all\n        // PDF documents which are not provided as binary data to the API.\n        // Hence we'll simply have to trust that the `contentLength` (as provided\n        // by the server), when it exists, is accurate enough here.\n        await new Promise(resolve => {\n          this.eventBus._on(\n            \"documentloaded\",\n            evt => {\n              resolve();\n            },\n            { once: true }\n          );\n        });\n        if (pdfDocument !== this.pdfDocument) {\n          return; // The document was closed while the downloadInfo resolved.\n        }\n      }\n\n      const updateFromSandbox = ({ detail }) => {\n        const { id, command, value } = detail;\n        if (!id) {\n          switch (command) {\n            case \"clear\":\n              console.clear();\n              break;\n            case \"error\":\n              console.error(value);\n              break;\n            case \"layout\":\n              this.pdfViewer.spreadMode = apiPageLayoutToSpreadMode(value);\n              break;\n            case \"page-num\":\n              this.pdfViewer.currentPageNumber = value + 1;\n              break;\n            case \"print\":\n              this.pdfViewer.pagesPromise.then(() => {\n                this.triggerPrinting();\n              });\n              break;\n            case \"println\":\n              console.log(value);\n              break;\n            case \"zoom\":\n              this.pdfViewer.currentScaleValue = value;\n              break;\n          }\n          return;\n        }\n\n        const element = document.getElementById(id);\n        if (element) {\n          element.dispatchEvent(new CustomEvent(\"updatefromsandbox\", { detail }));\n        } else {\n          if (value !== undefined && value !== null) {\n            // The element hasn't been rendered yet, use the AnnotationStorage.\n            pdfDocument.annotationStorage.setValue(id, value);\n          }\n        }\n      };\n      internalEvents.set(\"updatefromsandbox\", updateFromSandbox);\n\n      const visitedPages = new Map();\n      const pageOpen = ({ pageNumber, actionsPromise }) => {\n        visitedPages.set(\n          pageNumber,\n          (async () => {\n            // Avoid sending, and thus serializing, the `actions` data\n            // when the same page is opened several times.\n            let actions = null;\n            if (!visitedPages.has(pageNumber)) {\n              actions = await actionsPromise;\n\n              if (pdfDocument !== this.pdfDocument) {\n                return; // The document was closed while the actions resolved.\n              }\n            }\n\n            ///await this._scriptingInstance?.scripting.dispatchEventInSandbox({ // lwf\n            await this._scriptingInstance && this._scriptingInstance.scripting.dispatchEventInSandbox({\n              id: \"page\",\n              name: \"PageOpen\",\n              pageNumber,\n              actions,\n            });\n          })()\n        );\n      };\n\n      const pageClose = async ({ pageNumber }) => {\n        const actionsPromise = visitedPages.get(pageNumber);\n        if (!actionsPromise) {\n          // Ensure that the \"pageclose\" event was preceded by a \"pageopen\" event.\n          return;\n        }\n        visitedPages.set(pageNumber, null);\n\n        // Ensure that the \"pageopen\" event is handled first.\n        await actionsPromise;\n\n        if (pdfDocument !== this.pdfDocument) {\n          return; // The document was closed while the actions resolved.\n        }\n\n        ///await this._scriptingInstance?.scripting.dispatchEventInSandbox({ // lwf\n        await this._scriptingInstance && this._scriptingInstance.scripting.dispatchEventInSandbox({\n          id: \"page\",\n          name: \"PageClose\",\n          pageNumber,\n        });\n      };\n      internalEvents.set(\"pageopen\", pageOpen);\n      internalEvents.set(\"pageclose\", pageClose);\n\n      const dispatchEventInSandbox = ({ detail }) => {\n        scripting.dispatchEventInSandbox(detail);\n      };\n      internalEvents.set(\"dispatcheventinsandbox\", dispatchEventInSandbox);\n\n      const mouseDown = event => {\n        this._mouseState.isDown = true;\n      };\n      domEvents.set(\"mousedown\", mouseDown);\n\n      const mouseUp = event => {\n        this._mouseState.isDown = false;\n      };\n      domEvents.set(\"mouseup\", mouseUp);\n\n      for (const [name, listener] of internalEvents) {\n        this.eventBus._on(name, listener);\n      }\n      for (const [name, listener] of domEvents) {\n        window.addEventListener(name, listener);\n      }\n\n      try {\n        await scripting.createSandbox({\n          objects,\n          calculationOrder,\n          appInfo: {\n            platform: navigator.platform,\n            language: navigator.language,\n          },\n          docInfo: {\n            ...this.documentInfo,\n            baseURL: this.baseUrl,\n            filesize: this._contentLength,\n            filename: this._docFilename,\n            ///metadata: this.metadata?.getRaw(), // lwf\n            metadata: this.metadata && this.metadata.getRaw(),\n            ///authors: this.metadata?.get(\"dc:creator\"), // lwf\n            authors: this.metadata && this.metadata.get(\"dc:creator\"),\n            numPages: pdfDocument.numPages,\n            URL: this.url,\n            actions: docActions,\n          },\n        });\n\n        if (this.externalServices.isInAutomation) {\n          this.eventBus.dispatch(\"sandboxcreated\", { source: this });\n        }\n      } catch (error) {\n        ///console.error(`_initializeJavaScript: \"${error?.message}\".`); // lwf\n        console.error(`_initializeJavaScript: \"${error && error.message}\".`);\n\n        this._destroyScriptingInstance();\n        return;\n      }\n\n      await scripting.dispatchEventInSandbox({\n        id: \"doc\",\n        name: \"Open\",\n      });\n      await this.pdfViewer.initializeScriptingEvents();\n\n      // Used together with the integration-tests, see the `scriptingReady`\n      // getter, to enable awaiting full initialization of the scripting/sandbox.\n      // (Defer this slightly, to make absolutely sure that everything is done.)\n      Promise.resolve().then(() => {\n        if (this._scriptingInstance) {\n          this._scriptingInstance.ready = true;\n        }\n      });\n    },\n\n    /**\n     * A place to fetch data for telemetry after one page is rendered and the\n     * viewer is idle.\n     * @private\n     */\n    async _collectTelemetry(pdfDocument) {\n      const markInfo = await this.pdfDocument.getMarkInfo();\n      if (pdfDocument !== this.pdfDocument) {\n        return; // Document was closed while waiting for mark info.\n      }\n      ///const tagged = markInfo?.Marked || false; // lwf\n      const tagged = markInfo && markInfo.Marked || false;\n      this.externalServices.reportTelemetry({\n        type: \"tagged\",\n        tagged,\n      });\n    },\n\n    /**\n     * @private\n     */\n    async _initializeAutoPrint(pdfDocument, openActionPromise) {\n      const [openAction, javaScript] = await Promise.all([\n        openActionPromise,\n        !AppOptions.get(\"enableScripting\") ? pdfDocument.getJavaScript() : null,\n      ]);\n\n      if (pdfDocument !== this.pdfDocument) {\n        return; // The document was closed while the auto print data resolved.\n      }\n      let triggerAutoPrint = false;\n\n      ///if (openAction?.action === \"Print\") { // lwf\n      if (openAction && openAction.action === \"Print\") {\n        triggerAutoPrint = true;\n      }\n      if (javaScript) {\n        javaScript.some(js => {\n          if (!js) {\n            // Don't warn/fallback for empty JavaScript actions.\n            return false;\n          }\n          console.warn(\"Warning: JavaScript is not supported\");\n          this._delayedFallback(UNSUPPORTED_FEATURES.javaScript);\n          return true;\n        });\n\n        if (!triggerAutoPrint) {\n          // Hack to support auto printing.\n          for (const js of javaScript) {\n            if (js && AutoPrintRegExp.test(js)) {\n              triggerAutoPrint = true;\n              break;\n            }\n          }\n        }\n      }\n\n      if (triggerAutoPrint) {\n        this.triggerPrinting();\n      }\n    },\n\n    /**\n     * @private\n     */\n    async _initializeMetadata(pdfDocument) {\n      const {\n        info,\n        metadata,\n        contentDispositionFilename,\n        contentLength,\n      } = await pdfDocument.getMetadata();\n\n      if (pdfDocument !== this.pdfDocument) {\n        return; // The document was closed while the metadata resolved.\n      }\n      this.documentInfo = info;\n      this.metadata = metadata;\n      this._contentDispositionFilename = contentDispositionFilename;\n      //this._contentLength ??= contentLength; // See `getDownloadInfo`-call above. // lwf\n      this._contentLength ||  (this._contentLength = contentLength);\n\n      // Provides some basic debug information\n      console.log(\n        `PDF ${pdfDocument.fingerprint} [${info.PDFFormatVersion} ` +\n          `${(info.Producer || \"-\").trim()} / ${(info.Creator || \"-\").trim()}] ` +\n          `(PDF.js: ${version || \"-\"}` +\n          `${this.pdfViewer.enableWebGL ? \" [WebGL]\" : \"\"})`\n      );\n\n      let pdfTitle;\n      const infoTitle = info && info.Title;\n      if (infoTitle) {\n        pdfTitle = infoTitle;\n      }\n      const metadataTitle = metadata && metadata.get(\"dc:title\");\n      if (metadataTitle) {\n        // Ghostscript can produce invalid 'dc:title' Metadata entries:\n        //  - The title may be \"Untitled\" (fixes bug 1031612).\n        //  - The title may contain incorrectly encoded characters, which thus\n        //    looks broken, hence we ignore the Metadata entry when it\n        //    contains characters from the Specials Unicode block\n        //    (fixes bug 1605526).\n        if (\n          metadataTitle !== \"Untitled\" &&\n          !/[\\uFFF0-\\uFFFF]/g.test(metadataTitle)\n        ) {\n          pdfTitle = metadataTitle;\n        }\n      }\n      if (pdfTitle) {\n        this.setTitle(\n          `${pdfTitle} - ${contentDispositionFilename || document.title}`\n        );\n      } else if (contentDispositionFilename) {\n        this.setTitle(contentDispositionFilename);\n      }\n\n      if (info.IsXFAPresent && !info.IsAcroFormPresent) {\n        console.warn(\"Warning: XFA is not supported\");\n        this._delayedFallback(UNSUPPORTED_FEATURES.forms);\n      } else if (\n        (info.IsAcroFormPresent || info.IsXFAPresent) &&\n        !this.pdfViewer.renderInteractiveForms\n      ) {\n        console.warn(\"Warning: Interactive form support is not enabled\");\n        this._delayedFallback(UNSUPPORTED_FEATURES.forms);\n      }\n\n      // Telemetry labels must be C++ variable friendly.\n      let versionId = \"other\";\n      if (KNOWN_VERSIONS.includes(info.PDFFormatVersion)) {\n        versionId = `v${info.PDFFormatVersion.replace(\".\", \"_\")}`;\n      }\n      let generatorId = \"other\";\n      if (info.Producer) {\n        const producer = info.Producer.toLowerCase();\n        KNOWN_GENERATORS.some(function (generator) {\n          if (!producer.includes(generator)) {\n            return false;\n          }\n          generatorId = generator.replace(/[ .-]/g, \"_\");\n          return true;\n        });\n      }\n      let formType = null;\n      if (info.IsXFAPresent) {\n        formType = \"xfa\";\n      } else if (info.IsAcroFormPresent) {\n        formType = \"acroform\";\n      }\n      this.externalServices.reportTelemetry({\n        type: \"documentInfo\",\n        version: versionId,\n        generator: generatorId,\n        formType,\n      });\n\n      this.eventBus.dispatch(\"metadataloaded\", { source: this });\n    },\n\n    /**\n     * @private\n     */\n    async _initializePageLabels(pdfDocument) {\n      const labels = await pdfDocument.getPageLabels();\n\n      if (pdfDocument !== this.pdfDocument) {\n        return; // The document was closed while the page labels resolved.\n      }\n      if (!labels || AppOptions.get(\"disablePageLabels\")) {\n        return;\n      }\n      const numLabels = labels.length;\n      if (numLabels !== this.pagesCount) {\n        console.error(\n          \"The number of Page Labels does not match the number of pages in the document.\"\n        );\n        return;\n      }\n      let i = 0;\n      // Ignore page labels that correspond to standard page numbering.\n      while (i < numLabels && labels[i] === (i + 1).toString()) {\n        i++;\n      }\n      if (i === numLabels) {\n        return;\n      }\n      const { pdfViewer, pdfThumbnailViewer, toolbar } = this;\n\n      pdfViewer.setPageLabels(labels);\n      pdfThumbnailViewer.setPageLabels(labels);\n\n      // Changing toolbar page display to use labels and we need to set\n      // the label of the current page.\n      toolbar.setPagesCount(numLabels, true);\n      toolbar.setPageNumber(\n        pdfViewer.currentPageNumber,\n        pdfViewer.currentPageLabel\n      );\n    },\n\n    /**\n     * @private\n     */\n    _initializePdfHistory({ fingerprint, viewOnLoad, initialDest = null }) {\n      if (this.isViewerEmbedded || AppOptions.get(\"disableHistory\")) {\n        // The browsing history is only enabled when the viewer is standalone,\n        // i.e. not when it is embedded in a web page.\n        return;\n      }\n      this.pdfHistory.initialize({\n        fingerprint,\n        resetHistory: viewOnLoad === ViewOnLoad.INITIAL,\n        updateUrl: AppOptions.get(\"historyUpdateUrl\"),\n      });\n\n      if (this.pdfHistory.initialBookmark) {\n        this.initialBookmark = this.pdfHistory.initialBookmark;\n\n        this.initialRotation = this.pdfHistory.initialRotation;\n      }\n\n      // Always let the browser history/document hash take precedence.\n      if (\n        initialDest &&\n        !this.initialBookmark &&\n        viewOnLoad === ViewOnLoad.UNKNOWN\n      ) {\n        this.initialBookmark = JSON.stringify(initialDest);\n        // TODO: Re-factor the `PDFHistory` initialization to remove this hack\n        // that's currently necessary to prevent weird initial history state.\n        this.pdfHistory.push({ explicitDest: initialDest, pageNumber: null });\n      }\n    },\n\n    /**\n     * @private\n     */\n    async _initializePermissions(pdfDocument) {\n      const permissions = await pdfDocument.getPermissions();\n\n      if (pdfDocument !== this.pdfDocument) {\n        return; // The document was closed while the permissions resolved.\n      }\n      if (!permissions || !AppOptions.get(\"enablePermissions\")) {\n        return;\n      }\n      // Currently only the \"copy\"-permission is supported.\n      if (!permissions.includes(PermissionFlag.COPY)) {\n        this.appConfig.viewerContainer.classList.add(ENABLE_PERMISSIONS_CLASS);\n      }\n    },\n\n    /**\n     * @private\n     */\n    _initializeAnnotationStorageCallbacks(pdfDocument) {\n      if (pdfDocument !== this.pdfDocument) {\n        return;\n      }\n      const { annotationStorage } = pdfDocument;\n\n      annotationStorage.onSetModified = function () {\n        window.addEventListener(\"beforeunload\", beforeUnload);\n      };\n      annotationStorage.onResetModified = function () {\n        window.removeEventListener(\"beforeunload\", beforeUnload);\n      };\n    },\n\n    setInitialView(\n      storedHash,\n      { rotation, sidebarView, scrollMode, spreadMode } = {}\n    ) {\n      const setRotation = angle => {\n        if (isValidRotation(angle)) {\n          this.pdfViewer.pagesRotation = angle;\n        }\n      };\n      const setViewerModes = (scroll, spread) => {\n        if (isValidScrollMode(scroll)) {\n          this.pdfViewer.scrollMode = scroll;\n        }\n        if (isValidSpreadMode(spread)) {\n          this.pdfViewer.spreadMode = spread;\n        }\n      };\n      this.isInitialViewSet = true;\n      this.pdfSidebar.setInitialView(sidebarView);\n\n      setViewerModes(scrollMode, spreadMode);\n\n      if (this.initialBookmark) {\n        setRotation(this.initialRotation);\n        delete this.initialRotation;\n\n        this.pdfLinkService.setHash(this.initialBookmark);\n        this.initialBookmark = null;\n      } else if (storedHash) {\n        setRotation(rotation);\n\n        this.pdfLinkService.setHash(storedHash);\n      }\n\n      // Ensure that the correct page number is displayed in the UI,\n      // even if the active page didn't change during document load.\n      this.toolbar.setPageNumber(\n        this.pdfViewer.currentPageNumber,\n        this.pdfViewer.currentPageLabel\n      );\n      this.secondaryToolbar.setPageNumber(this.pdfViewer.currentPageNumber);\n\n      if (!this.pdfViewer.currentScaleValue) {\n        // Scale was not initialized: invalid bookmark or scale was not specified.\n        // Setting the default one.\n        this.pdfViewer.currentScaleValue = DEFAULT_SCALE_VALUE;\n      }\n    },\n\n    cleanup() {\n      if (!this.pdfDocument) {\n        return; // run cleanup when document is loaded\n      }\n      this.pdfViewer.cleanup();\n      this.pdfThumbnailViewer.cleanup();\n\n      // We don't want to remove fonts used by active page SVGs.\n      if (this.pdfViewer.renderer !== RendererType.SVG) {\n        this.pdfDocument.cleanup();\n      }\n    },\n\n    forceRendering() {\n      this.pdfRenderingQueue.printing = !!this.printService;\n      this.pdfRenderingQueue.isThumbnailViewEnabled = this.pdfSidebar.isThumbnailViewVisible;\n      this.pdfRenderingQueue.renderHighestPriority();\n    },\n\n    beforePrint() {\n      // Given that the \"beforeprint\" browser event is synchronous, we\n      // unfortunately cannot await the scripting event dispatching here.\n      ///this._scriptingInstance?.scripting.dispatchEventInSandbox({ // lwf\n      this._scriptingInstance && this._scriptingInstance.scripting.dispatchEventInSandbox({\n        id: \"doc\",\n        name: \"WillPrint\",\n      });\n\n      if (this.printService) {\n        // There is no way to suppress beforePrint/afterPrint events,\n        // but PDFPrintService may generate double events -- this will ignore\n        // the second event that will be coming from native window.print().\n        return;\n      }\n\n      if (!this.supportsPrinting) {\n        this.l10n\n          .get(\n            \"printing_not_supported\",\n            null,\n            \"Warning: Printing is not fully supported by this browser.\"\n          )\n          .then(printMessage => {\n            this.error(printMessage);\n          });\n        return;\n      }\n\n      // The beforePrint is a sync method and we need to know layout before\n      // returning from this method. Ensure that we can get sizes of the pages.\n      if (!this.pdfViewer.pageViewsReady) {\n        this.l10n\n          .get(\n            \"printing_not_ready\",\n            null,\n            \"Warning: The PDF is not fully loaded for printing.\"\n          )\n          .then(notReadyMessage => {\n            // eslint-disable-next-line no-alert\n            window.alert(notReadyMessage);\n          });\n        return;\n      }\n\n      const pagesOverview = this.pdfViewer.getPagesOverview();\n      const printContainer = this.appConfig.printContainer;\n      const printResolution = AppOptions.get(\"printResolution\");\n      const optionalContentConfigPromise = this.pdfViewer\n        .optionalContentConfigPromise;\n\n      const printService = PDFPrintServiceFactory.instance.createPrintService(\n        this.pdfDocument,\n        pagesOverview,\n        printContainer,\n        printResolution,\n        optionalContentConfigPromise,\n        this.l10n\n      );\n      this.printService = printService;\n      this.forceRendering();\n\n      printService.layout();\n\n      this.externalServices.reportTelemetry({\n        type: \"print\",\n      });\n    },\n\n    afterPrint() {\n      // Given that the \"afterprint\" browser event is synchronous, we\n      // unfortunately cannot await the scripting event dispatching here.\n      ///this._scriptingInstance?.scripting.dispatchEventInSandbox({ // lwf\n      this._scriptingInstance && this._scriptingInstance.scripting.dispatchEventInSandbox({\n        id: \"doc\",\n        name: \"DidPrint\",\n      });\n\n      if (this.printService) {\n        this.printService.destroy();\n        this.printService = null;\n\n        if (this.pdfDocument) {\n          this.pdfDocument.annotationStorage.resetModified();\n        }\n      }\n      this.forceRendering();\n    },\n\n    rotatePages(delta) {\n      if (!this.pdfDocument) {\n        return;\n      }\n      const newRotation = (this.pdfViewer.pagesRotation + 360 + delta) % 360;\n      this.pdfViewer.pagesRotation = newRotation;\n      // Note that the thumbnail viewer is updated, and rendering is triggered,\n      // in the 'rotationchanging' event handler.\n    },\n\n    requestPresentationMode() {\n      if (!this.pdfPresentationMode) {\n        return;\n      }\n      this.pdfPresentationMode.request();\n    },\n\n    triggerPrinting() {\n      if (!this.supportsPrinting) {\n        return;\n      }\n      window.print();\n    },\n\n    bindEvents() {\n      const { eventBus, _boundEvents } = this;\n\n      _boundEvents.beforePrint = this.beforePrint.bind(this);\n      _boundEvents.afterPrint = this.afterPrint.bind(this);\n\n      eventBus._on(\"resize\", webViewerResize);\n      eventBus._on(\"hashchange\", webViewerHashchange);\n      eventBus._on(\"beforeprint\", _boundEvents.beforePrint);\n      eventBus._on(\"afterprint\", _boundEvents.afterPrint);\n      eventBus._on(\"pagerendered\", webViewerPageRendered);\n      eventBus._on(\"updateviewarea\", webViewerUpdateViewarea);\n      eventBus._on(\"pagechanging\", webViewerPageChanging);\n      eventBus._on(\"scalechanging\", webViewerScaleChanging);\n      eventBus._on(\"rotationchanging\", webViewerRotationChanging);\n      eventBus._on(\"sidebarviewchanged\", webViewerSidebarViewChanged);\n      eventBus._on(\"pagemode\", webViewerPageMode);\n      eventBus._on(\"namedaction\", webViewerNamedAction);\n      eventBus._on(\"presentationmodechanged\", webViewerPresentationModeChanged);\n      eventBus._on(\"presentationmode\", webViewerPresentationMode);\n      eventBus._on(\"print\", webViewerPrint);\n      eventBus._on(\"download\", webViewerDownload);\n      eventBus._on(\"save\", webViewerSave);\n      eventBus._on(\"firstpage\", webViewerFirstPage);\n      eventBus._on(\"lastpage\", webViewerLastPage);\n      eventBus._on(\"nextpage\", webViewerNextPage);\n      eventBus._on(\"previouspage\", webViewerPreviousPage);\n      eventBus._on(\"zoomin\", webViewerZoomIn);\n      eventBus._on(\"zoomout\", webViewerZoomOut);\n      eventBus._on(\"zoomreset\", webViewerZoomReset);\n      eventBus._on(\"pagenumberchanged\", webViewerPageNumberChanged);\n      eventBus._on(\"scalechanged\", webViewerScaleChanged);\n      eventBus._on(\"rotatecw\", webViewerRotateCw);\n      eventBus._on(\"rotateccw\", webViewerRotateCcw);\n      eventBus._on(\"optionalcontentconfig\", webViewerOptionalContentConfig);\n      eventBus._on(\"switchscrollmode\", webViewerSwitchScrollMode);\n      eventBus._on(\"scrollmodechanged\", webViewerScrollModeChanged);\n      eventBus._on(\"switchspreadmode\", webViewerSwitchSpreadMode);\n      eventBus._on(\"spreadmodechanged\", webViewerSpreadModeChanged);\n      eventBus._on(\"documentproperties\", webViewerDocumentProperties);\n      eventBus._on(\"find\", webViewerFind);\n      eventBus._on(\"findfromurlhash\", webViewerFindFromUrlHash);\n      eventBus._on(\"updatefindmatchescount\", webViewerUpdateFindMatchesCount);\n      eventBus._on(\"updatefindcontrolstate\", webViewerUpdateFindControlState);\n\n      if (AppOptions.get(\"pdfBug\")) {\n        _boundEvents.reportPageStatsPDFBug = reportPageStatsPDFBug;\n\n        eventBus._on(\"pagerendered\", _boundEvents.reportPageStatsPDFBug);\n        eventBus._on(\"pagechanging\", _boundEvents.reportPageStatsPDFBug);\n      }\n      if (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) {\n        eventBus._on(\"fileinputchange\", webViewerFileInputChange);\n        eventBus._on(\"openfile\", webViewerOpenFile);\n      }\n    },\n\n    bindWindowEvents() {\n      const { eventBus, _boundEvents } = this;\n\n      _boundEvents.windowResize = () => {\n        eventBus.dispatch(\"resize\", { source: window });\n      };\n      _boundEvents.windowHashChange = () => {\n        eventBus.dispatch(\"hashchange\", {\n          source: window,\n          hash: document.location.hash.substring(1),\n        });\n      };\n      _boundEvents.windowBeforePrint = () => {\n        eventBus.dispatch(\"beforeprint\", { source: window });\n      };\n      _boundEvents.windowAfterPrint = () => {\n        eventBus.dispatch(\"afterprint\", { source: window });\n      };\n      _boundEvents.windowUpdateFromSandbox = event => {\n        eventBus.dispatch(\"updatefromsandbox\", {\n          source: window,\n          detail: event.detail,\n        });\n      };\n\n      window.addEventListener(\"visibilitychange\", webViewerVisibilityChange);\n      window.addEventListener(\"wheel\", webViewerWheel, { passive: false });\n      window.addEventListener(\"touchstart\", webViewerTouchStart, {\n        passive: false,\n      });\n      window.addEventListener(\"click\", webViewerClick);\n      window.addEventListener(\"keydown\", webViewerKeyDown);\n      window.addEventListener(\"keyup\", webViewerKeyUp);\n      window.addEventListener(\"resize\", _boundEvents.windowResize);\n      window.addEventListener(\"hashchange\", _boundEvents.windowHashChange);\n      window.addEventListener(\"beforeprint\", _boundEvents.windowBeforePrint);\n      window.addEventListener(\"afterprint\", _boundEvents.windowAfterPrint);\n      window.addEventListener(\n        \"updatefromsandbox\",\n        _boundEvents.windowUpdateFromSandbox\n      );\n    },\n\n    unbindEvents() {\n      const { eventBus, _boundEvents } = this;\n\n      eventBus._off(\"resize\", webViewerResize);\n      eventBus._off(\"hashchange\", webViewerHashchange);\n      eventBus._off(\"beforeprint\", _boundEvents.beforePrint);\n      eventBus._off(\"afterprint\", _boundEvents.afterPrint);\n      eventBus._off(\"pagerendered\", webViewerPageRendered);\n      eventBus._off(\"updateviewarea\", webViewerUpdateViewarea);\n      eventBus._off(\"pagechanging\", webViewerPageChanging);\n      eventBus._off(\"scalechanging\", webViewerScaleChanging);\n      eventBus._off(\"rotationchanging\", webViewerRotationChanging);\n      eventBus._off(\"sidebarviewchanged\", webViewerSidebarViewChanged);\n      eventBus._off(\"pagemode\", webViewerPageMode);\n      eventBus._off(\"namedaction\", webViewerNamedAction);\n      eventBus._off(\"presentationmodechanged\", webViewerPresentationModeChanged);\n      eventBus._off(\"presentationmode\", webViewerPresentationMode);\n      eventBus._off(\"print\", webViewerPrint);\n      eventBus._off(\"download\", webViewerDownload);\n      eventBus._off(\"save\", webViewerSave);\n      eventBus._off(\"firstpage\", webViewerFirstPage);\n      eventBus._off(\"lastpage\", webViewerLastPage);\n      eventBus._off(\"nextpage\", webViewerNextPage);\n      eventBus._off(\"previouspage\", webViewerPreviousPage);\n      eventBus._off(\"zoomin\", webViewerZoomIn);\n      eventBus._off(\"zoomout\", webViewerZoomOut);\n      eventBus._off(\"zoomreset\", webViewerZoomReset);\n      eventBus._off(\"pagenumberchanged\", webViewerPageNumberChanged);\n      eventBus._off(\"scalechanged\", webViewerScaleChanged);\n      eventBus._off(\"rotatecw\", webViewerRotateCw);\n      eventBus._off(\"rotateccw\", webViewerRotateCcw);\n      eventBus._off(\"optionalcontentconfig\", webViewerOptionalContentConfig);\n      eventBus._off(\"switchscrollmode\", webViewerSwitchScrollMode);\n      eventBus._off(\"scrollmodechanged\", webViewerScrollModeChanged);\n      eventBus._off(\"switchspreadmode\", webViewerSwitchSpreadMode);\n      eventBus._off(\"spreadmodechanged\", webViewerSpreadModeChanged);\n      eventBus._off(\"documentproperties\", webViewerDocumentProperties);\n      eventBus._off(\"find\", webViewerFind);\n      eventBus._off(\"findfromurlhash\", webViewerFindFromUrlHash);\n      eventBus._off(\"updatefindmatchescount\", webViewerUpdateFindMatchesCount);\n      eventBus._off(\"updatefindcontrolstate\", webViewerUpdateFindControlState);\n\n      if (_boundEvents.reportPageStatsPDFBug) {\n        eventBus._off(\"pagerendered\", _boundEvents.reportPageStatsPDFBug);\n        eventBus._off(\"pagechanging\", _boundEvents.reportPageStatsPDFBug);\n\n        _boundEvents.reportPageStatsPDFBug = null;\n      }\n      if (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) {\n        eventBus._off(\"fileinputchange\", webViewerFileInputChange);\n        eventBus._off(\"openfile\", webViewerOpenFile);\n      }\n\n      _boundEvents.beforePrint = null;\n      _boundEvents.afterPrint = null;\n    },\n\n    unbindWindowEvents() {\n      const { _boundEvents } = this;\n\n      window.removeEventListener(\"visibilitychange\", webViewerVisibilityChange);\n      window.removeEventListener(\"wheel\", webViewerWheel, { passive: false });\n      window.removeEventListener(\"touchstart\", webViewerTouchStart, {\n        passive: false,\n      });\n      window.removeEventListener(\"click\", webViewerClick);\n      window.removeEventListener(\"keydown\", webViewerKeyDown);\n      window.removeEventListener(\"keyup\", webViewerKeyUp);\n      window.removeEventListener(\"resize\", _boundEvents.windowResize);\n      window.removeEventListener(\"hashchange\", _boundEvents.windowHashChange);\n      window.removeEventListener(\"beforeprint\", _boundEvents.windowBeforePrint);\n      window.removeEventListener(\"afterprint\", _boundEvents.windowAfterPrint);\n      window.removeEventListener(\n        \"updatefromsandbox\",\n        _boundEvents.windowUpdateFromSandbox\n      );\n\n      _boundEvents.windowResize = null;\n      _boundEvents.windowHashChange = null;\n      _boundEvents.windowBeforePrint = null;\n      _boundEvents.windowAfterPrint = null;\n      _boundEvents.windowUpdateFromSandbox = null;\n    },\n\n    accumulateWheelTicks(ticks) {\n      // If the scroll direction changed, reset the accumulated wheel ticks.\n      if (\n        (this._wheelUnusedTicks > 0 && ticks < 0) ||\n        (this._wheelUnusedTicks < 0 && ticks > 0)\n      ) {\n        this._wheelUnusedTicks = 0;\n      }\n      this._wheelUnusedTicks += ticks;\n      const wholeTicks =\n        Math.sign(this._wheelUnusedTicks) *\n        Math.floor(Math.abs(this._wheelUnusedTicks));\n      this._wheelUnusedTicks -= wholeTicks;\n      return wholeTicks;\n    },\n\n    /**\n     * Used together with the integration-tests, to enable awaiting full\n     * initialization of the scripting/sandbox.\n     */\n    get scriptingReady() {\n      ///return this._scriptingInstance?.ready || false; // lwf\n      return this._scriptingInstance && this._scriptingInstance.ready || false;\n    },\n  };\n\n  let validateFileURL;\n  if (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) {\n    const HOSTED_VIEWER_ORIGINS = [\n      \"null\",\n      \"http://mozilla.github.io\",\n      \"https://mozilla.github.io\",\n    ];\n    validateFileURL = function (file) {\n      if (file === undefined) {\n        return;\n      }\n      try {\n        const viewerOrigin = new URL(window.location.href).origin || \"null\";\n        if (HOSTED_VIEWER_ORIGINS.includes(viewerOrigin)) {\n          // Hosted or local viewer, allow for any file locations\n          return;\n        }\n        const { origin, protocol } = new URL(file, window.location.href);\n        // Removing of the following line will not guarantee that the viewer will\n        // start accepting URLs from foreign origin -- CORS headers on the remote\n        // server must be properly configured.\n        // IE10 / IE11 does not include an origin in `blob:`-URLs. So don't block\n        // any blob:-URL. The browser's same-origin policy will block requests to\n        // blob:-URLs from other origins, so this is safe.\n        if (origin !== viewerOrigin && protocol !== \"blob:\") {\n          throw new Error(\"file origin does not match viewer's\");\n        }\n      } catch (ex) {\n        const message = ex && ex.message;\n        PDFViewerApplication.l10n\n          .get(\"loading_error\", null, \"An error occurred while loading the PDF.\")\n          .then(loadingErrorMessage => {\n            PDFViewerApplication.error(loadingErrorMessage, { message });\n          });\n        throw ex;\n      }\n    };\n  }\n\n  async function loadFakeWorker() {\n    if (!GlobalWorkerOptions.workerSrc) {\n      GlobalWorkerOptions.workerSrc = AppOptions.get(\"workerSrc\");\n    }\n    if (typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"PRODUCTION\")) {\n      window.pdfjsWorker = await import(\"pdfjs/core/worker.js\");\n      return undefined;\n    }\n    return loadScript(PDFWorker.getWorkerSrc());\n  }\n\n  function loadAndEnablePDFBug(enabledTabs) {\n    const appConfig = PDFViewerApplication.appConfig;\n    return loadScript(appConfig.debuggerScriptPath).then(function () {\n      PDFBug.enable(enabledTabs);\n      PDFBug.init({ OPS }, appConfig.mainContainer);\n    });\n  }\n\n  function reportPageStatsPDFBug({ pageNumber }) {\n    if (typeof Stats === \"undefined\" || !Stats.enabled) {\n      return;\n    }\n    const pageView = PDFViewerApplication.pdfViewer.getPageView(\n      /* index = */ pageNumber - 1\n    );\n    const pageStats = pageView && pageView.pdfPage && pageView.pdfPage.stats;\n    if (!pageStats) {\n      return;\n    }\n    Stats.add(pageNumber, pageStats);\n  }\n\n  function webViewerInitialized() {\n    const appConfig = PDFViewerApplication.appConfig;\n    let file;\n    if (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) {\n      const queryString = document.location.search.substring(1);\n      const params = parseQueryString(queryString);\n      file = \"file\" in params ? params.file : AppOptions.get(\"defaultUrl\");\n      validateFileURL(file);\n    } else if (PDFJSDev.test(\"MOZCENTRAL\")) {\n      file = window.location.href;\n    } else if (PDFJSDev.test(\"CHROME\")) {\n      file = AppOptions.get(\"defaultUrl\");\n    }\n\n    if (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) {\n      const fileInput = document.createElement(\"input\");\n      fileInput.id = appConfig.openFileInputName;\n      fileInput.className = \"fileInput\";\n      fileInput.setAttribute(\"type\", \"file\");\n      fileInput.oncontextmenu = noContextMenuHandler;\n      document.body.appendChild(fileInput);\n\n      if (\n        !window.File ||\n        !window.FileReader ||\n        !window.FileList ||\n        !window.Blob\n      ) {\n        appConfig.toolbar.openFile.setAttribute(\"hidden\", \"true\");\n        appConfig.secondaryToolbar.openFileButton.setAttribute(\"hidden\", \"true\");\n      } else {\n        fileInput.value = null;\n      }\n\n      fileInput.addEventListener(\"change\", function (evt) {\n        const files = evt.target.files;\n        if (!files || files.length === 0) {\n          return;\n        }\n        PDFViewerApplication.eventBus.dispatch(\"fileinputchange\", {\n          source: this,\n          fileInput: evt.target,\n        });\n      });\n\n      // Enable dragging-and-dropping a new PDF file onto the viewerContainer.\n      appConfig.mainContainer.addEventListener(\"dragover\", function (evt) {\n        evt.preventDefault();\n\n        evt.dataTransfer.dropEffect = \"move\";\n      });\n      appConfig.mainContainer.addEventListener(\"drop\", function (evt) {\n        evt.preventDefault();\n\n        const files = evt.dataTransfer.files;\n        if (!files || files.length === 0) {\n          return;\n        }\n        PDFViewerApplication.eventBus.dispatch(\"fileinputchange\", {\n          source: this,\n          fileInput: evt.dataTransfer,\n        });\n      });\n    } else {\n      appConfig.toolbar.openFile.setAttribute(\"hidden\", \"true\");\n      appConfig.secondaryToolbar.openFileButton.setAttribute(\"hidden\", \"true\");\n    }\n\n    if (!PDFViewerApplication.supportsDocumentFonts) {\n      AppOptions.set(\"disableFontFace\", true);\n      PDFViewerApplication.l10n\n        .get(\n          \"web_fonts_disabled\",\n          null,\n          \"Web fonts are disabled: unable to use embedded PDF fonts.\"\n        )\n        .then(msg => {\n          console.warn(msg);\n        });\n    }\n\n    if (!PDFViewerApplication.supportsPrinting) {\n      appConfig.toolbar.print.classList.add(\"hidden\");\n      appConfig.secondaryToolbar.printButton.classList.add(\"hidden\");\n    }\n\n    if (!PDFViewerApplication.supportsFullscreen) {\n      appConfig.toolbar.presentationModeButton.classList.add(\"hidden\");\n      appConfig.secondaryToolbar.presentationModeButton.classList.add(\"hidden\");\n    }\n\n    if (PDFViewerApplication.supportsIntegratedFind) {\n      appConfig.toolbar.viewFind.classList.add(\"hidden\");\n    }\n\n    appConfig.mainContainer.addEventListener(\n      \"transitionend\",\n      function (evt) {\n        if (evt.target === /* mainContainer */ this) {\n          PDFViewerApplication.eventBus.dispatch(\"resize\", { source: this });\n        }\n      },\n      true\n    );\n\n    try {\n      webViewerOpenFileViaURL(file);\n    } catch (reason) {\n      PDFViewerApplication.l10n\n        .get(\"loading_error\", null, \"An error occurred while loading the PDF.\")\n        .then(msg => {\n          PDFViewerApplication.error(msg, reason);\n        });\n    }\n  }\n\n  let webViewerOpenFileViaURL;\n  if (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) {\n    webViewerOpenFileViaURL = function (file) {\n      if (file && file.lastIndexOf(\"file:\", 0) === 0) {\n        // file:-scheme. Load the contents in the main thread because QtWebKit\n        // cannot load file:-URLs in a Web Worker. file:-URLs are usually loaded\n        // very quickly, so there is no need to set up progress event listeners.\n        PDFViewerApplication.setTitleUsingUrl(file);\n        const xhr = new XMLHttpRequest();\n        xhr.onload = function () {\n          PDFViewerApplication.open(new Uint8Array(xhr.response));\n        };\n        xhr.open(\"GET\", file);\n        xhr.responseType = \"arraybuffer\";\n        xhr.send();\n        return;\n      }\n\n      if (file) {\n        PDFViewerApplication.open(file);\n      }\n    };\n  } else if (PDFJSDev.test(\"MOZCENTRAL || CHROME\")) {\n    webViewerOpenFileViaURL = function (file) {\n      PDFViewerApplication.setTitleUsingUrl(file);\n      PDFViewerApplication.initPassiveLoading();\n    };\n  } else {\n    webViewerOpenFileViaURL = function (file) {\n      if (file) {\n        throw new Error(\"Not implemented: webViewerOpenFileViaURL\");\n      }\n    };\n  }\n\n  function webViewerResetPermissions() {\n    const { appConfig } = PDFViewerApplication;\n    if (!appConfig) {\n      return;\n    }\n    // Currently only the \"copy\"-permission is supported.\n    appConfig.viewerContainer.classList.remove(ENABLE_PERMISSIONS_CLASS);\n  }\n\n  function webViewerPageRendered({ pageNumber, timestamp, error }) {\n    // If the page is still visible when it has finished rendering,\n    // ensure that the page number input loading indicator is hidden.\n    if (pageNumber === PDFViewerApplication.page) {\n      PDFViewerApplication.toolbar.updateLoadingIndicatorState(false);\n    }\n\n    // Use the rendered page to set the corresponding thumbnail image.\n    if (PDFViewerApplication.pdfSidebar.isThumbnailViewVisible) {\n      const pageView = PDFViewerApplication.pdfViewer.getPageView(\n        /* index = */ pageNumber - 1\n      );\n      const thumbnailView = PDFViewerApplication.pdfThumbnailViewer.getThumbnail(\n        /* index = */ pageNumber - 1\n      );\n      if (pageView && thumbnailView) {\n        thumbnailView.setImage(pageView);\n      }\n    }\n\n    if (error) {\n      PDFViewerApplication.l10n\n        .get(\n          \"rendering_error\",\n          null,\n          \"An error occurred while rendering the page.\"\n        )\n        .then(msg => {\n          PDFViewerApplication.error(msg, error);\n        });\n    }\n\n    PDFViewerApplication.externalServices.reportTelemetry({\n      type: \"pageInfo\",\n      timestamp,\n    });\n    // It is a good time to report stream and font types.\n    PDFViewerApplication.pdfDocument.getStats().then(function (stats) {\n      PDFViewerApplication.externalServices.reportTelemetry({\n        type: \"documentStats\",\n        stats,\n      });\n    });\n  }\n\n  function webViewerPageMode({ mode }) {\n    // Handle the 'pagemode' hash parameter, see also `PDFLinkService_setHash`.\n    let view;\n    switch (mode) {\n      case \"thumbs\":\n        view = SidebarView.THUMBS;\n        break;\n      case \"bookmarks\":\n      case \"outline\": // non-standard\n        view = SidebarView.OUTLINE;\n        break;\n      case \"attachments\": // non-standard\n        view = SidebarView.ATTACHMENTS;\n        break;\n      case \"layers\": // non-standard\n        view = SidebarView.LAYERS;\n        break;\n      case \"none\":\n        view = SidebarView.NONE;\n        break;\n      default:\n        console.error('Invalid \"pagemode\" hash parameter: ' + mode);\n        return;\n    }\n    PDFViewerApplication.pdfSidebar.switchView(view, /* forceOpen = */ true);\n  }\n\n  function webViewerNamedAction(evt) {\n    // Processing a couple of named actions that might be useful, see also\n    // `PDFLinkService.executeNamedAction`.\n    switch (evt.action) {\n      case \"GoToPage\":\n        PDFViewerApplication.appConfig.toolbar.pageNumber.select();\n        break;\n\n      case \"Find\":\n        if (!PDFViewerApplication.supportsIntegratedFind) {\n          PDFViewerApplication.findBar.toggle();\n        }\n        break;\n\n      case \"Print\":\n        PDFViewerApplication.triggerPrinting();\n        break;\n\n      case \"SaveAs\":\n        webViewerSave();\n        break;\n    }\n  }\n\n  function webViewerPresentationModeChanged(evt) {\n    PDFViewerApplication.pdfViewer.presentationModeState = evt.state;\n  }\n\n  function webViewerSidebarViewChanged(evt) {\n    PDFViewerApplication.pdfRenderingQueue.isThumbnailViewEnabled =\n      PDFViewerApplication.pdfSidebar.isThumbnailViewVisible;\n\n    const store = PDFViewerApplication.store;\n    if (store && PDFViewerApplication.isInitialViewSet) {\n      // Only update the storage when the document has been loaded *and* rendered.\n      store.set(\"sidebarView\", evt.view).catch(function () {});\n    }\n  }\n\n  function webViewerUpdateViewarea(evt) {\n    const location = evt.location,\n      store = PDFViewerApplication.store;\n\n    if (store && PDFViewerApplication.isInitialViewSet) {\n      store\n        .setMultiple({\n          page: location.pageNumber,\n          zoom: location.scale,\n          scrollLeft: location.left,\n          scrollTop: location.top,\n          rotation: location.rotation,\n        })\n        .catch(function () {\n          /* unable to write to storage */\n        });\n    }\n    const href = PDFViewerApplication.pdfLinkService.getAnchorUrl(\n      location.pdfOpenParams\n    );\n    PDFViewerApplication.appConfig.toolbar.viewBookmark.href = href;\n    PDFViewerApplication.appConfig.secondaryToolbar.viewBookmarkButton.href = href;\n\n    // Show/hide the loading indicator in the page number input element.\n    const currentPage = PDFViewerApplication.pdfViewer.getPageView(\n      /* index = */ PDFViewerApplication.page - 1\n    );\n    const loading =\n      (currentPage && currentPage.renderingState) !== RenderingStates.FINISHED;\n    PDFViewerApplication.toolbar.updateLoadingIndicatorState(loading);\n  }\n\n  function webViewerScrollModeChanged(evt) {\n    const store = PDFViewerApplication.store;\n    if (store && PDFViewerApplication.isInitialViewSet) {\n      // Only update the storage when the document has been loaded *and* rendered.\n      store.set(\"scrollMode\", evt.mode).catch(function () {});\n    }\n  }\n\n  function webViewerSpreadModeChanged(evt) {\n    const store = PDFViewerApplication.store;\n    if (store && PDFViewerApplication.isInitialViewSet) {\n      // Only update the storage when the document has been loaded *and* rendered.\n      store.set(\"spreadMode\", evt.mode).catch(function () {});\n    }\n  }\n\n  function webViewerResize() {\n    const { pdfDocument, pdfViewer } = PDFViewerApplication;\n    if (!pdfDocument) {\n      return;\n    }\n    const currentScaleValue = pdfViewer.currentScaleValue;\n    if (\n      currentScaleValue === \"auto\" ||\n      currentScaleValue === \"page-fit\" ||\n      currentScaleValue === \"page-width\"\n    ) {\n      // Note: the scale is constant for 'page-actual'.\n      pdfViewer.currentScaleValue = currentScaleValue;\n    }\n    pdfViewer.update();\n  }\n\n  function webViewerHashchange(evt) {\n    const hash = evt.hash;\n    if (!hash) {\n      return;\n    }\n    if (!PDFViewerApplication.isInitialViewSet) {\n      PDFViewerApplication.initialBookmark = hash;\n    } else if (!PDFViewerApplication.pdfHistory.popStateInProgress) {\n      PDFViewerApplication.pdfLinkService.setHash(hash);\n    }\n  }\n\n  let webViewerFileInputChange, webViewerOpenFile;\n  if (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) {\n    webViewerFileInputChange = function (evt) {\n      if (\n        PDFViewerApplication.pdfViewer &&\n        PDFViewerApplication.pdfViewer.isInPresentationMode\n      ) {\n        return; // Opening a new PDF file isn't supported in Presentation Mode.\n      }\n      const file = evt.fileInput.files[0];\n\n      if (!viewerCompatibilityParams.disableCreateObjectURL) {\n        let url = URL.createObjectURL(file);\n        if (file.name) {\n          url = { url, originalUrl: file.name };\n        }\n        PDFViewerApplication.open(url);\n      } else {\n        PDFViewerApplication.setTitleUsingUrl(file.name);\n        // Read the local file into a Uint8Array.\n        const fileReader = new FileReader();\n        fileReader.onload = function webViewerChangeFileReaderOnload(event) {\n          const buffer = event.target.result;\n          PDFViewerApplication.open(new Uint8Array(buffer));\n        };\n        fileReader.readAsArrayBuffer(file);\n      }\n\n      // URL does not reflect proper document location - hiding some icons.\n      const appConfig = PDFViewerApplication.appConfig;\n      appConfig.toolbar.viewBookmark.setAttribute(\"hidden\", \"true\");\n      appConfig.secondaryToolbar.viewBookmarkButton.setAttribute(\n        \"hidden\",\n        \"true\"\n      );\n      appConfig.toolbar.download.setAttribute(\"hidden\", \"true\");\n      appConfig.secondaryToolbar.downloadButton.setAttribute(\"hidden\", \"true\");\n    };\n\n    webViewerOpenFile = function (evt) {\n      const openFileInputName = PDFViewerApplication.appConfig.openFileInputName;\n      document.getElementById(openFileInputName).click();\n    };\n  }\n\n  function webViewerPresentationMode() {\n    PDFViewerApplication.requestPresentationMode();\n  }\n  function webViewerPrint() {\n    PDFViewerApplication.triggerPrinting();\n  }\n  function webViewerDownload() {\n    PDFViewerApplication.downloadOrSave({ sourceEventType: \"download\" });\n  }\n  function webViewerSave() {\n    PDFViewerApplication.downloadOrSave({ sourceEventType: \"save\" });\n  }\n  function webViewerFirstPage() {\n    if (PDFViewerApplication.pdfDocument) {\n      PDFViewerApplication.page = 1;\n    }\n  }\n  function webViewerLastPage() {\n    if (PDFViewerApplication.pdfDocument) {\n      PDFViewerApplication.page = PDFViewerApplication.pagesCount;\n    }\n  }\n  function webViewerNextPage() {\n    PDFViewerApplication.pdfViewer.nextPage();\n  }\n  function webViewerPreviousPage() {\n    PDFViewerApplication.pdfViewer.previousPage();\n  }\n  function webViewerZoomIn() {\n    PDFViewerApplication.zoomIn();\n  }\n  function webViewerZoomOut() {\n    PDFViewerApplication.zoomOut();\n  }\n  function webViewerZoomReset() {\n    PDFViewerApplication.zoomReset();\n  }\n  function webViewerPageNumberChanged(evt) {\n    const pdfViewer = PDFViewerApplication.pdfViewer;\n    // Note that for `<input type=\"number\">` HTML elements, an empty string will\n    // be returned for non-number inputs; hence we simply do nothing in that case.\n    if (evt.value !== \"\") {\n      PDFViewerApplication.pdfLinkService.goToPage(evt.value);\n    }\n\n    // Ensure that the page number input displays the correct value, even if the\n    // value entered by the user was invalid (e.g. a floating point number).\n    if (\n      evt.value !== pdfViewer.currentPageNumber.toString() &&\n      evt.value !== pdfViewer.currentPageLabel\n    ) {\n      PDFViewerApplication.toolbar.setPageNumber(\n        pdfViewer.currentPageNumber,\n        pdfViewer.currentPageLabel\n      );\n    }\n  }\n  function webViewerScaleChanged(evt) {\n    PDFViewerApplication.pdfViewer.currentScaleValue = evt.value;\n  }\n  function webViewerRotateCw() {\n    PDFViewerApplication.rotatePages(90);\n  }\n  function webViewerRotateCcw() {\n    PDFViewerApplication.rotatePages(-90);\n  }\n  function webViewerOptionalContentConfig(evt) {\n    PDFViewerApplication.pdfViewer.optionalContentConfigPromise = evt.promise;\n  }\n  function webViewerSwitchScrollMode(evt) {\n    PDFViewerApplication.pdfViewer.scrollMode = evt.mode;\n  }\n  function webViewerSwitchSpreadMode(evt) {\n    PDFViewerApplication.pdfViewer.spreadMode = evt.mode;\n  }\n  function webViewerDocumentProperties() {\n    PDFViewerApplication.pdfDocumentProperties.open();\n  }\n\n  function webViewerFind(evt) {\n    PDFViewerApplication.findController.executeCommand(\"find\" + evt.type, {\n      query: evt.query,\n      phraseSearch: evt.phraseSearch,\n      caseSensitive: evt.caseSensitive,\n      entireWord: evt.entireWord,\n      highlightAll: evt.highlightAll,\n      findPrevious: evt.findPrevious,\n    });\n  }\n\n  function webViewerFindFromUrlHash(evt) {\n    PDFViewerApplication.findController.executeCommand(\"find\", {\n      query: evt.query,\n      phraseSearch: evt.phraseSearch,\n      caseSensitive: false,\n      entireWord: false,\n      highlightAll: true,\n      findPrevious: false,\n    });\n  }\n\n  function webViewerUpdateFindMatchesCount({ matchesCount }) {\n    if (PDFViewerApplication.supportsIntegratedFind) {\n      PDFViewerApplication.externalServices.updateFindMatchesCount(matchesCount);\n    } else {\n      PDFViewerApplication.findBar.updateResultsCount(matchesCount);\n    }\n  }\n\n  function webViewerUpdateFindControlState({\n    state,\n    previous,\n    matchesCount,\n    rawQuery,\n  }) {\n    if (PDFViewerApplication.supportsIntegratedFind) {\n      PDFViewerApplication.externalServices.updateFindControlState({\n        result: state,\n        findPrevious: previous,\n        matchesCount,\n        rawQuery,\n      });\n    } else {\n      PDFViewerApplication.findBar.updateUIState(state, previous, matchesCount);\n    }\n  }\n\n  function webViewerScaleChanging(evt) {\n    PDFViewerApplication.toolbar.setPageScale(evt.presetValue, evt.scale);\n\n    PDFViewerApplication.pdfViewer.update();\n  }\n\n  function webViewerRotationChanging(evt) {\n    PDFViewerApplication.pdfThumbnailViewer.pagesRotation = evt.pagesRotation;\n\n    PDFViewerApplication.forceRendering();\n    // Ensure that the active page doesn't change during rotation.\n    PDFViewerApplication.pdfViewer.currentPageNumber = evt.pageNumber;\n  }\n\n  function webViewerPageChanging({ pageNumber, pageLabel }) {\n    PDFViewerApplication.toolbar.setPageNumber(pageNumber, pageLabel);\n    PDFViewerApplication.secondaryToolbar.setPageNumber(pageNumber);\n\n    if (PDFViewerApplication.pdfSidebar.isThumbnailViewVisible) {\n      PDFViewerApplication.pdfThumbnailViewer.scrollThumbnailIntoView(pageNumber);\n    }\n  }\n\n  function webViewerVisibilityChange(evt) {\n    if (document.visibilityState === \"visible\") {\n      // Ignore mouse wheel zooming during tab switches (bug 1503412).\n      setZoomDisabledTimeout();\n    }\n  }\n\n  let zoomDisabledTimeout = null;\n  function setZoomDisabledTimeout() {\n    if (zoomDisabledTimeout) {\n      clearTimeout(zoomDisabledTimeout);\n    }\n    zoomDisabledTimeout = setTimeout(function () {\n      zoomDisabledTimeout = null;\n    }, WHEEL_ZOOM_DISABLED_TIMEOUT);\n  }\n\n  function webViewerWheel(evt) {\n    const {\n      pdfViewer,\n      supportedMouseWheelZoomModifierKeys,\n    } = PDFViewerApplication;\n\n    if (pdfViewer.isInPresentationMode) {\n      return;\n    }\n\n    if (\n      (evt.ctrlKey && supportedMouseWheelZoomModifierKeys.ctrlKey) ||\n      (evt.metaKey && supportedMouseWheelZoomModifierKeys.metaKey)\n    ) {\n      // Only zoom the pages, not the entire viewer.\n      evt.preventDefault();\n      // NOTE: this check must be placed *after* preventDefault.\n      if (zoomDisabledTimeout || document.visibilityState === \"hidden\") {\n        return;\n      }\n\n      const previousScale = pdfViewer.currentScale;\n\n      const delta = normalizeWheelEventDirection(evt);\n      let ticks = 0;\n      if (\n        evt.deltaMode === WheelEvent.DOM_DELTA_LINE ||\n        evt.deltaMode === WheelEvent.DOM_DELTA_PAGE\n      ) {\n        // For line-based devices, use one tick per event, because different\n        // OSs have different defaults for the number lines. But we generally\n        // want one \"clicky\" roll of the wheel (which produces one event) to\n        // adjust the zoom by one step.\n        if (Math.abs(delta) >= 1) {\n          ticks = Math.sign(delta);\n        } else {\n          // If we're getting fractional lines (I can't think of a scenario\n          // this might actually happen), be safe and use the accumulator.\n          ticks = PDFViewerApplication.accumulateWheelTicks(delta);\n        }\n      } else {\n        // pixel-based devices\n        const PIXELS_PER_LINE_SCALE = 30;\n        ticks = PDFViewerApplication.accumulateWheelTicks(\n          delta / PIXELS_PER_LINE_SCALE\n        );\n      }\n\n      if (ticks < 0) {\n        PDFViewerApplication.zoomOut(-ticks);\n      } else if (ticks > 0) {\n        PDFViewerApplication.zoomIn(ticks);\n      }\n\n      const currentScale = pdfViewer.currentScale;\n      if (previousScale !== currentScale) {\n        // After scaling the page via zoomIn/zoomOut, the position of the upper-\n        // left corner is restored. When the mouse wheel is used, the position\n        // under the cursor should be restored instead.\n        const scaleCorrectionFactor = currentScale / previousScale - 1;\n        const rect = pdfViewer.container.getBoundingClientRect();\n        const dx = evt.clientX - rect.left;\n        const dy = evt.clientY - rect.top;\n        pdfViewer.container.scrollLeft += dx * scaleCorrectionFactor;\n        pdfViewer.container.scrollTop += dy * scaleCorrectionFactor;\n      }\n    } else {\n      setZoomDisabledTimeout();\n    }\n  }\n\n  function webViewerTouchStart(evt) {\n    if (evt.touches.length > 1) {\n      // Disable touch-based zooming, because the entire UI bits gets zoomed and\n      // that doesn't look great. If we do want to have a good touch-based\n      // zooming experience, we need to implement smooth zoom capability (probably\n      // using a CSS transform for faster visual response, followed by async\n      // re-rendering at the final zoom level) and do gesture detection on the\n      // touchmove events to drive it. Or if we want to settle for a less good\n      // experience we can make the touchmove events drive the existing step-zoom\n      // behaviour that the ctrl+mousewheel path takes.\n      evt.preventDefault();\n    }\n  }\n\n  function webViewerClick(evt) {\n    // Avoid triggering the fallback bar when the user clicks on the\n    // toolbar or sidebar.\n    if (\n      PDFViewerApplication.triggerDelayedFallback &&\n      PDFViewerApplication.pdfViewer.containsElement(evt.target)\n    ) {\n      PDFViewerApplication.triggerDelayedFallback();\n    }\n\n    if (!PDFViewerApplication.secondaryToolbar.isOpen) {\n      return;\n    }\n    const appConfig = PDFViewerApplication.appConfig;\n    if (\n      PDFViewerApplication.pdfViewer.containsElement(evt.target) ||\n      (appConfig.toolbar.container.contains(evt.target) &&\n        evt.target !== appConfig.secondaryToolbar.toggleButton)\n    ) {\n      PDFViewerApplication.secondaryToolbar.close();\n    }\n  }\n\n  function webViewerKeyUp(evt) {\n    if (evt.keyCode === 9) {\n      // The user is tabbing into the viewer. Trigger the fallback bar if it has\n      // not already been displayed.\n      if (PDFViewerApplication.triggerDelayedFallback) {\n        PDFViewerApplication.triggerDelayedFallback();\n      }\n    }\n  }\n\n  function webViewerKeyDown(evt) {\n    if (PDFViewerApplication.overlayManager.active) {\n      return;\n    }\n\n    let handled = false,\n      ensureViewerFocused = false;\n    const cmd =\n      (evt.ctrlKey ? 1 : 0) |\n      (evt.altKey ? 2 : 0) |\n      (evt.shiftKey ? 4 : 0) |\n      (evt.metaKey ? 8 : 0);\n\n    const pdfViewer = PDFViewerApplication.pdfViewer;\n    const isViewerInPresentationMode =\n      pdfViewer && pdfViewer.isInPresentationMode;\n\n    // First, handle the key bindings that are independent whether an input\n    // control is selected or not.\n    if (cmd === 1 || cmd === 8 || cmd === 5 || cmd === 12) {\n      // either CTRL or META key with optional SHIFT.\n      switch (evt.keyCode) {\n        case 70: // f\n          if (!PDFViewerApplication.supportsIntegratedFind && !evt.shiftKey) {\n            PDFViewerApplication.findBar.open();\n            handled = true;\n          }\n          break;\n        case 71: // g\n          if (!PDFViewerApplication.supportsIntegratedFind) {\n            const findState = PDFViewerApplication.findController.state;\n            if (findState) {\n              PDFViewerApplication.findController.executeCommand(\"findagain\", {\n                query: findState.query,\n                phraseSearch: findState.phraseSearch,\n                caseSensitive: findState.caseSensitive,\n                entireWord: findState.entireWord,\n                highlightAll: findState.highlightAll,\n                findPrevious: cmd === 5 || cmd === 12,\n              });\n            }\n            handled = true;\n          }\n          break;\n        case 61: // FF/Mac '='\n        case 107: // FF '+' and '='\n        case 187: // Chrome '+'\n        case 171: // FF with German keyboard\n          if (!isViewerInPresentationMode) {\n            PDFViewerApplication.zoomIn();\n          }\n          handled = true;\n          break;\n        case 173: // FF/Mac '-'\n        case 109: // FF '-'\n        case 189: // Chrome '-'\n          if (!isViewerInPresentationMode) {\n            PDFViewerApplication.zoomOut();\n          }\n          handled = true;\n          break;\n        case 48: // '0'\n        case 96: // '0' on Numpad of Swedish keyboard\n          if (!isViewerInPresentationMode) {\n            // keeping it unhandled (to restore page zoom to 100%)\n            setTimeout(function () {\n              // ... and resetting the scale after browser adjusts its scale\n              PDFViewerApplication.zoomReset();\n            });\n            handled = false;\n          }\n          break;\n\n        case 38: // up arrow\n          if (isViewerInPresentationMode || PDFViewerApplication.page > 1) {\n            PDFViewerApplication.page = 1;\n            handled = true;\n            ensureViewerFocused = true;\n          }\n          break;\n        case 40: // down arrow\n          if (\n            isViewerInPresentationMode ||\n            PDFViewerApplication.page < PDFViewerApplication.pagesCount\n          ) {\n            PDFViewerApplication.page = PDFViewerApplication.pagesCount;\n            handled = true;\n            ensureViewerFocused = true;\n          }\n          break;\n      }\n    }\n\n    if (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC || CHROME\")) {\n      const { eventBus } = PDFViewerApplication;\n\n      // CTRL or META without shift\n      if (cmd === 1 || cmd === 8) {\n        switch (evt.keyCode) {\n          case 83: // s\n            eventBus.dispatch(\"download\", { source: window });\n            handled = true;\n            break;\n\n          case 79: // o\n            if (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) {\n              eventBus.dispatch(\"openfile\", { source: window });\n              handled = true;\n            }\n            break;\n        }\n      }\n    }\n\n    // CTRL+ALT or Option+Command\n    if (cmd === 3 || cmd === 10) {\n      switch (evt.keyCode) {\n        case 80: // p\n          PDFViewerApplication.requestPresentationMode();\n          handled = true;\n          break;\n        case 71: // g\n          // focuses input#pageNumber field\n          PDFViewerApplication.appConfig.toolbar.pageNumber.select();\n          handled = true;\n          break;\n      }\n    }\n\n    if (handled) {\n      if (ensureViewerFocused && !isViewerInPresentationMode) {\n        pdfViewer.focus();\n      }\n      evt.preventDefault();\n      return;\n    }\n\n    // Some shortcuts should not get handled if a control/input element\n    // is selected.\n    const curElement = getActiveOrFocusedElement();\n    const curElementTagName = curElement && curElement.tagName.toUpperCase();\n    if (\n      curElementTagName === \"INPUT\" ||\n      curElementTagName === \"TEXTAREA\" ||\n      curElementTagName === \"SELECT\" ||\n      (curElement && curElement.isContentEditable)\n    ) {\n      // Make sure that the secondary toolbar is closed when Escape is pressed.\n      if (evt.keyCode !== /* Esc = */ 27) {\n        return;\n      }\n    }\n\n    // No control key pressed at all.\n    if (cmd === 0) {\n      let turnPage = 0,\n        turnOnlyIfPageFit = false;\n      switch (evt.keyCode) {\n        case 38: // up arrow\n        case 33: // pg up\n          // vertical scrolling using arrow/pg keys\n          if (pdfViewer.isVerticalScrollbarEnabled) {\n            turnOnlyIfPageFit = true;\n          }\n          turnPage = -1;\n          break;\n        case 8: // backspace\n          if (!isViewerInPresentationMode) {\n            turnOnlyIfPageFit = true;\n          }\n          turnPage = -1;\n          break;\n        case 37: // left arrow\n          // horizontal scrolling using arrow keys\n          if (pdfViewer.isHorizontalScrollbarEnabled) {\n            turnOnlyIfPageFit = true;\n          }\n        /* falls through */\n        case 75: // 'k'\n        case 80: // 'p'\n          turnPage = -1;\n          break;\n        case 27: // esc key\n          if (PDFViewerApplication.secondaryToolbar.isOpen) {\n            PDFViewerApplication.secondaryToolbar.close();\n            handled = true;\n          }\n          if (\n            !PDFViewerApplication.supportsIntegratedFind &&\n            PDFViewerApplication.findBar.opened\n          ) {\n            PDFViewerApplication.findBar.close();\n            handled = true;\n          }\n          break;\n        case 40: // down arrow\n        case 34: // pg down\n          // vertical scrolling using arrow/pg keys\n          if (pdfViewer.isVerticalScrollbarEnabled) {\n            turnOnlyIfPageFit = true;\n          }\n          turnPage = 1;\n          break;\n        case 13: // enter key\n        case 32: // spacebar\n          if (!isViewerInPresentationMode) {\n            turnOnlyIfPageFit = true;\n          }\n          turnPage = 1;\n          break;\n        case 39: // right arrow\n          // horizontal scrolling using arrow keys\n          if (pdfViewer.isHorizontalScrollbarEnabled) {\n            turnOnlyIfPageFit = true;\n          }\n        /* falls through */\n        case 74: // 'j'\n        case 78: // 'n'\n          turnPage = 1;\n          break;\n\n        case 36: // home\n          if (isViewerInPresentationMode || PDFViewerApplication.page > 1) {\n            PDFViewerApplication.page = 1;\n            handled = true;\n            ensureViewerFocused = true;\n          }\n          break;\n        case 35: // end\n          if (\n            isViewerInPresentationMode ||\n            PDFViewerApplication.page < PDFViewerApplication.pagesCount\n          ) {\n            PDFViewerApplication.page = PDFViewerApplication.pagesCount;\n            handled = true;\n            ensureViewerFocused = true;\n          }\n          break;\n\n        case 83: // 's'\n          PDFViewerApplication.pdfCursorTools.switchTool(CursorTool.SELECT);\n          break;\n        case 72: // 'h'\n          PDFViewerApplication.pdfCursorTools.switchTool(CursorTool.HAND);\n          break;\n\n        case 82: // 'r'\n          PDFViewerApplication.rotatePages(90);\n          break;\n\n        case 115: // F4\n          PDFViewerApplication.pdfSidebar.toggle();\n          break;\n      }\n\n      if (\n        turnPage !== 0 &&\n        (!turnOnlyIfPageFit || pdfViewer.currentScaleValue === \"page-fit\")\n      ) {\n        if (turnPage > 0) {\n          pdfViewer.nextPage();\n        } else {\n          pdfViewer.previousPage();\n        }\n        handled = true;\n      }\n    }\n\n    // shift-key\n    if (cmd === 4) {\n      switch (evt.keyCode) {\n        case 13: // enter key\n        case 32: // spacebar\n          if (\n            !isViewerInPresentationMode &&\n            pdfViewer.currentScaleValue !== \"page-fit\"\n          ) {\n            break;\n          }\n          if (PDFViewerApplication.page > 1) {\n            PDFViewerApplication.page--;\n          }\n          handled = true;\n          break;\n\n        case 82: // 'r'\n          PDFViewerApplication.rotatePages(-90);\n          break;\n      }\n    }\n\n    if (!handled && !isViewerInPresentationMode) {\n      // 33=Page Up  34=Page Down  35=End    36=Home\n      // 37=Left     38=Up         39=Right  40=Down\n      // 32=Spacebar\n      if (\n        (evt.keyCode >= 33 && evt.keyCode <= 40) ||\n        (evt.keyCode === 32 && curElementTagName !== \"BUTTON\")\n      ) {\n        ensureViewerFocused = true;\n      }\n    }\n\n    if (ensureViewerFocused && !pdfViewer.containsElement(curElement)) {\n      // The page container is not focused, but a page navigation key has been\n      // pressed. Change the focus to the viewer container to make sure that\n      // navigation by keyboard works as expected.\n      pdfViewer.focus();\n    }\n\n    if (handled) {\n      evt.preventDefault();\n    }\n  }\n\n  function beforeUnload(evt) {\n    evt.preventDefault();\n    evt.returnValue = \"\";\n    return false;\n  }\n\n  /**\n   * Converts API PageLayout values to the format used by `PDFViewer`.\n   * NOTE: This is supported to the extent that the viewer implements the\n   *       necessary Scroll/Spread modes (since SinglePage, TwoPageLeft,\n   *       and TwoPageRight all suggests using non-continuous scrolling).\n   * @param {string} mode - The API PageLayout value.\n   * @returns {number} A value from {SpreadMode}.\n   */\n  function apiPageLayoutToSpreadMode(layout) {\n    switch (layout) {\n      case \"SinglePage\":\n      case \"OneColumn\":\n        return SpreadMode.NONE;\n      case \"TwoColumnLeft\":\n      case \"TwoPageLeft\":\n        return SpreadMode.ODD;\n      case \"TwoColumnRight\":\n      case \"TwoPageRight\":\n        return SpreadMode.EVEN;\n    }\n    return SpreadMode.NONE; // Default value.\n  }\n\n  /**\n   * Converts API PageMode values to the format used by `PDFSidebar`.\n   * NOTE: There's also a \"FullScreen\" parameter which is not possible to support,\n   *       since the Fullscreen API used in browsers requires that entering\n   *       fullscreen mode only occurs as a result of a user-initiated event.\n   * @param {string} mode - The API PageMode value.\n   * @returns {number} A value from {SidebarView}.\n   */\n  function apiPageModeToSidebarView(mode) {\n    switch (mode) {\n      case \"UseNone\":\n        return SidebarView.NONE;\n      case \"UseThumbs\":\n        return SidebarView.THUMBS;\n      case \"UseOutlines\":\n        return SidebarView.OUTLINE;\n      case \"UseAttachments\":\n        return SidebarView.ATTACHMENTS;\n      case \"UseOC\":\n        return SidebarView.LAYERS;\n    }\n    return SidebarView.NONE; // Default value.\n  }\n\n  /* Abstract factory for the print service. */\n  const PDFPrintServiceFactory = {\n    instance: {\n      supportsPrinting: false,\n      createPrintService() {\n        throw new Error(\"Not implemented: createPrintService\");\n      },\n    },\n  };\n\n  return {\n    DefaultExternalServices,\n    PDFPrintServiceFactory,\n    PDFViewerApplication,\n  };\n\n});\ndefine('skylark-pdfjs-viewer/preferences',[\n\n  \"./app_options\"\n],function(app_options){\n  /* Copyright 2013 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { AppOptions, OptionKind } =  app_options;\n\n  /**\n   * BasePreferences - Abstract base class for storing persistent settings.\n   *   Used for settings that should be applied to all opened documents,\n   *   or every time the viewer is loaded.\n   */\n  class BasePreferences {\n    constructor() {\n      if (this.constructor === BasePreferences) {\n        throw new Error(\"Cannot initialize BasePreferences.\");\n      }\n      Object.defineProperty(this, \"defaults\", {\n        value: Object.freeze(\n          typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"PRODUCTION\")\n            ? AppOptions.getAll(OptionKind.PREFERENCE)\n            : PDFJSDev.json(\"$ROOT/build/default_preferences.json\")\n        ),\n        writable: false,\n        enumerable: true,\n        configurable: false,\n      });\n      this.prefs = Object.assign(Object.create(null), this.defaults);\n\n      this._initializedPromise = this._readFromStorage(this.defaults).then(\n        prefs => {\n          if (!prefs) {\n            return;\n          }\n          for (const name in prefs) {\n            const defaultValue = this.defaults[name],\n              prefValue = prefs[name];\n            // Ignore preferences not present in, or whose types don't match,\n            // the default values.\n            if (\n              defaultValue === undefined ||\n              typeof prefValue !== typeof defaultValue\n            ) {\n              continue;\n            }\n            this.prefs[name] = prefValue;\n          }\n        }\n      );\n    }\n\n    /**\n     * Stub function for writing preferences to storage.\n     * @param {Object} prefObj The preferences that should be written to storage.\n     * @returns {Promise} A promise that is resolved when the preference values\n     *                    have been written.\n     */\n    async _writeToStorage(prefObj) {\n      throw new Error(\"Not implemented: _writeToStorage\");\n    }\n\n    /**\n     * Stub function for reading preferences from storage.\n     * @param {Object} prefObj The preferences that should be read from storage.\n     * @returns {Promise} A promise that is resolved with an {Object} containing\n     *                    the preferences that have been read.\n     */\n    async _readFromStorage(prefObj) {\n      throw new Error(\"Not implemented: _readFromStorage\");\n    }\n\n    /**\n     * Reset the preferences to their default values and update storage.\n     * @returns {Promise} A promise that is resolved when the preference values\n     *                    have been reset.\n     */\n    async reset() {\n      await this._initializedPromise;\n      this.prefs = Object.assign(Object.create(null), this.defaults);\n      return this._writeToStorage(this.defaults);\n    }\n\n    /**\n     * Set the value of a preference.\n     * @param {string} name The name of the preference that should be changed.\n     * @param {boolean|number|string} value The new value of the preference.\n     * @returns {Promise} A promise that is resolved when the value has been set,\n     *                    provided that the preference exists and the types match.\n     */\n    async set(name, value) {\n      await this._initializedPromise;\n      const defaultValue = this.defaults[name];\n\n      if (defaultValue === undefined) {\n        throw new Error(`Set preference: \"${name}\" is undefined.`);\n      } else if (value === undefined) {\n        throw new Error(\"Set preference: no value is specified.\");\n      }\n      const valueType = typeof value;\n      const defaultType = typeof defaultValue;\n\n      if (valueType !== defaultType) {\n        if (valueType === \"number\" && defaultType === \"string\") {\n          value = value.toString();\n        } else {\n          throw new Error(\n            `Set preference: \"${value}\" is a ${valueType}, ` +\n              `expected a ${defaultType}.`\n          );\n        }\n      } else {\n        if (valueType === \"number\" && !Number.isInteger(value)) {\n          throw new Error(`Set preference: \"${value}\" must be an integer.`);\n        }\n      }\n      this.prefs[name] = value;\n      return this._writeToStorage(this.prefs);\n    }\n\n    /**\n     * Get the value of a preference.\n     * @param {string} name The name of the preference whose value is requested.\n     * @returns {Promise} A promise resolved with a {boolean|number|string}\n     *                    containing the value of the preference.\n     */\n    async get(name) {\n      await this._initializedPromise;\n      const defaultValue = this.defaults[name];\n\n      if (defaultValue === undefined) {\n        throw new Error(`Get preference: \"${name}\" is undefined.`);\n      } else {\n        const prefValue = this.prefs[name];\n\n        if (prefValue !== undefined) {\n          return prefValue;\n        }\n      }\n      return defaultValue;\n    }\n\n    /**\n     * Get the values of all preferences.\n     * @returns {Promise} A promise that is resolved with an {Object} containing\n     *                    the values of all preferences.\n     */\n    async getAll() {\n      await this._initializedPromise;\n      return Object.assign(Object.create(null), this.defaults, this.prefs);\n    }\n  }\n\n  return { BasePreferences };\n});\ndefine('skylark-pdfjs-viewer/download_manager',[\n  \"skylark-pdfjs-display\",\n  \"./pdfjs_dev\",\n  \"./viewer_compatibility\"\n],function(\n  pdfjsLib,\n  PDFJSDev,\n  viewer_compatibility\n){\n\n\n  /* Copyright 2013 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { createObjectURL, createValidAbsoluteUrl } = pdfjsLib;\n  const { viewerCompatibilityParams } = viewer_compatibility;\n\n  if (typeof PDFJSDev !== \"undefined\" && !PDFJSDev.test(\"CHROME || GENERIC\")) {\n    throw new Error(\n      'Module \"pdfjs-web/download_manager\" shall not be used ' +\n        \"outside CHROME and GENERIC builds.\"\n    );\n  }\n\n  function download(blobUrl, filename) {\n    const a = document.createElement(\"a\");\n    if (!a.click) {\n      throw new Error('DownloadManager: \"a.click()\" is not supported.');\n    }\n    a.href = blobUrl;\n    a.target = \"_parent\";\n    // Use a.download if available. This increases the likelihood that\n    // the file is downloaded instead of opened by another PDF plugin.\n    if (\"download\" in a) {\n      a.download = filename;\n    }\n    // <a> must be in the document for recent Firefox versions,\n    // otherwise .click() is ignored.\n    (document.body || document.documentElement).appendChild(a);\n    a.click();\n    a.remove();\n  }\n\n  class DownloadManager {\n    downloadUrl(url, filename) {\n      if (!createValidAbsoluteUrl(url, \"http://example.com\")) {\n        return; // restricted/invalid URL\n      }\n      download(url + \"#pdfjs.action=download\", filename);\n    }\n\n    downloadData(data, filename, contentType) {\n      const blobUrl = createObjectURL(\n        data,\n        contentType,\n        viewerCompatibilityParams.disableCreateObjectURL\n      );\n      download(blobUrl, filename);\n    }\n\n    /**\n     * @param sourceEventType {string} Used to signal what triggered the download.\n     *   The version of PDF.js integrated with Firefox uses this to to determine\n     *   which dialog to show. \"save\" triggers \"save as\" and \"download\" triggers\n     *   the \"open with\" dialog.\n     */\n    download(blob, url, filename, sourceEventType = \"download\") {\n      if (viewerCompatibilityParams.disableCreateObjectURL) {\n        // URL.createObjectURL is not supported\n        this.downloadUrl(url, filename);\n        return;\n      }\n      const blobUrl = URL.createObjectURL(blob);\n      download(blobUrl, filename);\n    }\n  }\n\n  return { DownloadManager };\n});\ndefine('skylark-pdfjs-viewer/l10n',[],function(){\r\n  /**\r\n   * Copyright (c) 2011-2013 Fabien Cazenave, Mozilla.\r\n   *\r\n   * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n   * of this software and associated documentation files (the \"Software\"), to\r\n   * deal in the Software without restriction, including without limitation the\r\n   * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\r\n   * sell copies of the Software, and to permit persons to whom the Software is\r\n   * furnished to do so, subject to the following conditions:\r\n   *\r\n   * The above copyright notice and this permission notice shall be included in\r\n   * all copies or substantial portions of the Software.\r\n   *\r\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\r\n   * IN THE SOFTWARE.\r\n   */\r\n  /*\r\n    Additional modifications for PDF.js project:\r\n      - Disables language initialization on page loading.\r\n      - Disables document translation on page loading.\r\n      - Removes consoleWarn and consoleLog and use console.log/warn directly.\r\n      - Removes window._ assignment.\r\n      - Remove compatibility code for OldIE.\r\n      - Replaces `String.prototype.substr()` with `String.prototype.substring()`.\r\n      - Removes `fireL10nReadyEvent` since the \"localized\" event it dispatches\r\n        is unused and may clash with an identically named event in the viewer.\r\n  */\r\n\r\n  /*jshint browser: true, devel: true, es5: true, globalstrict: true */\r\n  'use strict';\r\n\r\n  return document.webL10n = (function(window, document, undefined) {\r\n    var gL10nData = {};\r\n    var gTextData = '';\r\n    var gTextProp = 'textContent';\r\n    var gLanguage = '';\r\n    var gMacros = {};\r\n    var gReadyState = 'loading';\r\n\r\n\r\n    /**\r\n     * Synchronously loading l10n resources significantly minimizes flickering\r\n     * from displaying the app with non-localized strings and then updating the\r\n     * strings. Although this will block all script execution on this page, we\r\n     * expect that the l10n resources are available locally on flash-storage.\r\n     *\r\n     * As synchronous XHR is generally considered as a bad idea, we're still\r\n     * loading l10n resources asynchronously -- but we keep this in a setting,\r\n     * just in case... and applications using this library should hide their\r\n     * content until the `localized' event happens.\r\n     */\r\n\r\n    var gAsyncResourceLoading = true; // read-only\r\n\r\n\r\n    /**\r\n     * DOM helpers for the so-called \"HTML API\".\r\n     *\r\n     * These functions are written for modern browsers. For old versions of IE,\r\n     * they're overridden in the 'startup' section at the end of this file.\r\n     */\r\n\r\n    function getL10nResourceLinks() {\r\n      return document.querySelectorAll('link[type=\"application/l10n\"]');\r\n    }\r\n\r\n    function getL10nDictionary() {\r\n      var script = document.querySelector('script[type=\"application/l10n\"]');\r\n      // TODO: support multiple and external JSON dictionaries\r\n      return script ? JSON.parse(script.innerHTML) : null;\r\n    }\r\n\r\n    function getTranslatableChildren(element) {\r\n      return element ? element.querySelectorAll('*[data-l10n-id]') : [];\r\n    }\r\n\r\n    function getL10nAttributes(element) {\r\n      if (!element)\r\n        return {};\r\n\r\n      var l10nId = element.getAttribute('data-l10n-id');\r\n      var l10nArgs = element.getAttribute('data-l10n-args');\r\n      var args = {};\r\n      if (l10nArgs) {\r\n        try {\r\n          args = JSON.parse(l10nArgs);\r\n        } catch (e) {\r\n          console.warn('could not parse arguments for #' + l10nId);\r\n        }\r\n      }\r\n      return { id: l10nId, args: args };\r\n    }\r\n\r\n    function xhrLoadText(url, onSuccess, onFailure) {\r\n      onSuccess = onSuccess || function _onSuccess(data) {};\r\n      onFailure = onFailure || function _onFailure() {};\r\n\r\n      var xhr = new XMLHttpRequest();\r\n      xhr.open('GET', url, gAsyncResourceLoading);\r\n      if (xhr.overrideMimeType) {\r\n        xhr.overrideMimeType('text/plain; charset=utf-8');\r\n      }\r\n      xhr.onreadystatechange = function() {\r\n        if (xhr.readyState == 4) {\r\n          if (xhr.status == 200 || xhr.status === 0) {\r\n            onSuccess(xhr.responseText);\r\n          } else {\r\n            onFailure();\r\n          }\r\n        }\r\n      };\r\n      xhr.onerror = onFailure;\r\n      xhr.ontimeout = onFailure;\r\n\r\n      // in Firefox OS with the app:// protocol, trying to XHR a non-existing\r\n      // URL will raise an exception here -- hence this ugly try...catch.\r\n      try {\r\n        xhr.send(null);\r\n      } catch (e) {\r\n        onFailure();\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * l10n resource parser:\r\n     *  - reads (async XHR) the l10n resource matching `lang';\r\n     *  - imports linked resources (synchronously) when specified;\r\n     *  - parses the text data (fills `gL10nData' and `gTextData');\r\n     *  - triggers success/failure callbacks when done.\r\n     *\r\n     * @param {string} href\r\n     *    URL of the l10n resource to parse.\r\n     *\r\n     * @param {string} lang\r\n     *    locale (language) to parse. Must be a lowercase string.\r\n     *\r\n     * @param {Function} successCallback\r\n     *    triggered when the l10n resource has been successfully parsed.\r\n     *\r\n     * @param {Function} failureCallback\r\n     *    triggered when the an error has occurred.\r\n     *\r\n     * @return {void}\r\n     *    uses the following global variables: gL10nData, gTextData, gTextProp.\r\n     */\r\n\r\n    function parseResource(href, lang, successCallback, failureCallback) {\r\n      var baseURL = href.replace(/[^\\/]*$/, '') || './';\r\n\r\n      // handle escaped characters (backslashes) in a string\r\n      function evalString(text) {\r\n        if (text.lastIndexOf('\\\\') < 0)\r\n          return text;\r\n        return text.replace(/\\\\\\\\/g, '\\\\')\r\n                   .replace(/\\\\n/g, '\\n')\r\n                   .replace(/\\\\r/g, '\\r')\r\n                   .replace(/\\\\t/g, '\\t')\r\n                   .replace(/\\\\b/g, '\\b')\r\n                   .replace(/\\\\f/g, '\\f')\r\n                   .replace(/\\\\{/g, '{')\r\n                   .replace(/\\\\}/g, '}')\r\n                   .replace(/\\\\\"/g, '\"')\r\n                   .replace(/\\\\'/g, \"'\");\r\n      }\r\n\r\n      // parse *.properties text data into an l10n dictionary\r\n      // If gAsyncResourceLoading is false, then the callback will be called\r\n      // synchronously. Otherwise it is called asynchronously.\r\n      function parseProperties(text, parsedPropertiesCallback) {\r\n        var dictionary = {};\r\n\r\n        // token expressions\r\n        var reBlank = /^\\s*|\\s*$/;\r\n        var reComment = /^\\s*#|^\\s*$/;\r\n        var reSection = /^\\s*\\[(.*)\\]\\s*$/;\r\n        var reImport = /^\\s*@import\\s+url\\((.*)\\)\\s*$/i;\r\n        var reSplit = /^([^=\\s]*)\\s*=\\s*(.+)$/; // TODO: escape EOLs with '\\'\r\n\r\n        // parse the *.properties file into an associative array\r\n        function parseRawLines(rawText, extendedSyntax, parsedRawLinesCallback) {\r\n          var entries = rawText.replace(reBlank, '').split(/[\\r\\n]+/);\r\n          var currentLang = '*';\r\n          var genericLang = lang.split('-', 1)[0];\r\n          var skipLang = false;\r\n          var match = '';\r\n\r\n          function nextEntry() {\r\n            // Use infinite loop instead of recursion to avoid reaching the\r\n            // maximum recursion limit for content with many lines.\r\n            while (true) {\r\n              if (!entries.length) {\r\n                parsedRawLinesCallback();\r\n                return;\r\n              }\r\n              var line = entries.shift();\r\n\r\n              // comment or blank line?\r\n              if (reComment.test(line))\r\n                continue;\r\n\r\n              // the extended syntax supports [lang] sections and @import rules\r\n              if (extendedSyntax) {\r\n                match = reSection.exec(line);\r\n                if (match) { // section start?\r\n                  // RFC 4646, section 4.4, \"All comparisons MUST be performed\r\n                  // in a case-insensitive manner.\"\r\n\r\n                  currentLang = match[1].toLowerCase();\r\n                  skipLang = (currentLang !== '*') &&\r\n                      (currentLang !== lang) && (currentLang !== genericLang);\r\n                  continue;\r\n                } else if (skipLang) {\r\n                  continue;\r\n                }\r\n                match = reImport.exec(line);\r\n                if (match) { // @import rule?\r\n                  loadImport(baseURL + match[1], nextEntry);\r\n                  return;\r\n                }\r\n              }\r\n\r\n              // key-value pair\r\n              var tmp = line.match(reSplit);\r\n              if (tmp && tmp.length == 3) {\r\n                dictionary[tmp[1]] = evalString(tmp[2]);\r\n              }\r\n            }\r\n          }\r\n          nextEntry();\r\n        }\r\n\r\n        // import another *.properties file\r\n        function loadImport(url, callback) {\r\n          xhrLoadText(url, function(content) {\r\n            parseRawLines(content, false, callback); // don't allow recursive imports\r\n          }, function () {\r\n            console.warn(url + ' not found.');\r\n            callback();\r\n          });\r\n        }\r\n\r\n        // fill the dictionary\r\n        parseRawLines(text, true, function() {\r\n          parsedPropertiesCallback(dictionary);\r\n        });\r\n      }\r\n\r\n      // load and parse l10n data (warning: global variables are used here)\r\n      xhrLoadText(href, function(response) {\r\n        gTextData += response; // mostly for debug\r\n\r\n        // parse *.properties text data into an l10n dictionary\r\n        parseProperties(response, function(data) {\r\n\r\n          // find attribute descriptions, if any\r\n          for (var key in data) {\r\n            var id, prop, index = key.lastIndexOf('.');\r\n            if (index > 0) { // an attribute has been specified\r\n              id = key.substring(0, index);\r\n              prop = key.substring(index + 1);\r\n            } else { // no attribute: assuming text content by default\r\n              id = key;\r\n              prop = gTextProp;\r\n            }\r\n            if (!gL10nData[id]) {\r\n              gL10nData[id] = {};\r\n            }\r\n            gL10nData[id][prop] = data[key];\r\n          }\r\n\r\n          // trigger callback\r\n          if (successCallback) {\r\n            successCallback();\r\n          }\r\n        });\r\n      }, failureCallback);\r\n    }\r\n\r\n    // load and parse all resources for the specified locale\r\n    function loadLocale(lang, callback) {\r\n      // RFC 4646, section 2.1 states that language tags have to be treated as\r\n      // case-insensitive. Convert to lowercase for case-insensitive comparisons.\r\n      if (lang) {\r\n        lang = lang.toLowerCase();\r\n      }\r\n\r\n      callback = callback || function _callback() {};\r\n\r\n      clear();\r\n      gLanguage = lang;\r\n\r\n      // check all <link type=\"application/l10n\" href=\"...\" /> nodes\r\n      // and load the resource files\r\n      var langLinks = getL10nResourceLinks();\r\n      var langCount = langLinks.length;\r\n      if (langCount === 0) {\r\n        // we might have a pre-compiled dictionary instead\r\n        var dict = getL10nDictionary();\r\n        if (dict && dict.locales && dict.default_locale) {\r\n          console.log('using the embedded JSON directory, early way out');\r\n          gL10nData = dict.locales[lang];\r\n          if (!gL10nData) {\r\n            var defaultLocale = dict.default_locale.toLowerCase();\r\n            for (var anyCaseLang in dict.locales) {\r\n              anyCaseLang = anyCaseLang.toLowerCase();\r\n              if (anyCaseLang === lang) {\r\n                gL10nData = dict.locales[lang];\r\n                break;\r\n              } else if (anyCaseLang === defaultLocale) {\r\n                gL10nData = dict.locales[defaultLocale];\r\n              }\r\n            }\r\n          }\r\n          callback();\r\n        } else {\r\n          console.log('no resource to load, early way out');\r\n        }\r\n        // early way out\r\n        gReadyState = 'complete';\r\n        return;\r\n      }\r\n\r\n      // start the callback when all resources are loaded\r\n      var onResourceLoaded = null;\r\n      var gResourceCount = 0;\r\n      onResourceLoaded = function() {\r\n        gResourceCount++;\r\n        if (gResourceCount >= langCount) {\r\n          callback();\r\n          gReadyState = 'complete';\r\n        }\r\n      };\r\n\r\n      // load all resource files\r\n      function L10nResourceLink(link) {\r\n        var href = link.href;\r\n        // Note: If |gAsyncResourceLoading| is false, then the following callbacks\r\n        // are synchronously called.\r\n        this.load = function(lang, callback) {\r\n          parseResource(href, lang, callback, function() {\r\n            console.warn(href + ' not found.');\r\n            // lang not found, used default resource instead\r\n            console.warn('\"' + lang + '\" resource not found');\r\n            gLanguage = '';\r\n            // Resource not loaded, but we still need to call the callback.\r\n            callback();\r\n          });\r\n        };\r\n      }\r\n\r\n      for (var i = 0; i < langCount; i++) {\r\n        var resource = new L10nResourceLink(langLinks[i]);\r\n        resource.load(lang, onResourceLoaded);\r\n      }\r\n    }\r\n\r\n    // clear all l10n data\r\n    function clear() {\r\n      gL10nData = {};\r\n      gTextData = '';\r\n      gLanguage = '';\r\n      // TODO: clear all non predefined macros.\r\n      // There's no such macro /yet/ but we're planning to have some...\r\n    }\r\n\r\n\r\n    /**\r\n     * Get rules for plural forms (shared with JetPack), see:\r\n     * http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html\r\n     * https://github.com/mozilla/addon-sdk/blob/master/python-lib/plural-rules-generator.p\r\n     *\r\n     * @param {string} lang\r\n     *    locale (language) used.\r\n     *\r\n     * @return {Function}\r\n     *    returns a function that gives the plural form name for a given integer:\r\n     *       var fun = getPluralRules('en');\r\n     *       fun(1)    -> 'one'\r\n     *       fun(0)    -> 'other'\r\n     *       fun(1000) -> 'other'.\r\n     */\r\n\r\n    function getPluralRules(lang) {\r\n      var locales2rules = {\r\n        'af': 3,\r\n        'ak': 4,\r\n        'am': 4,\r\n        'ar': 1,\r\n        'asa': 3,\r\n        'az': 0,\r\n        'be': 11,\r\n        'bem': 3,\r\n        'bez': 3,\r\n        'bg': 3,\r\n        'bh': 4,\r\n        'bm': 0,\r\n        'bn': 3,\r\n        'bo': 0,\r\n        'br': 20,\r\n        'brx': 3,\r\n        'bs': 11,\r\n        'ca': 3,\r\n        'cgg': 3,\r\n        'chr': 3,\r\n        'cs': 12,\r\n        'cy': 17,\r\n        'da': 3,\r\n        'de': 3,\r\n        'dv': 3,\r\n        'dz': 0,\r\n        'ee': 3,\r\n        'el': 3,\r\n        'en': 3,\r\n        'eo': 3,\r\n        'es': 3,\r\n        'et': 3,\r\n        'eu': 3,\r\n        'fa': 0,\r\n        'ff': 5,\r\n        'fi': 3,\r\n        'fil': 4,\r\n        'fo': 3,\r\n        'fr': 5,\r\n        'fur': 3,\r\n        'fy': 3,\r\n        'ga': 8,\r\n        'gd': 24,\r\n        'gl': 3,\r\n        'gsw': 3,\r\n        'gu': 3,\r\n        'guw': 4,\r\n        'gv': 23,\r\n        'ha': 3,\r\n        'haw': 3,\r\n        'he': 2,\r\n        'hi': 4,\r\n        'hr': 11,\r\n        'hu': 0,\r\n        'id': 0,\r\n        'ig': 0,\r\n        'ii': 0,\r\n        'is': 3,\r\n        'it': 3,\r\n        'iu': 7,\r\n        'ja': 0,\r\n        'jmc': 3,\r\n        'jv': 0,\r\n        'ka': 0,\r\n        'kab': 5,\r\n        'kaj': 3,\r\n        'kcg': 3,\r\n        'kde': 0,\r\n        'kea': 0,\r\n        'kk': 3,\r\n        'kl': 3,\r\n        'km': 0,\r\n        'kn': 0,\r\n        'ko': 0,\r\n        'ksb': 3,\r\n        'ksh': 21,\r\n        'ku': 3,\r\n        'kw': 7,\r\n        'lag': 18,\r\n        'lb': 3,\r\n        'lg': 3,\r\n        'ln': 4,\r\n        'lo': 0,\r\n        'lt': 10,\r\n        'lv': 6,\r\n        'mas': 3,\r\n        'mg': 4,\r\n        'mk': 16,\r\n        'ml': 3,\r\n        'mn': 3,\r\n        'mo': 9,\r\n        'mr': 3,\r\n        'ms': 0,\r\n        'mt': 15,\r\n        'my': 0,\r\n        'nah': 3,\r\n        'naq': 7,\r\n        'nb': 3,\r\n        'nd': 3,\r\n        'ne': 3,\r\n        'nl': 3,\r\n        'nn': 3,\r\n        'no': 3,\r\n        'nr': 3,\r\n        'nso': 4,\r\n        'ny': 3,\r\n        'nyn': 3,\r\n        'om': 3,\r\n        'or': 3,\r\n        'pa': 3,\r\n        'pap': 3,\r\n        'pl': 13,\r\n        'ps': 3,\r\n        'pt': 3,\r\n        'rm': 3,\r\n        'ro': 9,\r\n        'rof': 3,\r\n        'ru': 11,\r\n        'rwk': 3,\r\n        'sah': 0,\r\n        'saq': 3,\r\n        'se': 7,\r\n        'seh': 3,\r\n        'ses': 0,\r\n        'sg': 0,\r\n        'sh': 11,\r\n        'shi': 19,\r\n        'sk': 12,\r\n        'sl': 14,\r\n        'sma': 7,\r\n        'smi': 7,\r\n        'smj': 7,\r\n        'smn': 7,\r\n        'sms': 7,\r\n        'sn': 3,\r\n        'so': 3,\r\n        'sq': 3,\r\n        'sr': 11,\r\n        'ss': 3,\r\n        'ssy': 3,\r\n        'st': 3,\r\n        'sv': 3,\r\n        'sw': 3,\r\n        'syr': 3,\r\n        'ta': 3,\r\n        'te': 3,\r\n        'teo': 3,\r\n        'th': 0,\r\n        'ti': 4,\r\n        'tig': 3,\r\n        'tk': 3,\r\n        'tl': 4,\r\n        'tn': 3,\r\n        'to': 0,\r\n        'tr': 0,\r\n        'ts': 3,\r\n        'tzm': 22,\r\n        'uk': 11,\r\n        'ur': 3,\r\n        've': 3,\r\n        'vi': 0,\r\n        'vun': 3,\r\n        'wa': 4,\r\n        'wae': 3,\r\n        'wo': 0,\r\n        'xh': 3,\r\n        'xog': 3,\r\n        'yo': 0,\r\n        'zh': 0,\r\n        'zu': 3\r\n      };\r\n\r\n      // utility functions for plural rules methods\r\n      function isIn(n, list) {\r\n        return list.indexOf(n) !== -1;\r\n      }\r\n      function isBetween(n, start, end) {\r\n        return start <= n && n <= end;\r\n      }\r\n\r\n      // list of all plural rules methods:\r\n      // map an integer to the plural form name to use\r\n      var pluralRules = {\r\n        '0': function(n) {\r\n          return 'other';\r\n        },\r\n        '1': function(n) {\r\n          if ((isBetween((n % 100), 3, 10)))\r\n            return 'few';\r\n          if (n === 0)\r\n            return 'zero';\r\n          if ((isBetween((n % 100), 11, 99)))\r\n            return 'many';\r\n          if (n == 2)\r\n            return 'two';\r\n          if (n == 1)\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '2': function(n) {\r\n          if (n !== 0 && (n % 10) === 0)\r\n            return 'many';\r\n          if (n == 2)\r\n            return 'two';\r\n          if (n == 1)\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '3': function(n) {\r\n          if (n == 1)\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '4': function(n) {\r\n          if ((isBetween(n, 0, 1)))\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '5': function(n) {\r\n          if ((isBetween(n, 0, 2)) && n != 2)\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '6': function(n) {\r\n          if (n === 0)\r\n            return 'zero';\r\n          if ((n % 10) == 1 && (n % 100) != 11)\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '7': function(n) {\r\n          if (n == 2)\r\n            return 'two';\r\n          if (n == 1)\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '8': function(n) {\r\n          if ((isBetween(n, 3, 6)))\r\n            return 'few';\r\n          if ((isBetween(n, 7, 10)))\r\n            return 'many';\r\n          if (n == 2)\r\n            return 'two';\r\n          if (n == 1)\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '9': function(n) {\r\n          if (n === 0 || n != 1 && (isBetween((n % 100), 1, 19)))\r\n            return 'few';\r\n          if (n == 1)\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '10': function(n) {\r\n          if ((isBetween((n % 10), 2, 9)) && !(isBetween((n % 100), 11, 19)))\r\n            return 'few';\r\n          if ((n % 10) == 1 && !(isBetween((n % 100), 11, 19)))\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '11': function(n) {\r\n          if ((isBetween((n % 10), 2, 4)) && !(isBetween((n % 100), 12, 14)))\r\n            return 'few';\r\n          if ((n % 10) === 0 ||\r\n              (isBetween((n % 10), 5, 9)) ||\r\n              (isBetween((n % 100), 11, 14)))\r\n            return 'many';\r\n          if ((n % 10) == 1 && (n % 100) != 11)\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '12': function(n) {\r\n          if ((isBetween(n, 2, 4)))\r\n            return 'few';\r\n          if (n == 1)\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '13': function(n) {\r\n          if ((isBetween((n % 10), 2, 4)) && !(isBetween((n % 100), 12, 14)))\r\n            return 'few';\r\n          if (n != 1 && (isBetween((n % 10), 0, 1)) ||\r\n              (isBetween((n % 10), 5, 9)) ||\r\n              (isBetween((n % 100), 12, 14)))\r\n            return 'many';\r\n          if (n == 1)\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '14': function(n) {\r\n          if ((isBetween((n % 100), 3, 4)))\r\n            return 'few';\r\n          if ((n % 100) == 2)\r\n            return 'two';\r\n          if ((n % 100) == 1)\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '15': function(n) {\r\n          if (n === 0 || (isBetween((n % 100), 2, 10)))\r\n            return 'few';\r\n          if ((isBetween((n % 100), 11, 19)))\r\n            return 'many';\r\n          if (n == 1)\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '16': function(n) {\r\n          if ((n % 10) == 1 && n != 11)\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '17': function(n) {\r\n          if (n == 3)\r\n            return 'few';\r\n          if (n === 0)\r\n            return 'zero';\r\n          if (n == 6)\r\n            return 'many';\r\n          if (n == 2)\r\n            return 'two';\r\n          if (n == 1)\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '18': function(n) {\r\n          if (n === 0)\r\n            return 'zero';\r\n          if ((isBetween(n, 0, 2)) && n !== 0 && n != 2)\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '19': function(n) {\r\n          if ((isBetween(n, 2, 10)))\r\n            return 'few';\r\n          if ((isBetween(n, 0, 1)))\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '20': function(n) {\r\n          if ((isBetween((n % 10), 3, 4) || ((n % 10) == 9)) && !(\r\n              isBetween((n % 100), 10, 19) ||\r\n              isBetween((n % 100), 70, 79) ||\r\n              isBetween((n % 100), 90, 99)\r\n              ))\r\n            return 'few';\r\n          if ((n % 1000000) === 0 && n !== 0)\r\n            return 'many';\r\n          if ((n % 10) == 2 && !isIn((n % 100), [12, 72, 92]))\r\n            return 'two';\r\n          if ((n % 10) == 1 && !isIn((n % 100), [11, 71, 91]))\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '21': function(n) {\r\n          if (n === 0)\r\n            return 'zero';\r\n          if (n == 1)\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '22': function(n) {\r\n          if ((isBetween(n, 0, 1)) || (isBetween(n, 11, 99)))\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '23': function(n) {\r\n          if ((isBetween((n % 10), 1, 2)) || (n % 20) === 0)\r\n            return 'one';\r\n          return 'other';\r\n        },\r\n        '24': function(n) {\r\n          if ((isBetween(n, 3, 10) || isBetween(n, 13, 19)))\r\n            return 'few';\r\n          if (isIn(n, [2, 12]))\r\n            return 'two';\r\n          if (isIn(n, [1, 11]))\r\n            return 'one';\r\n          return 'other';\r\n        }\r\n      };\r\n\r\n      // return a function that gives the plural form name for a given integer\r\n      var index = locales2rules[lang.replace(/-.*$/, '')];\r\n      if (!(index in pluralRules)) {\r\n        console.warn('plural form unknown for [' + lang + ']');\r\n        return function() { return 'other'; };\r\n      }\r\n      return pluralRules[index];\r\n    }\r\n\r\n    // pre-defined 'plural' macro\r\n    gMacros.plural = function(str, param, key, prop) {\r\n      var n = parseFloat(param);\r\n      if (isNaN(n))\r\n        return str;\r\n\r\n      // TODO: support other properties (l20n still doesn't...)\r\n      if (prop != gTextProp)\r\n        return str;\r\n\r\n      // initialize _pluralRules\r\n      if (!gMacros._pluralRules) {\r\n        gMacros._pluralRules = getPluralRules(gLanguage);\r\n      }\r\n      var index = '[' + gMacros._pluralRules(n) + ']';\r\n\r\n      // try to find a [zero|one|two] key if it's defined\r\n      if (n === 0 && (key + '[zero]') in gL10nData) {\r\n        str = gL10nData[key + '[zero]'][prop];\r\n      } else if (n == 1 && (key + '[one]') in gL10nData) {\r\n        str = gL10nData[key + '[one]'][prop];\r\n      } else if (n == 2 && (key + '[two]') in gL10nData) {\r\n        str = gL10nData[key + '[two]'][prop];\r\n      } else if ((key + index) in gL10nData) {\r\n        str = gL10nData[key + index][prop];\r\n      } else if ((key + '[other]') in gL10nData) {\r\n        str = gL10nData[key + '[other]'][prop];\r\n      }\r\n\r\n      return str;\r\n    };\r\n\r\n\r\n    /**\r\n     * l10n dictionary functions\r\n     */\r\n\r\n    // fetch an l10n object, warn if not found, apply `args' if possible\r\n    function getL10nData(key, args, fallback) {\r\n      var data = gL10nData[key];\r\n      if (!data) {\r\n        console.warn('#' + key + ' is undefined.');\r\n        if (!fallback) {\r\n          return null;\r\n        }\r\n        data = fallback;\r\n      }\r\n\r\n      /** This is where l10n expressions should be processed.\r\n        * The plan is to support C-style expressions from the l20n project;\r\n        * until then, only two kinds of simple expressions are supported:\r\n        *   {[ index ]} and {{ arguments }}.\r\n        */\r\n      var rv = {};\r\n      for (var prop in data) {\r\n        var str = data[prop];\r\n        str = substIndexes(str, args, key, prop);\r\n        str = substArguments(str, args, key);\r\n        rv[prop] = str;\r\n      }\r\n      return rv;\r\n    }\r\n\r\n    // replace {[macros]} with their values\r\n    function substIndexes(str, args, key, prop) {\r\n      var reIndex = /\\{\\[\\s*([a-zA-Z]+)\\(([a-zA-Z]+)\\)\\s*\\]\\}/;\r\n      var reMatch = reIndex.exec(str);\r\n      if (!reMatch || !reMatch.length)\r\n        return str;\r\n\r\n      // an index/macro has been found\r\n      // Note: at the moment, only one parameter is supported\r\n      var macroName = reMatch[1];\r\n      var paramName = reMatch[2];\r\n      var param;\r\n      if (args && paramName in args) {\r\n        param = args[paramName];\r\n      } else if (paramName in gL10nData) {\r\n        param = gL10nData[paramName];\r\n      }\r\n\r\n      // there's no macro parser yet: it has to be defined in gMacros\r\n      if (macroName in gMacros) {\r\n        var macro = gMacros[macroName];\r\n        str = macro(str, param, key, prop);\r\n      }\r\n      return str;\r\n    }\r\n\r\n    // replace {{arguments}} with their values\r\n    function substArguments(str, args, key) {\r\n      var reArgs = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\r\n      return str.replace(reArgs, function(matched_text, arg) {\r\n        if (args && arg in args) {\r\n          return args[arg];\r\n        }\r\n        if (arg in gL10nData) {\r\n          return gL10nData[arg];\r\n        }\r\n        console.log('argument {{' + arg + '}} for #' + key + ' is undefined.');\r\n        return matched_text;\r\n      });\r\n    }\r\n\r\n    // translate an HTML element\r\n    function translateElement(element) {\r\n      var l10n = getL10nAttributes(element);\r\n      if (!l10n.id)\r\n        return;\r\n\r\n      // get the related l10n object\r\n      var data = getL10nData(l10n.id, l10n.args);\r\n      if (!data) {\r\n        console.warn('#' + l10n.id + ' is undefined.');\r\n        return;\r\n      }\r\n\r\n      // translate element (TODO: security checks?)\r\n      if (data[gTextProp]) { // XXX\r\n        if (getChildElementCount(element) === 0) {\r\n          element[gTextProp] = data[gTextProp];\r\n        } else {\r\n          // this element has element children: replace the content of the first\r\n          // (non-empty) child textNode and clear other child textNodes\r\n          var children = element.childNodes;\r\n          var found = false;\r\n          for (var i = 0, l = children.length; i < l; i++) {\r\n            if (children[i].nodeType === 3 && /\\S/.test(children[i].nodeValue)) {\r\n              if (found) {\r\n                children[i].nodeValue = '';\r\n              } else {\r\n                children[i].nodeValue = data[gTextProp];\r\n                found = true;\r\n              }\r\n            }\r\n          }\r\n          // if no (non-empty) textNode is found, insert a textNode before the\r\n          // first element child.\r\n          if (!found) {\r\n            var textNode = document.createTextNode(data[gTextProp]);\r\n            element.insertBefore(textNode, element.firstChild);\r\n          }\r\n        }\r\n        delete data[gTextProp];\r\n      }\r\n\r\n      for (var k in data) {\r\n        element[k] = data[k];\r\n      }\r\n    }\r\n\r\n    // webkit browsers don't currently support 'children' on SVG elements...\r\n    function getChildElementCount(element) {\r\n      if (element.children) {\r\n        return element.children.length;\r\n      }\r\n      if (typeof element.childElementCount !== 'undefined') {\r\n        return element.childElementCount;\r\n      }\r\n      var count = 0;\r\n      for (var i = 0; i < element.childNodes.length; i++) {\r\n        count += element.nodeType === 1 ? 1 : 0;\r\n      }\r\n      return count;\r\n    }\r\n\r\n    // translate an HTML subtree\r\n    function translateFragment(element) {\r\n      element = element || document.documentElement;\r\n\r\n      // check all translatable children (= w/ a `data-l10n-id' attribute)\r\n      var children = getTranslatableChildren(element);\r\n      var elementCount = children.length;\r\n      for (var i = 0; i < elementCount; i++) {\r\n        translateElement(children[i]);\r\n      }\r\n\r\n      // translate element itself if necessary\r\n      translateElement(element);\r\n    }\r\n\r\n    return {\r\n      // get a localized string\r\n      get: function(key, args, fallbackString) {\r\n        var index = key.lastIndexOf('.');\r\n        var prop = gTextProp;\r\n        if (index > 0) { // An attribute has been specified\r\n          prop = key.substring(index + 1);\r\n          key = key.substring(0, index);\r\n        }\r\n        var fallback;\r\n        if (fallbackString) {\r\n          fallback = {};\r\n          fallback[prop] = fallbackString;\r\n        }\r\n        var data = getL10nData(key, args, fallback);\r\n        if (data && prop in data) {\r\n          return data[prop];\r\n        }\r\n        return '{{' + key + '}}';\r\n      },\r\n\r\n      // debug\r\n      getData: function() { return gL10nData; },\r\n      getText: function() { return gTextData; },\r\n\r\n      // get|set the document language\r\n      getLanguage: function() { return gLanguage; },\r\n      setLanguage: function(lang, callback) {\r\n        loadLocale(lang, function() {\r\n          if (callback)\r\n            callback();\r\n        });\r\n      },\r\n\r\n      // get the direction (ltr|rtl) of the current language\r\n      getDirection: function() {\r\n        // http://www.w3.org/International/questions/qa-scripts\r\n        // Arabic, Hebrew, Farsi, Pashto, Urdu\r\n        var rtlList = ['ar', 'he', 'fa', 'ps', 'ur'];\r\n        var shortCode = gLanguage.split('-', 1)[0];\r\n        return (rtlList.indexOf(shortCode) >= 0) ? 'rtl' : 'ltr';\r\n      },\r\n\r\n      // translate an element or document fragment\r\n      translate: translateFragment,\r\n\r\n      // this can be used to prevent race conditions\r\n      getReadyState: function() { return gReadyState; },\r\n      ready: function(callback) {\r\n        if (!callback) {\r\n          return;\r\n        } else if (gReadyState == 'complete' || gReadyState == 'interactive') {\r\n          window.setTimeout(function() {\r\n            callback();\r\n          });\r\n        } else if (document.addEventListener) {\r\n          document.addEventListener('localized', function once() {\r\n            document.removeEventListener('localized', once);\r\n            callback();\r\n          });\r\n        }\r\n      }\r\n    };\r\n  }) (window, document);\r\n\r\n});\ndefine('skylark-pdfjs-viewer/genericl10n',[\n  \"./l10n\"\n],function(webL10n){\n  /* Copyright 2017 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n\n  //const webL10n = document.webL10n;\n\n  class GenericL10n {\n    constructor(lang) {\n      this._lang = lang;\n      this._ready = new Promise((resolve, reject) => {\n        webL10n.setLanguage(lang, () => {\n          resolve(webL10n);\n        });\n      });\n    }\n\n    async getLanguage() {\n      const l10n = await this._ready;\n      return l10n.getLanguage();\n    }\n\n    async getDirection() {\n      const l10n = await this._ready;\n      return l10n.getDirection();\n    }\n\n    async get(property, args, fallback) {\n      const l10n = await this._ready;\n      return l10n.get(property, args, fallback);\n    }\n\n    async translate(element) {\n      const l10n = await this._ready;\n      return l10n.translate(element);\n    }\n  }\n\n  return { GenericL10n };\n});\ndefine('skylark-pdfjs-viewer/generic_scripting',[\n  \"skylark-pdfjs-display\"\n],function(pdfjsLib){\n  /* Copyright 2020 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { loadScript } = pdfjsLib;\n\n  class GenericScripting {\n    constructor(sandboxBundleSrc) {\n      this._ready = loadScript(\n        sandboxBundleSrc,\n        /* removeScriptElement = */ true\n      ).then(() => {\n        return window.pdfjsSandbox.QuickJSSandbox();\n      });\n    }\n\n    async createSandbox(data) {\n      const sandbox = await this._ready;\n      sandbox.create(data);\n    }\n\n    async dispatchEventInSandbox(event) {\n      const sandbox = await this._ready;\n      sandbox.dispatchEvent(event);\n    }\n\n    async destroySandbox() {\n      const sandbox = await this._ready;\n      sandbox.nukeSandbox();\n    }\n  }\n\n  return { GenericScripting };\n});\ndefine('skylark-pdfjs-viewer/genericcom',[\n  \"./pdfjs_dev\",\n  \"./app\",\n  \"./preferences\",\n  \"./download_manager\",\n  \"./genericl10n\",\n  \"./generic_scripting\"\n],function(\n  PDFJSDev,\n  app,\n  preferences,\n  download_manager,\n  genericl10n,\n  generic_scripting\n){\n  /* Copyright 2017 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { DefaultExternalServices, PDFViewerApplication } = app;\n  const { BasePreferences } = preferences;\n  const { DownloadManager } = download_manager;\n  const { GenericL10n } = genericl10n;\n  const { GenericScripting } = generic_scripting;\n\n  if (typeof PDFJSDev !== \"undefined\" && !PDFJSDev.test(\"GENERIC\")) {\n    throw new Error(\n      'Module \"pdfjs-web/genericcom\" shall not be used outside ' +\n        \"GENERIC build.\"\n    );\n  }\n\n  const GenericCom = {};\n\n  class GenericPreferences extends BasePreferences {\n    async _writeToStorage(prefObj) {\n      localStorage.setItem(\"pdfjs.preferences\", JSON.stringify(prefObj));\n    }\n\n    async _readFromStorage(prefObj) {\n      return JSON.parse(localStorage.getItem(\"pdfjs.preferences\"));\n    }\n  }\n\n  class GenericExternalServices extends DefaultExternalServices {\n    static createDownloadManager(options) {\n      return new DownloadManager();\n    }\n\n    static createPreferences() {\n      return new GenericPreferences();\n    }\n\n    static createL10n({ locale = \"en-US\" }) {\n      return new GenericL10n(locale);\n    }\n\n    static createScripting({ sandboxBundleSrc }) {\n      return new GenericScripting(sandboxBundleSrc);\n    }\n  }\n  PDFViewerApplication.externalServices = GenericExternalServices;\n\n  return { GenericCom };\n});\ndefine('skylark-pdfjs-viewer/pdf_print_service',[\n  \"./ui_utils\",\n  \"./app\",\n  \"./viewer_compatibility\"\n],function(ui_utils,app,viewer_compatibility){\n  /* Copyright 2016 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n    const { CSS_UNITS, NullL10n } = ui_utils;\n    const { PDFPrintServiceFactory, PDFViewerApplication } = app;\n    const { viewerCompatibilityParams } = viewer_compatibility;\n\n    let activeService = null;\n    let overlayManager = null;\n\n    // Renders the page to the canvas of the given print service, and returns\n    // the suggested dimensions of the output page.\n    function renderPage(\n      activeServiceOnEntry,\n      pdfDocument,\n      pageNumber,\n      size,\n      printResolution,\n      optionalContentConfigPromise\n    ) {\n      const scratchCanvas = activeService.scratchCanvas;\n\n      // The size of the canvas in pixels for printing.\n      const PRINT_UNITS = printResolution / 72.0;\n      scratchCanvas.width = Math.floor(size.width * PRINT_UNITS);\n      scratchCanvas.height = Math.floor(size.height * PRINT_UNITS);\n\n      // The physical size of the img as specified by the PDF document.\n      const width = Math.floor(size.width * CSS_UNITS) + \"px\";\n      const height = Math.floor(size.height * CSS_UNITS) + \"px\";\n\n      const ctx = scratchCanvas.getContext(\"2d\");\n      ctx.save();\n      ctx.fillStyle = \"rgb(255, 255, 255)\";\n      ctx.fillRect(0, 0, scratchCanvas.width, scratchCanvas.height);\n      ctx.restore();\n\n      return pdfDocument\n        .getPage(pageNumber)\n        .then(function (pdfPage) {\n          const renderContext = {\n            canvasContext: ctx,\n            transform: [PRINT_UNITS, 0, 0, PRINT_UNITS, 0, 0],\n            viewport: pdfPage.getViewport({ scale: 1, rotation: size.rotation }),\n            intent: \"print\",\n            annotationStorage: pdfDocument.annotationStorage,\n            optionalContentConfigPromise,\n          };\n          return pdfPage.render(renderContext).promise;\n        })\n        .then(function () {\n          return {\n            width,\n            height,\n          };\n        });\n    }\n\n    function PDFPrintService(\n      pdfDocument,\n      pagesOverview,\n      printContainer,\n      printResolution,\n      optionalContentConfigPromise = null,\n      l10n\n    ) {\n      this.pdfDocument = pdfDocument;\n      this.pagesOverview = pagesOverview;\n      this.printContainer = printContainer;\n      this._printResolution = printResolution || 150;\n      this._optionalContentConfigPromise =\n        optionalContentConfigPromise || pdfDocument.getOptionalContentConfig();\n      this.l10n = l10n || NullL10n;\n      this.currentPage = -1;\n      // The temporary canvas where renderPage paints one page at a time.\n      this.scratchCanvas = document.createElement(\"canvas\");\n    }\n\n    PDFPrintService.prototype = {\n      layout() {\n        this.throwIfInactive();\n\n        const body = document.querySelector(\"body\");\n        body.setAttribute(\"data-pdfjsprinting\", true);\n\n        const hasEqualPageSizes = this.pagesOverview.every(function (size) {\n          return (\n            size.width === this.pagesOverview[0].width &&\n            size.height === this.pagesOverview[0].height\n          );\n        }, this);\n        if (!hasEqualPageSizes) {\n          console.warn(\n            \"Not all pages have the same size. The printed \" +\n              \"result may be incorrect!\"\n          );\n        }\n\n        // Insert a @page + size rule to make sure that the page size is correctly\n        // set. Note that we assume that all pages have the same size, because\n        // variable-size pages are not supported yet (e.g. in Chrome & Firefox).\n        // TODO(robwu): Use named pages when size calculation bugs get resolved\n        // (e.g. https://crbug.com/355116) AND when support for named pages is\n        // added (http://www.w3.org/TR/css3-page/#using-named-pages).\n        // In browsers where @page + size is not supported (such as Firefox,\n        // https://bugzil.la/851441), the next stylesheet will be ignored and the\n        // user has to select the correct paper size in the UI if wanted.\n        this.pageStyleSheet = document.createElement(\"style\");\n        const pageSize = this.pagesOverview[0];\n        this.pageStyleSheet.textContent =\n          // \"size:<width> <height>\" is what we need. But also add \"A4\" because\n          // Firefox incorrectly reports support for the other value.\n          \"@supports ((size:A4) and (size:1pt 1pt)) {\" +\n          \"@page { size: \" +\n          pageSize.width +\n          \"pt \" +\n          pageSize.height +\n          \"pt;}\" +\n          \"}\";\n        body.appendChild(this.pageStyleSheet);\n      },\n\n      destroy() {\n        if (activeService !== this) {\n          // |activeService| cannot be replaced without calling destroy() first,\n          // so if it differs then an external consumer has a stale reference to\n          // us.\n          return;\n        }\n        this.printContainer.textContent = \"\";\n\n        const body = document.querySelector(\"body\");\n        body.removeAttribute(\"data-pdfjsprinting\");\n\n        if (this.pageStyleSheet) {\n          this.pageStyleSheet.remove();\n          this.pageStyleSheet = null;\n        }\n        this.scratchCanvas.width = this.scratchCanvas.height = 0;\n        this.scratchCanvas = null;\n        activeService = null;\n        ensureOverlay().then(function () {\n          if (overlayManager.active !== \"printServiceOverlay\") {\n            return; // overlay was already closed\n          }\n          overlayManager.close(\"printServiceOverlay\");\n        });\n      },\n\n      renderPages() {\n        const pageCount = this.pagesOverview.length;\n        const renderNextPage = (resolve, reject) => {\n          this.throwIfInactive();\n          if (++this.currentPage >= pageCount) {\n            renderProgress(pageCount, pageCount, this.l10n);\n            resolve();\n            return;\n          }\n          const index = this.currentPage;\n          renderProgress(index, pageCount, this.l10n);\n          renderPage(\n            this,\n            this.pdfDocument,\n            /* pageNumber = */ index + 1,\n            this.pagesOverview[index],\n            this._printResolution,\n            this._optionalContentConfigPromise\n          )\n            .then(this.useRenderedPage.bind(this))\n            .then(function () {\n              renderNextPage(resolve, reject);\n            }, reject);\n        };\n        return new Promise(renderNextPage);\n      },\n\n      useRenderedPage(printItem) {\n        this.throwIfInactive();\n        const img = document.createElement(\"img\");\n        img.style.width = printItem.width;\n        img.style.height = printItem.height;\n\n        const scratchCanvas = this.scratchCanvas;\n        if (\n          \"toBlob\" in scratchCanvas &&\n          !viewerCompatibilityParams.disableCreateObjectURL\n        ) {\n          scratchCanvas.toBlob(function (blob) {\n            img.src = URL.createObjectURL(blob);\n          });\n        } else {\n          img.src = scratchCanvas.toDataURL();\n        }\n\n        const wrapper = document.createElement(\"div\");\n        wrapper.appendChild(img);\n        this.printContainer.appendChild(wrapper);\n\n        return new Promise(function (resolve, reject) {\n          img.onload = resolve;\n          img.onerror = reject;\n        });\n      },\n\n      performPrint() {\n        this.throwIfInactive();\n        return new Promise(resolve => {\n          // Push window.print in the macrotask queue to avoid being affected by\n          // the deprecation of running print() code in a microtask, see\n          // https://github.com/mozilla/pdf.js/issues/7547.\n          setTimeout(() => {\n            if (!this.active) {\n              resolve();\n              return;\n            }\n            print.call(window);\n            // Delay promise resolution in case print() was not synchronous.\n            setTimeout(resolve, 20); // Tidy-up.\n          }, 0);\n        });\n      },\n\n      get active() {\n        return this === activeService;\n      },\n\n      throwIfInactive() {\n        if (!this.active) {\n          throw new Error(\"This print request was cancelled or completed.\");\n        }\n      },\n    };\n\n    const print = window.print;\n    window.print = function () {\n      if (activeService) {\n        console.warn(\"Ignored window.print() because of a pending print job.\");\n        return;\n      }\n      ensureOverlay().then(function () {\n        if (activeService) {\n          overlayManager.open(\"printServiceOverlay\");\n        }\n      });\n\n      try {\n        dispatchEvent(\"beforeprint\");\n      } finally {\n        if (!activeService) {\n          console.error(\"Expected print service to be initialized.\");\n          ensureOverlay().then(function () {\n            if (overlayManager.active === \"printServiceOverlay\") {\n              overlayManager.close(\"printServiceOverlay\");\n            }\n          });\n          return; // eslint-disable-line no-unsafe-finally\n        }\n        const activeServiceOnEntry = activeService;\n        activeService\n          .renderPages()\n          .then(function () {\n            return activeServiceOnEntry.performPrint();\n          })\n          .catch(function () {\n            // Ignore any error messages.\n          })\n          .then(function () {\n            // aborts acts on the \"active\" print request, so we need to check\n            // whether the print request (activeServiceOnEntry) is still active.\n            // Without the check, an unrelated print request (created after aborting\n            // this print request while the pages were being generated) would be\n            // aborted.\n            if (activeServiceOnEntry.active) {\n              abort();\n            }\n          });\n      }\n    };\n\n    function dispatchEvent(eventType) {\n      const event = document.createEvent(\"CustomEvent\");\n      event.initCustomEvent(eventType, false, false, \"custom\");\n      window.dispatchEvent(event);\n    }\n\n    function abort() {\n      if (activeService) {\n        activeService.destroy();\n        dispatchEvent(\"afterprint\");\n      }\n    }\n\n    function renderProgress(index, total, l10n) {\n      const progressContainer = document.getElementById(\"printServiceOverlay\");\n      const progress = Math.round((100 * index) / total);\n      const progressBar = progressContainer.querySelector(\"progress\");\n      const progressPerc = progressContainer.querySelector(\".relative-progress\");\n      progressBar.value = progress;\n      l10n.get(\"print_progress_percent\", { progress }, progress + \"%\").then(msg => {\n        progressPerc.textContent = msg;\n      });\n    }\n\n    window.addEventListener(\n      \"keydown\",\n      function (event) {\n        // Intercept Cmd/Ctrl + P in all browsers.\n        // Also intercept Cmd/Ctrl + Shift + P in Chrome and Opera\n        if (\n          event.keyCode === /* P= */ 80 &&\n          (event.ctrlKey || event.metaKey) &&\n          !event.altKey &&\n          (!event.shiftKey || window.chrome || window.opera)\n        ) {\n          window.print();\n\n          // The (browser) print dialog cannot be prevented from being shown in\n          // IE11.\n          event.preventDefault();\n          if (event.stopImmediatePropagation) {\n            event.stopImmediatePropagation();\n          } else {\n            event.stopPropagation();\n          }\n        }\n      },\n      true\n    );\n\n    if (\"onbeforeprint\" in window) {\n      // Do not propagate before/afterprint events when they are not triggered\n      // from within this polyfill. (FF / Chrome 63+).\n      const stopPropagationIfNeeded = function (event) {\n        if (event.detail !== \"custom\" && event.stopImmediatePropagation) {\n          event.stopImmediatePropagation();\n        }\n      };\n      window.addEventListener(\"beforeprint\", stopPropagationIfNeeded);\n      window.addEventListener(\"afterprint\", stopPropagationIfNeeded);\n    }\n\n    let overlayPromise;\n    function ensureOverlay() {\n      if (!overlayPromise) {\n        overlayManager = PDFViewerApplication.overlayManager;\n        if (!overlayManager) {\n          throw new Error(\"The overlay manager has not yet been initialized.\");\n        }\n\n        overlayPromise = overlayManager.register(\n          \"printServiceOverlay\",\n          document.getElementById(\"printServiceOverlay\"),\n          abort,\n          true\n        );\n        document.getElementById(\"printCancel\").onclick = abort;\n      }\n      return overlayPromise;\n    }\n\n    PDFPrintServiceFactory.instance = {\n      supportsPrinting: true,\n\n      createPrintService(\n        pdfDocument,\n        pagesOverview,\n        printContainer,\n        printResolution,\n        optionalContentConfigPromise,\n        l10n\n      ) {\n        if (activeService) {\n          throw new Error(\"The print service is created and active.\");\n        }\n        activeService = new PDFPrintService(\n          pdfDocument,\n          pagesOverview,\n          printContainer,\n          printResolution,\n          optionalContentConfigPromise,\n          l10n\n        );\n        return activeService;\n      },\n    };\n\n    return { PDFPrintService };\n});\ndefine('skylark-pdfjs-viewer/viewer',[\n  \"./pdfjs_dev\",\n  \"./app_options\",\n  \"./app\",\n  \"./genericcom\",\n  \"./pdf_print_service\"\n],function(\n  PDFJSDev,\n  app_options,\n  app\n){\n  /* Copyright 2016 Mozilla Foundation\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  const { AppOptions } = app_options;\n  const { PDFViewerApplication } = app;\n\n  /* eslint-disable-next-line no-unused-vars */\n  const pdfjsVersion =\n    typeof PDFJSDev !== \"undefined\" ? PDFJSDev.eval(\"BUNDLE_VERSION\") : void 0;\n  /* eslint-disable-next-line no-unused-vars */\n  const pdfjsBuild =\n    typeof PDFJSDev !== \"undefined\" ? PDFJSDev.eval(\"BUNDLE_BUILD\") : void 0;\n\n  window.PDFViewerApplication = PDFViewerApplication;\n  window.PDFViewerApplicationOptions = AppOptions;\n\n  if (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"CHROME\")) {\n    var defaultUrl; // eslint-disable-line no-var\n\n    (function rewriteUrlClosure() {\n      // Run this code outside DOMContentLoaded to make sure that the URL\n      // is rewritten as soon as possible.\n      const queryString = document.location.search.slice(1);\n      const m = /(^|&)file=([^&]*)/.exec(queryString);\n      defaultUrl = m ? decodeURIComponent(m[2]) : \"\";\n\n      // Example: chrome-extension://.../http://example.com/file.pdf\n      const humanReadableUrl = \"/\" + defaultUrl + location.hash;\n      history.replaceState(history.state, \"\", humanReadableUrl);\n      if (top === window) {\n        // eslint-disable-next-line no-undef\n        chrome.runtime.sendMessage(\"showPageAction\");\n      }\n    })();\n  }\n\n  //TODO : checking\n  ///if (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"MOZCENTRAL\")) {\n  ///  require(\"./firefoxcom.js\");\n  ///  require(\"./firefox_print_service.js\");\n  ///}\n  ///if (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"GENERIC\")) {\n  ///  require(\"./genericcom.js\");\n  ///}\n  ///if (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"CHROME\")) {\n  ///  require(\"./chromecom.js\");\n  ///}\n  ///if (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"CHROME || GENERIC\")) {\n  ///  require(\"./pdf_print_service.js\");\n  ///}\n\n  function getViewerConfiguration() {\n    return {\n      appContainer: document.body,\n      mainContainer: document.getElementById(\"viewerContainer\"),\n      viewerContainer: document.getElementById(\"viewer\"),\n      eventBus: null,\n      toolbar: {\n        container: document.getElementById(\"toolbarViewer\"),\n        numPages: document.getElementById(\"numPages\"),\n        pageNumber: document.getElementById(\"pageNumber\"),\n        scaleSelectContainer: document.getElementById(\"scaleSelectContainer\"),\n        scaleSelect: document.getElementById(\"scaleSelect\"),\n        customScaleOption: document.getElementById(\"customScaleOption\"),\n        previous: document.getElementById(\"previous\"),\n        next: document.getElementById(\"next\"),\n        zoomIn: document.getElementById(\"zoomIn\"),\n        zoomOut: document.getElementById(\"zoomOut\"),\n        viewFind: document.getElementById(\"viewFind\"),\n        openFile: document.getElementById(\"openFile\"),\n        print: document.getElementById(\"print\"),\n        presentationModeButton: document.getElementById(\"presentationMode\"),\n        download: document.getElementById(\"download\"),\n        viewBookmark: document.getElementById(\"viewBookmark\"),\n      },\n      secondaryToolbar: {\n        toolbar: document.getElementById(\"secondaryToolbar\"),\n        toggleButton: document.getElementById(\"secondaryToolbarToggle\"),\n        toolbarButtonContainer: document.getElementById(\n          \"secondaryToolbarButtonContainer\"\n        ),\n        presentationModeButton: document.getElementById(\n          \"secondaryPresentationMode\"\n        ),\n        openFileButton: document.getElementById(\"secondaryOpenFile\"),\n        printButton: document.getElementById(\"secondaryPrint\"),\n        downloadButton: document.getElementById(\"secondaryDownload\"),\n        viewBookmarkButton: document.getElementById(\"secondaryViewBookmark\"),\n        firstPageButton: document.getElementById(\"firstPage\"),\n        lastPageButton: document.getElementById(\"lastPage\"),\n        pageRotateCwButton: document.getElementById(\"pageRotateCw\"),\n        pageRotateCcwButton: document.getElementById(\"pageRotateCcw\"),\n        cursorSelectToolButton: document.getElementById(\"cursorSelectTool\"),\n        cursorHandToolButton: document.getElementById(\"cursorHandTool\"),\n        scrollVerticalButton: document.getElementById(\"scrollVertical\"),\n        scrollHorizontalButton: document.getElementById(\"scrollHorizontal\"),\n        scrollWrappedButton: document.getElementById(\"scrollWrapped\"),\n        spreadNoneButton: document.getElementById(\"spreadNone\"),\n        spreadOddButton: document.getElementById(\"spreadOdd\"),\n        spreadEvenButton: document.getElementById(\"spreadEven\"),\n        documentPropertiesButton: document.getElementById(\"documentProperties\"),\n      },\n      fullscreen: {\n        contextFirstPage: document.getElementById(\"contextFirstPage\"),\n        contextLastPage: document.getElementById(\"contextLastPage\"),\n        contextPageRotateCw: document.getElementById(\"contextPageRotateCw\"),\n        contextPageRotateCcw: document.getElementById(\"contextPageRotateCcw\"),\n      },\n      sidebar: {\n        // Divs (and sidebar button)\n        outerContainer: document.getElementById(\"outerContainer\"),\n        viewerContainer: document.getElementById(\"viewerContainer\"),\n        toggleButton: document.getElementById(\"sidebarToggle\"),\n        // Buttons\n        thumbnailButton: document.getElementById(\"viewThumbnail\"),\n        outlineButton: document.getElementById(\"viewOutline\"),\n        attachmentsButton: document.getElementById(\"viewAttachments\"),\n        layersButton: document.getElementById(\"viewLayers\"),\n        // Views\n        thumbnailView: document.getElementById(\"thumbnailView\"),\n        outlineView: document.getElementById(\"outlineView\"),\n        attachmentsView: document.getElementById(\"attachmentsView\"),\n        layersView: document.getElementById(\"layersView\"),\n        // View-specific options\n        outlineOptionsContainer: document.getElementById(\n          \"outlineOptionsContainer\"\n        ),\n        currentOutlineItemButton: document.getElementById(\"currentOutlineItem\"),\n      },\n      sidebarResizer: {\n        outerContainer: document.getElementById(\"outerContainer\"),\n        resizer: document.getElementById(\"sidebarResizer\"),\n      },\n      findBar: {\n        bar: document.getElementById(\"findbar\"),\n        toggleButton: document.getElementById(\"viewFind\"),\n        findField: document.getElementById(\"findInput\"),\n        highlightAllCheckbox: document.getElementById(\"findHighlightAll\"),\n        caseSensitiveCheckbox: document.getElementById(\"findMatchCase\"),\n        entireWordCheckbox: document.getElementById(\"findEntireWord\"),\n        findMsg: document.getElementById(\"findMsg\"),\n        findResultsCount: document.getElementById(\"findResultsCount\"),\n        findPreviousButton: document.getElementById(\"findPrevious\"),\n        findNextButton: document.getElementById(\"findNext\"),\n      },\n      passwordOverlay: {\n        overlayName: \"passwordOverlay\",\n        container: document.getElementById(\"passwordOverlay\"),\n        label: document.getElementById(\"passwordText\"),\n        input: document.getElementById(\"password\"),\n        submitButton: document.getElementById(\"passwordSubmit\"),\n        cancelButton: document.getElementById(\"passwordCancel\"),\n      },\n      documentProperties: {\n        overlayName: \"documentPropertiesOverlay\",\n        container: document.getElementById(\"documentPropertiesOverlay\"),\n        closeButton: document.getElementById(\"documentPropertiesClose\"),\n        fields: {\n          fileName: document.getElementById(\"fileNameField\"),\n          fileSize: document.getElementById(\"fileSizeField\"),\n          title: document.getElementById(\"titleField\"),\n          author: document.getElementById(\"authorField\"),\n          subject: document.getElementById(\"subjectField\"),\n          keywords: document.getElementById(\"keywordsField\"),\n          creationDate: document.getElementById(\"creationDateField\"),\n          modificationDate: document.getElementById(\"modificationDateField\"),\n          creator: document.getElementById(\"creatorField\"),\n          producer: document.getElementById(\"producerField\"),\n          version: document.getElementById(\"versionField\"),\n          pageCount: document.getElementById(\"pageCountField\"),\n          pageSize: document.getElementById(\"pageSizeField\"),\n          linearized: document.getElementById(\"linearizedField\"),\n        },\n      },\n      errorWrapper: {\n        container: document.getElementById(\"errorWrapper\"),\n        errorMessage: document.getElementById(\"errorMessage\"),\n        closeButton: document.getElementById(\"errorClose\"),\n        errorMoreInfo: document.getElementById(\"errorMoreInfo\"),\n        moreInfoButton: document.getElementById(\"errorShowMore\"),\n        lessInfoButton: document.getElementById(\"errorShowLess\"),\n      },\n      printContainer: document.getElementById(\"printContainer\"),\n      openFileInputName: \"fileInput\",\n      debuggerScriptPath: \"./debugger.js\",\n    };\n  }\n\n  function webViewerLoad() {\n    const config = getViewerConfiguration();\n    if (typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"PRODUCTION\")) {\n        PDFViewerApplication.run(config);\n    } else {\n      if (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"CHROME\")) {\n        AppOptions.set(\"defaultUrl\", defaultUrl);\n      }\n\n      if (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"GENERIC\")) {\n        // Give custom implementations of the default viewer a simpler way to\n        // set various `AppOptions`, by dispatching an event once all viewer\n        // files are loaded but *before* the viewer initialization has run.\n        const event = document.createEvent(\"CustomEvent\");\n        event.initCustomEvent(\"webviewerloaded\", true, true, {\n          source: window,\n        });\n        try {\n          // Attempt to dispatch the event at the embedding `document`,\n          // in order to support cases where the viewer is embedded in\n          // a *dynamically* created <iframe> element.\n          parent.document.dispatchEvent(event);\n        } catch (ex) {\n          // The viewer could be in e.g. a cross-origin <iframe> element,\n          // fallback to dispatching the event at the current `document`.\n          console.error(`webviewerloaded: ${ex}`);\n          document.dispatchEvent(event);\n        }\n      }\n\n      PDFViewerApplication.run(config);\n    }\n  }\n\n\n  function init() {\n    if (\n      document.readyState === \"interactive\" ||\n      document.readyState === \"complete\"\n    ) {\n      webViewerLoad();\n    } else {\n      document.addEventListener(\"DOMContentLoaded\", webViewerLoad, true);\n    }    \n  }\n\n\n  return { \n    init,\n    PDFViewerApplication, \n    PDFViewerApplicationOptions : AppOptions  \n  };\n});\ndefine('skylark-pdfjs-viewer/main',[\r\n\t\"./viewer\"\t\r\n],function(viewer){\r\n\treturn viewer;\r\n});\ndefine('skylark-pdfjs-viewer', ['skylark-pdfjs-viewer/main'], function (main) { return main; });\n\n"]}